<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>《Node.js 设计模式》读书笔记 第一章 | 七秒悲伤的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Welcome to the Node.js PlatformSmall modules(小模块)Node.js使用module(模块)的概念组织代码的结构。package可提供复用的模块，有一个 module 作为入口。Node.js中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：">
<meta name="keywords" content="读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《Node.js 设计模式》读书笔记 第一章">
<meta property="og:url" content="http://1016990109.github.io/2018/05/11/Node-js-设计模式读书笔记-第一章/index.html">
<meta property="og:site_name" content="七秒悲伤的博客">
<meta property="og:description" content="Welcome to the Node.js PlatformSmall modules(小模块)Node.js使用module(模块)的概念组织代码的结构。package可提供复用的模块，有一个 module 作为入口。Node.js中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://1016990109.github.io/assets/img/node_demultiplexer.png">
<meta property="og:image" content="http://1016990109.github.io/assets/img/event_loop.png">
<meta property="og:image" content="http://1016990109.github.io/assets/img/node_architecture.png">
<meta property="og:updated_time" content="2018-05-18T07:45:00.820Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Node.js 设计模式》读书笔记 第一章">
<meta name="twitter:description" content="Welcome to the Node.js PlatformSmall modules(小模块)Node.js使用module(模块)的概念组织代码的结构。package可提供复用的模块，有一个 module 作为入口。Node.js中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：">
<meta name="twitter:image" content="http://1016990109.github.io/assets/img/node_demultiplexer.png">
  
    <link rel="alternative" href="/atom.xml" title="七秒悲伤的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/user.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">七秒悲伤</a></h1>
		</hgroup>

		
		<p class="header-subtitle">一个深藏功与名的软件开发爱好者</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔/">随笔</a></li>
				        
							<li><a href="/instagram">相册</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/1016990109" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/3571600800" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/前端/" style="font-size: 20px;">前端</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://kass.top/">Vboars的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">七秒悲伤</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/user.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">七秒悲伤</h1>
			</hgroup>
			
			<p class="header-subtitle">一个深藏功与名的软件开发爱好者</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔/">随笔</a></li>
		        
					<li><a href="/instagram">相册</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/1016990109" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3571600800" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Node-js-设计模式读书笔记-第一章" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/11/Node-js-设计模式读书笔记-第一章/" class="article-date">
  	<time datetime="2018-05-11T12:00:45.000Z" itemprop="datePublished">2018-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      《Node.js 设计模式》读书笔记 第一章
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Welcome-to-the-Node-js-Platform"><a href="#Welcome-to-the-Node-js-Platform" class="headerlink" title="Welcome to the Node.js Platform"></a>Welcome to the Node.js Platform</h1><h2 id="Small-modules-小模块"><a href="#Small-modules-小模块" class="headerlink" title="Small modules(小模块)"></a>Small modules(小模块)</h2><p><code>Node.js</code>使用<code>module</code>(模块)的概念组织代码的结构。<br><code>package</code>可提供复用的模块，有一个 module 作为入口。<br><code>Node.js</code>中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：</p>
<a id="more"></a>
<blockquote>
<ul>
<li>“Small is beautiful.”(小而精)</li>
<li>“Make each program do one thing well.” (每个程序只有单一的职责)</li>
</ul>
</blockquote>
<p><code>Node.js</code> 通过官方包管理工具<code>npm</code>解决包之间的依赖问题，每个<code>package</code>都有它自己的依赖，故而一个程序中多个<code>package</code>能够无冲突地安装。应用程序都是由一个个很小的、单职责的依赖构成的。</p>
<p><strong>小模块</strong>应该有的特性：</p>
<blockquote>
<ul>
<li>Easier to understand and use(易理解、易用)</li>
<li>Simpler to test and maintain(易于测试和维护)</li>
<li>Perfect to share with the browser(完美支持浏览器)</li>
</ul>
</blockquote>
<p><strong>DRY(Dont’t Repeat Yourself)原则</strong></p>
<h2 id="Small-surface-area-暴露需要的接口"><a href="#Small-surface-area-暴露需要的接口" class="headerlink" title="Small surface area(暴露需要的接口)"></a>Small surface area(暴露需要的接口)</h2><p>一般使用者只会用到很有限的功能，而很少去  扩展一个模块，所以<code>Node.js</code>的很多模块只会暴露一个函数或者一个构造器，然后把更细节的东西都放在函数或者构造器里，这样能帮助  使用者认清什么是主要的什么是次要的.</p>
<p>模块是不允许被扩展的，看起来扩展性低，但实际上有很多优势：减少了应用场景(这样考虑的情况就少了，容易实现)，简化了实现，便于维护，提高了可用性。</p>
<h2 id="Simplicity-and-progmatism-简单而实用"><a href="#Simplicity-and-progmatism-简单而实用" class="headerlink" title="Simplicity and progmatism(简单而实用)"></a>Simplicity and progmatism(简单而实用)</h2><blockquote>
<p>简单就是复杂到极致。—— 达尔文</p>
</blockquote>
<blockquote>
<p>设计必须简单， 不管是实现还是接口。实现的简洁比接口的简洁更重要。设计中最重要的就是简洁。—— Richard P.Gabriel(一位杰出的计算机科学家)</p>
</blockquote>
<p>设计简单的而不是完美或功能完备的软件是一个好的实践：</p>
<ul>
<li> 更容易实现</li>
<li>更少的资源，传输更快</li>
<li>更容易适应</li>
<li>容易维护和理解</li>
</ul>
<p>设计简单这个原则同样也适用于<code>JavaScript</code>，简单函数、闭包、<code>object</code>替代了复杂的类继承。</p>
<h2 id="Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6"><a href="#Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6" class="headerlink" title="Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)"></a>Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)</h2><h3 id="The-let-and-const-keywords-let-和-const-关键字"><a href="#The-let-and-const-keywords-let-和-const-关键字" class="headerlink" title="The let and const keywords(let 和 const 关键字)"></a>The let and const keywords(let 和 const 关键字)</h3><p>在之前(ES2015 之前)，<code>js</code>只支持函数作用域和全局作用域，例如在 if 中声明一个变量却能在 if 块之外访问：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>但是使用<code>let</code>关键字后，if 块外就访问不到其中声明的变量了，这在一定程度上能减少因为误操作其中的变量而导致的 bug：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>关键字用于声明不可变变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">'This will never change'</span></span><br><span class="line">x = <span class="string">'...'</span></span><br><span class="line"><span class="comment">//TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>const</code>  是意味着变量的绑定不变而不是内容不变，示例入下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cosnt x = &#123;&#125;</span><br><span class="line">x.name = <span class="string">'John'</span><span class="comment">//work</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">null</span><span class="comment">//don't work</span></span><br></pre></td></tr></table></figure>
<p>通常来说引入模块使用 <code>const</code>防止模块发生变化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> path = <span class="string">'./some/path'</span> <span class="comment">//fail</span></span><br></pre></td></tr></table></figure>
<p>如果你想要创建一个不可更改的对象，<code>const</code>是不够的，你可以使用 ES5 的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">Object.freeze()</a>或者 <a href="https://www.npmjs.com/package/deep-freeze" target="_blank" rel="noopener">deep-freeze</a>模块，或者我使用<code>react</code>框架时候经常用的<a href="https://www.npmjs.com/package/immutable" target="_blank" rel="noopener">immutable</a>模块也可以。</p>
<blockquote>
<p>扩展——这里提一下<strong>ES5</strong>中<code>freeze</code>和<code>seal</code>的区别，<code>seal</code>只限制无法增加和删除对象属性 ，而<code>freeze</code>在<code>seal</code>的基础上还限制了不可更改对象的属性。</p>
</blockquote>
<h3 id="The-arrow-function-箭头函数"><a href="#The-arrow-function-箭头函数" class="headerlink" title="The arrow function(箭头函数)"></a>The arrow function(箭头函数)</h3><p>箭头函数是<strong>ES6</strong>的一大亮点，能很大程度上简化代码。一个参数可以不需要圆括号，函数体只有一行且结果为返回值可不需要花括号，具体示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> event = numbers.filter(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event2 = numbers.filter(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>箭头函数中 this 的指向跟随父函数，示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DelayedGreeter</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DelayedGreeter.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> DelayedGreeter(<span class="string">'World'</span>).greet() <span class="comment">//Hello undefined</span></span><br><span class="line"></span><br><span class="line">DelayedGreeter.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> DelayedGreeter(<span class="string">'World'</span>).greet() <span class="comment">//Hello World</span></span><br></pre></td></tr></table></figure>
<h3 id="Class-syntax-Class-语法"><a href="#Class-syntax-Class-语法" class="headerlink" title="Class syntax(Class 语法)"></a>Class syntax(Class 语法)</h3><p><code>class</code>只是个语法糖，使用 class 实现对象继承并不是通过<code>class</code>继承的，还是通过内部的 prototypes，properties 实现继承，但是<code>class</code>使得程序可读性变强了。</p>
<p>让我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂，晦涩难懂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, surname, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.surname = surname</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.surname</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.older = <span class="function"><span class="keyword">function</span>(<span class="params">person1, person2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易懂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, surname, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.surname = surname</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.surname</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> older(person1, person2) &#123;</span><br><span class="line">    <span class="keyword">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonWithMiddlename</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, middlename, surname, age) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, surname, age)</span><br><span class="line">    <span class="keyword">this</span>.middlename = middlename</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.middlename + <span class="string">' '</span> + <span class="keyword">this</span>.surname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Enhanced-object-literals-对象字面量语法增强"><a href="#Enhanced-object-literals-对象字面量语法增强" class="headerlink" title="Enhanced object literals(对象字面量语法增强)"></a>Enhanced object literals(对象字面量语法增强)</h3><ul>
<li>缺省键值，属性名和变量名相同时可省略属性名</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">22</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">17</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>计算属性，属性可以是由变量计算而来</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> namespace = <span class="string">'-webkit-'</span></span><br><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">  [namespace + <span class="string">'box-sizing'</span>]: <span class="string">'border-box'</span>,</span><br><span class="line">  [namespace + <span class="string">'box-shadow'</span>]: <span class="string">'10px 10px 5px #888888'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>getter 和 setter</li>
</ul>
<p>先看例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'George'</span>,</span><br><span class="line">  surname: <span class="string">'Boole'</span>,</span><br><span class="line">  get fullname() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">''</span> + <span class="keyword">this</span>.surname</span><br><span class="line">  &#125;,</span><br><span class="line">  set fullname(fullname) &#123;</span><br><span class="line">    <span class="keyword">let</span> parts = fullname.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">this</span>.name = parts[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">this</span>.surname = parts[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.fullname) <span class="comment">// "George Boole"</span></span><br><span class="line"><span class="built_in">console</span>.log((person.fullname = <span class="string">'Alan Turing'</span>)) <span class="comment">// "Alan Turing"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "Alan"</span></span><br></pre></td></tr></table></figure>
<p>可以看到第二个 console.log 输出的是“Alan Turing”，这是因为调用 set 后默认返回 get 获得的值。</p>
<h3 id="Map-and-Set-collections-Map-和-Set-集合"><a href="#Map-and-Set-collections-Map-和-Set-集合" class="headerlink" title="Map and Set collections(Map 和 Set 集合)"></a>Map and Set collections(Map 和 Set 集合)</h3><p>原来我们建立 hash map 的时候都是用<code>object</code>来完成的，而现在可以直接使用<code>Map</code>原型，提供了 set、get、has、delete 方法和 size 属性，比使用<code>object</code>更加直接、简单，遍历可使用<code>for...of</code>语法，这种遍历方式是和 Map 中属性的插入顺序是一样的(这在普通<code>object</code>中是无法保证的)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tests = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">   tests.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>+<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">   tests.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>*<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">   tests.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>/<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> tests) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log((entry[<span class="number">0</span>]() === entry[<span class="number">1</span>])   <span class="string">'PASS'</span> : <span class="string">'FAIL'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Set</code>只允许存在不同的值，和数学上的集合是一个概念，里面内容可以是<code>number</code>也可以是<code>object</code>或<code>function</code>，除了 set 换成 add 外其他的都与 map 相同，遍历时每一个 entry 内容是 value。</p>
<h3 id="WeakMap-and-WeakSet-collections"><a href="#WeakMap-and-WeakSet-collections" class="headerlink" title="WeakMap and WeakSet collections"></a>WeakMap and WeakSet collections</h3><p>顾名思义，<code>WeakMap</code>和<code>WeakSet</code>是<code>Map</code>和<code>Set</code>弱化后的原型，但是这其中并无优劣之分，只是适用于不同的场合。</p>
<p><code>WeakMap</code>的<strong>key</strong>只能是非空对象，对<strong>key</strong>仅保持弱引用，最大的好处是可以避免内存泄漏，一旦<strong>key</strong>的引用为空或者 undefined，垃圾回收器就可以回收这个对象，但是<code>WeakMap</code>不能迭代遍历。</p>
<p><code>WeakSet</code>与<code>WeakMap</code>同。</p>
<h3 id="Template-literals-模板字符串"><a href="#Template-literals-模板字符串" class="headerlink" title="Template literals(模板字符串)"></a>Template literals(模板字符串)</h3><p>使用`代替双引号和单引号，在字符串中可以使用表达式${expression}，可以换行。</p>
<h3 id="ES6-其他语法"><a href="#ES6-其他语法" class="headerlink" title="ES6 其他语法"></a>ES6 其他语法</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a>(稍后会详细讲到)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" target="_blank" rel="noopener">函数默认参数</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Rest_parameters" target="_blank" rel="noopener">剩余参数语法</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="noopener">拓展运算符</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="noopener">new.target</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">代理</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener">反射</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol" target="_blank" rel="noopener">Symbol</a></li>
</ul>
<h2 id="The-reactor-pattern"><a href="#The-reactor-pattern" class="headerlink" title="The reactor pattern"></a>The reactor pattern</h2><p><code>reactor</code>模式是 <code>Node.js</code> 异步的核心。</p>
<h3 id="I-O-is-slow-I-O-操作是慢的"><a href="#I-O-is-slow-I-O-操作是慢的" class="headerlink" title="I/O is slow(I/O 操作是慢的)"></a>I/O is slow(I/O 操作是慢的)</h3><p>I/O 操作可以说是计算机操作中最慢的一环，I/O 的速度可能和网络速度、磁盘速率有关，也可能和其他因素有关，比如用户点击事件等等。</p>
<h3 id="Blocking-I-O-阻塞-I-O"><a href="#Blocking-I-O-阻塞-I-O" class="headerlink" title="Blocking I/O(阻塞 I/O)"></a>Blocking I/O(阻塞 I/O)</h3><p>传统的阻塞 I/O 模型中，I/O 请求会阻塞之后代码块的运行，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直到请求完成，数据可用，线程都是阻塞的</span></span><br><span class="line">data = socket.read()</span><br><span class="line"><span class="comment">// 请求完成，数据可用</span></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p>而为了达到并发的  目的，传统的 web 服务器是  选择新开一个线程或进程，这样因为线程(或进程)之间的相互独立性，一个线程(或进程)阻塞并不会影响另一个。</p>
<p>但是创建一个线程是昂贵的，一个线程需要内存，而且切换线程需要保留线程的上下文等等，所以这种方式并不是最佳实践。</p>
<h3 id="Non-blocking-I-O-非阻塞-I-O"><a href="#Non-blocking-I-O-非阻塞-I-O" class="headerlink" title="Non-blocking I/O(非阻塞 I/O)"></a>Non-blocking I/O(非阻塞 I/O)</h3><p>与阻塞 I/O 相反，遇到 I/O 请求不会阻塞后续代码的执行，如果访问的资源不可用则会返回一个预定义的常量值。</p>
<p>非阻塞 I/O 最基本的模式是轮询直到有数据已经返回了，也叫做 <code>忙等待</code>模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resources = [socketA, socketB, pipeA]</span><br><span class="line"><span class="keyword">while</span> (!resources.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resources.length; i++) &#123;</span><br><span class="line">    resource = resources[i]</span><br><span class="line">    <span class="comment">// 进行读操作</span></span><br><span class="line">    <span class="keyword">let</span> data = resource.read()</span><br><span class="line">    <span class="keyword">if</span> (data === NO_DATA_AVAILABLE) &#123;</span><br><span class="line">      <span class="comment">// 此时还没有数据</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// 资源被释放，从队列中移除该链接</span></span><br><span class="line">      resources.remove(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      consumeData(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子已经能有单线程处理多个请求了， 但是不够高效，资源不可用时循环占了太多了 CPU 时间，轮询算法浪费 CPU 时间。</p>
<h3 id="Event-demultiplexing-事件多路复用"><a href="#Event-demultiplexing-事件多路复用" class="headerlink" title="Event demultiplexing(事件多路复用)"></a>Event demultiplexing(事件多路复用)</h3><p>对于获取非阻塞的资源而言，忙等待模型不是一个理想的技术，大多数现代的操作系统都提供了一种机制来处理并发和非阻塞资源，这个机制被称为<code>同步多路复用</code>。</p>
<p>这个组件从一系列被监听的资源中收集 I/O 事件并放入队列中，而且会一直处于阻塞状态直到有新的事件可以被处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">socketA, pipeB;</span><br><span class="line">wachedList.add(socketA, FOR_READ);</span><br><span class="line">wachedList.add(pipeB, FOR_READ);</span><br><span class="line"><span class="keyword">while</span>(events = demultiplexer.watch(wachedList)) &#123;</span><br><span class="line">  <span class="comment">// 事件循环</span></span><br><span class="line">  foreach(event <span class="keyword">in</span> events) &#123;</span><br><span class="line">    <span class="comment">// 永远不会阻塞，并且总会有返回值</span></span><br><span class="line">    data = event.resource.read();</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// 资源已经被释放，从观察者队列移除</span></span><br><span class="line">      demultiplexer.unwatch(event.resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 获得数据进行处理</span></span><br><span class="line">      consumeData(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的三个重要步骤：</p>
<ol>
<li>资源被添加到一个数据结构中，为每个资源关联一个特定的操作，在这个例子中是 read。</li>
<li>事件通知器由一组被观察的资源组成，事件通知器是同步和阻塞的直到有资源可以被<code>read</code>，事件触发后会从调用中返回，之后这些事件可以被处理。</li>
<li>多路复用器返回的每个事件被处理，此时，和事件相关的资源都可用且不会在操作中阻塞。当所有的事件都被处理完后，继续进入循环等待下一个可以被处理的事件。这个被称作为<code>事件循环(event loop)</code>。</li>
</ol>
<p><img src="/assets/img/node_demultiplexer.png" alt="多路复用"></p>
<p>上图帮助我们理解如何在一个单线程中使用多路复用器和非阻塞 I/O 来处理并发。我们能够看到，只使用一个线程并不会影响我们处理多个 I/O 任务的性能。同时，我们看到任务是在单个线程中随着时间的推移而展开的，而不是分散在多个线程中。我们看到，在单线程中传播的任务相对于多线程中传播的任务反而节约了线程的总体空闲时间，并且更利于程序员编写代码。</p>
<h3 id="Introducing-to-reactor-pattern-reactor-模式的介绍"><a href="#Introducing-to-reactor-pattern-reactor-模式的介绍" class="headerlink" title="Introducing to reactor pattern(reactor 模式的介绍)"></a>Introducing to reactor pattern(reactor 模式的介绍)</h3><p>主要思想就是每一个 I/O 操作都有一个<code>handler</code>或者成为回调函数(<code>callback</code>)，当事件发生并且被<code>事件循环</code>处理后，这个回调函数就会被调用：</p>
<p><img src="/assets/img/event_loop.png" alt="event loop"></p>
<p>一个应用使用<code>reactor</code>模式后：</p>
<ol>
<li>应用提交一个请求给事件多路复用器 ，生成 I/O 操作，同时提供事件触发时的<code>handler</code>， 发送请求给事件多路复用器是一个非阻塞的操作，发送后立即返回到应用。</li>
<li>当一组 I/O 操作完成，事件多路复用器会将新来的事件添加到事件队列中。</li>
<li>此时，事件循环会迭代事件队列中的每个事件。</li>
<li>对于每个事件，对应的<code>handler</code>被处理。</li>
<li><code>handler</code>，是应用程序代码的一部分，<code>handler</code>执行结束后执行权会交回事件循环。但是，在<code>handler</code>执行时可能请求新的异步操作，从而新的操作被添加到事件多路复用器。</li>
<li>当事件队列的全部事件被处理完后，事件多路复用器再次阻塞直到有一个新的事件触发。</li>
</ol>
<p>现在来定义 Node.js 的核心模式：<br><code>模式(reactor)</code>这样处理 I/O，阻塞直到有新的事件从被观察的资源中触发，然后将事件派发给相应的<code>handler</code>。</p>
<h3 id="Node-js-非阻塞-I-O-引擎——libuv"><a href="#Node-js-非阻塞-I-O-引擎——libuv" class="headerlink" title="Node.js 非阻塞 I/O 引擎——libuv"></a>Node.js 非阻塞 I/O 引擎——libuv</h3><p>每个操作系统都有不同的接口来实现事件多路复用器，Linux 是 epoll，Mac OSX 是 kqueue，Windows 的 IOCP API，即使是在相同的操作系统中对于不同资源的 I/O 操作也不同，所以 Node.js 使用<code>libuv</code>来统一处理 I/O 操作，来达到兼容不同操作系统的目的。</p>
<h3 id="Node-js-架构"><a href="#Node-js-架构" class="headerlink" title="Node.js 架构"></a>Node.js 架构</h3><p><img src="/assets/img/node_architecture.png" alt="Node.js 架构"></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/05/09/Python-处理excel文件/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Python 处理excel文件</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Node-js-设计模式读书笔记-第一章" data-title="《Node.js 设计模式》读书笔记 第一章" data-url="http://1016990109.github.io/2018/05/11/Node-js-设计模式读书笔记-第一章/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"hcw13"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 七秒悲伤
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>