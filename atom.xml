<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七秒悲伤的博客</title>
  
  <subtitle>一个深藏功与名的软件开发爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1016990109.github.io/"/>
  <updated>2018-07-28T17:32:20.855Z</updated>
  <id>http://1016990109.github.io/</id>
  
  <author>
    <name>七秒悲伤</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第七章</title>
    <link href="http://1016990109.github.io/2018/07/28/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/07/28/Node-js-设计模式读书笔记-第七章/</id>
    <published>2018-07-28T15:36:33.000Z</published>
    <updated>2018-07-28T17:32:20.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wiring-Modules-连接模块"><a href="#Wiring-Modules-连接模块" class="headerlink" title="Wiring Modules(连接模块)"></a>Wiring Modules(连接模块)</h1><p>对模块常见的一个问题就是：将组件X的实例传递到模块Y的最佳方式是什么？</p><p>常见的模式有一下几种：</p><ul><li>硬编码依赖</li><li>依赖注入</li><li>服务定位器</li><li>依赖注入容器</li></ul><a id="more"></a><h2 id="Modules-and-dependencies-模块和依赖"><a href="#Modules-and-dependencies-模块和依赖" class="headerlink" title="Modules and dependencies(模块和依赖)"></a>Modules and dependencies(模块和依赖)</h2><h3 id="The-most-common-dependency-in-Node-js-Node-js中最常见的模块"><a href="#The-most-common-dependency-in-Node-js-Node-js中最常见的模块" class="headerlink" title="The most common dependency in Node.js(Node.js中最常见的模块)"></a>The most common dependency in Node.js(Node.js中最常见的模块)</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Wiring-Modules-连接模块&quot;&gt;&lt;a href=&quot;#Wiring-Modules-连接模块&quot; class=&quot;headerlink&quot; title=&quot;Wiring Modules(连接模块)&quot;&gt;&lt;/a&gt;Wiring Modules(连接模块)&lt;/h1&gt;&lt;p&gt;对模块常见的一个问题就是：将组件X的实例传递到模块Y的最佳方式是什么？&lt;/p&gt;
&lt;p&gt;常见的模式有一下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬编码依赖&lt;/li&gt;
&lt;li&gt;依赖注入&lt;/li&gt;
&lt;li&gt;服务定位器&lt;/li&gt;
&lt;li&gt;依赖注入容器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端——网络</title>
    <link href="http://1016990109.github.io/2018/07/19/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C/"/>
    <id>http://1016990109.github.io/2018/07/19/前端——网络/</id>
    <published>2018-07-19T08:20:00.000Z</published>
    <updated>2018-07-26T15:13:50.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强缓存与协商缓存"><a href="#强缓存与协商缓存" class="headerlink" title="强缓存与协商缓存"></a>强缓存与协商缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>1.<code>Expires</code>：<br>服务器返回的一个时间，在这个时间之前都使用缓存，不发送 <code>http</code> 请求。</p><p>例如：<code>Expires: Thu, 10 Dec 2015 23:21:37 GMT</code></p><p><strong>缺点</strong>：服务器的时间和客户端不同会出现问题，老版本 <code>http 1.0</code> 中才使用，现在一般使用 <code>Cache-Contorl</code>。</p><p>2.<code>Cache-Control</code>(优先级高)：<br>声明一个相对的秒数，表示从现在起一段时间内缓存都有效，也不会发送 <code>http</code> 请求。</p><p>例如：<code>Cache-Control: max-age=3600</code></p><a id="more"></a><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>1.<code>Last-Modified</code> / <code>If-Modified-Since</code>:<br>第一次请求一个资源时，服务器返回 <code>Last-Modified</code>(例如：<code>Last-Modified: Mon, 30 Nov 2015 23:21:37 GMT</code>)，下一次请求是客户端带上 <code>If-Modified-Since</code> 的 <code>header</code>。</p><p>例如 <code>If-Modified-Since: Mon, 30 Nov 2015 23:21:37 GMT</code>，如果资源没改变则返回 <code>304</code> 状态码。</p><p><strong>缺点</strong>：服务器可能频繁修改文件（<code>ms</code>级），而 <code>Last-Modified</code> 只能精确到秒，可能返回错误的状态码(已经变动却返回相同的时间)；服务器修改了文件但是内容没变化，只是修改时间变了，这个时候其实是不用更新缓存的，故而 <code>ETag</code> 更好。</p><p>2.<code>ETag</code> / <code>If-None-Match</code>(优先级高):<br>用一个 <code>ETag</code> 标记服务器的文件(可以用 <code>hash</code> 之类的算法计算)，如果 <code>ETag</code> 没变则服务器返回 <code>304</code> 状态码。</p><p>例如：服务器返回：<code>ETag: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;</code>；客户端发送：<code>If-None-Match: W/&quot;d41d8cd98f00b204e9800998ecf8427e&quot;</code></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h3><p><img src="/assets/img/tcp_connect.png" alt="TCP connect"></p><ol><li>客户端请求建立 <code>TCP</code> 连接，标记 <code>SYN</code>(Synchronize Sequence Numbers，同步序列号) 为 <code>1</code>，并发送客户端的序列号 <code>x</code>，即 <code>SYN=1;seq=x</code>。发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li><li>服务器收到后，标记 <code>ACK</code>(Acknowledgement) 为 <code>1</code>，返回一个确认码 <code>ack</code>，值为客户端序列号加 <code>1</code>，并发送自己的同步序列号 <code>y</code> 给客户端，即 <code>SYN=1;seq=y;ACK=1;ack=x+1</code>。发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态，一段时间后没收到回复，自动尝试 5 次重新发送确认报文，每次时间间隔指数递增(1s,2s,4s,8s,16s)，第 5 次后等待 31s 后(总共 63s)才能断开连接。</li><li>客户端收到后需要告知服务器它收到了，同样发送确认码和序列号，即 <code>SYN=1;ACK=1;ack=y+1;seq=x+1</code>。发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li></ol><blockquote><p>注意：客户端发送每次 <code>TCP</code> 报文时 <code>seq</code> 都会递增 <code>1</code>，便于收到报文后确认报文发送的先后顺序。第三次握手不需要发送 <code>SYN=1</code> 信号，因为不是初始建立连接状态，如果标记为 <code>1</code> 那么服务器又会认为是建立一个新连接了。</p></blockquote><h3 id="四次握手关闭连接-以客户端发起关闭为例"><a href="#四次握手关闭连接-以客户端发起关闭为例" class="headerlink" title="四次握手关闭连接(以客户端发起关闭为例)"></a>四次握手关闭连接(以客户端发起关闭为例)</h3><p><img src="/assets/img/tcp_finish.png" alt="TCP finis"></p><ol><li>客户端请求关闭连接，标记 <code>FIN</code>(finish) 标记为 <code>1</code>，带上序列号 <code>u</code>，这个时候客户端还可以接收数据但是不再发送数据了。</li><li>服务器收到请求后标记 <code>ACK</code> 为 <code>1</code>，返回确认码 <code>u+1</code>，告诉客户端它收到了，服务器开始关闭连接（发送剩余数据等等操作）。</li><li>服务器等待关闭后(需要把没发完的发完)，向客户端发起关闭请求，标记 <code>FIN</code> 为 <code>1</code>，序列号为 <code>w</code>，这个时候服务器也不发送数据了。</li><li>客户端收到确认后，知道服务器关闭了，那么自己也不再接受数据了，标记 <code>ACK</code> 为 <code>1</code>，发送确认码 <code>w+1</code>，进入等待阶段，等待 <code>2MSL</code>(Maximum Segment Lifetime，最大报文生存周期)，保证服务器收到确认并已关闭了，客户端才可以放心关闭，如果继续收到服务器的数据，说明确认码未收到，需要再次向服务器发送，这就是等待 <code>2MSL</code> 的原因。</li></ol><blockquote><p>需要四次握手的原因，建立连接时服务器返回确认码时可以同时传输序列号 <code>SYN</code>，但是关闭连接时服务器可能还有剩余数据需要发送，所以先回复一个 <code>ACK</code> 告诉客户端它知道该关闭了只是需要做一些收尾，等到收尾工作做完（发送完剩余数据），再告诉客户端可以关闭了。</p></blockquote><h3 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h3><p>在三次握手过程中，服务器发送 <code>SYN-ACK</code> 之后，收到客户端的 <code>ACK</code> 之前的 <code>TCP</code> 连接称为半连接(<code>half-open connect</code>)。此时服务器处于 <code>SYN_RCVD</code> 状态。当收到 <code>ACK</code> 后，服务器才能转入 <code>ESTABLISHED</code> 状态.</p><p><code>SYN</code> 攻击指的是，攻击客户端在短时间内伪造大量不存在的 <code>IP</code> 地址，向服务器不断地发送 <code>SYN</code> 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 <code>SYN</code> 包将长时间占用未连接队列，正常的 <code>SYN</code> 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p><code>SYN</code> 攻击是一种典型的 <code>DoS/DDoS</code> 攻击。防御可以限制最大半连接数、网关过滤、缩短超时时间等等。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>先来了解一下前提：</p><ol><li><code>TCP</code> 协议的两端分别为发送者 <code>A</code> 和接收者 <code>B</code>，由于是全双工协议，因此 <code>A</code> 和 <code>B</code> 应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（<code>A</code> 发 <code>B</code> 收和 <code>B</code> 发 <code>A</code> 收），我们以 <code>A</code> 发送 <code>B</code> 接收的情况作为例子；</li><li>发送窗口是发送缓存中的一部分，是可以被 <code>TCP</code> 协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；</li><li>发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据。</li></ol><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><code>TCP</code> 建立的开始，<code>B</code> 会告诉 <code>A</code> 自己的接受窗口大小，比如 <code>20</code>。</p><p><code>A</code> 发送 <code>11</code> 个字节后，发送窗口位置不变，<code>B</code> 接收到了乱序的数据分组：</p><p><img src="/assets/img/tcp_slide1.png" alt="TCP Slide 1"></p><p>只有当 <code>A</code> 成功发送了数据，即发送的数据得到了 <code>B</code> 的确认之后，才会移动滑动窗口离开已发送的数据；同时 <code>B</code> 则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递：</p><p><img src="/assets/img/tcp_slide2.png" alt="TCP Slide 2"></p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>流量控制方面主要有两个要点需要掌握。一是 <code>TCP</code> 利用滑动窗口实现流量控制的机制；二是如何考虑流量控制中的传输效率。</p><p>1.流量控制</p><p>所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制。主要的方式就是返回的 <code>ACK</code> 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p><p>这里面涉及到一种情况，如果 <code>B</code> 已经告诉 <code>A</code> 自己的缓冲区已满，于是 <code>A</code> 停止发送数据；等待一段时间后，<code>B</code> 的缓冲区出现了富余，于是给 <code>A</code> 发送报文告诉 <code>A</code> 我的 <code>rwnd</code> 大小为 400，但是这个报文不幸丢失了，于是就出现 <code>A</code> 等待 <code>B</code> 的通知||<code>B</code> 等待 <code>A</code> 发送数据的死锁状态。为了处理这种问题，<code>TCP</code> 引入了持续计时器（<code>Persistence timer</code>），当 <code>A</code> 收到对方的零窗口通知时，就启用该计时器，时间到则发送一个 1 字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未 0，则重设持续计时器，继续等待。</p><p>2.传递效率</p><p>单个发送字节单个确认，窗口有一个空余就通知对方，这未免也太浪费性能了，所以确认一般是批量确认一部分连续的，而窗口要等到空余较多的时候才通知对方发送。</p><ul><li>对于单发字节确认问题：</li></ul><p>使用 <code>Nagle</code> 算法：</p><p>a.要发送一段数据时候，先发送第一个数据字节，后面的数据先缓存。<br>b.等到收到确认后了解接收方的可接收窗口大小，再根据这个大小组织数据发送出去。<br>c.等到发送的数据有一半收到确认回复或者达到报文最大长度时，发送一个报文段。</p><ul><li>对于窗口空余问题：</li></ul><p>让接收方等待一段时间，或者接收方获得足够的空间容纳一个报文段或者等到接受缓存有一半空闲的时候，再通知发送方发送数据。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法就是：</p><p>1.慢开始、拥塞控制：</p><p>通过图我们来一步步解释：</p><p><img src="/assets/img/tcp_slow_start.png" alt="TCP Slow Start"></p><ul><li>发送方维持一个“拥塞窗口”(<code>cwnd</code>,congestion window)的变量，与发送方的允许窗口大小(<code>rwnd</code>,receiver window)共同决定发送窗口大小，显然 <code>cwnd</code> 是不能超过 <code>rwnd</code> 的。</li><li>当开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个 1 字节的试探报文，收到确认后尝试发送 2 字节，收到确认再发 4 字节，等等，以此类推，以 2 的指数级增长。</li><li>最后回达到一个门限(<code>ssthresh</code>)，规则如下：<br><code>cwnd</code> &lt; <code>ssthresh</code>:继续 2 的指数增长。<br><code>cwnd</code> &gt;= <code>ssthresh</code>:拥塞避免方法，每次窗口大小只增加 1，而不是 2 的指数级增长。</li><li><p><strong>当出现拥塞时</strong>，比如丢包，也就是可能这个门限(<code>ssthresh</code>)可能设置过大了，那么把门限减少为原来的一般(<code>ssthresh/2</code>)，同时 <code>cwnd</code> 设为 1，重新开始指数级增长(慢开始)。</p><p>2.快重传、快恢复：</p></li></ul><p><img src="/assets/img/tcp_fast_start.png" alt="TCP Fast Restore"></p><ul><li>接收方建立这样的机制，如果一个包丢失，则对后续的包继续发送针对该包的重传请求。</li><li>一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包。</li><li>此时发送方开始执行“快恢复”算法：<br>门限设为一半，<code>cwnd</code> 直接从减少后的门限开始，即 <code>ssthresh/2</code>，之后每次收到确认递增 1 知道达到接收方的最大接收窗口大小(<code>rwnd</code>)。</li></ul><blockquote><p>这种方式能比较快的恢复传输，而不必要重新等待 <code>TCP</code> 的慢开始，现在 <code>TCP</code> 都是基于快重传的机制了，在 <code>TCP Tahoe</code> 版本是使用慢开始的，从 <code>TCP Reno</code> 版本开始使用快重传。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;强缓存与协商缓存&quot;&gt;&lt;a href=&quot;#强缓存与协商缓存&quot; class=&quot;headerlink&quot; title=&quot;强缓存与协商缓存&quot;&gt;&lt;/a&gt;强缓存与协商缓存&lt;/h2&gt;&lt;h3 id=&quot;强缓存&quot;&gt;&lt;a href=&quot;#强缓存&quot; class=&quot;headerlink&quot; title=&quot;强缓存&quot;&gt;&lt;/a&gt;强缓存&lt;/h3&gt;&lt;p&gt;1.&lt;code&gt;Expires&lt;/code&gt;：&lt;br&gt;服务器返回的一个时间，在这个时间之前都使用缓存，不发送 &lt;code&gt;http&lt;/code&gt; 请求。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;Expires: Thu, 10 Dec 2015 23:21:37 GMT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：服务器的时间和客户端不同会出现问题，老版本 &lt;code&gt;http 1.0&lt;/code&gt; 中才使用，现在一般使用 &lt;code&gt;Cache-Contorl&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;Cache-Control&lt;/code&gt;(优先级高)：&lt;br&gt;声明一个相对的秒数，表示从现在起一段时间内缓存都有效，也不会发送 &lt;code&gt;http&lt;/code&gt; 请求。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;Cache-Control: max-age=3600&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://1016990109.github.io/tags/js/"/>
    
      <category term="http" scheme="http://1016990109.github.io/tags/http/"/>
    
      <category term="tcp" scheme="http://1016990109.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>前端——JS数组</title>
    <link href="http://1016990109.github.io/2018/07/19/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94JS%E6%95%B0%E7%BB%84/"/>
    <id>http://1016990109.github.io/2018/07/19/前端——JS数组/</id>
    <published>2018-07-19T07:18:41.000Z</published>
    <updated>2018-07-19T11:58:14.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol><li><code>push(val1,val2,...)</code>、<code>pop</code> 操作，增加和删除，后进先出。</li><li><code>unshift(val1,val2,...)</code>、<code>shift()</code> 对应在开头添加元素和删除元素。</li><li><code>splice(start,deleteCount,val1,val2,...)</code> 从开始位置删除一定数量的元素，并从这个位置插入新的元素。</li><li><code>reverse()</code> 反向。</li><li><code>sort([orderfunction])</code> 排序。</li><li><code>slice([start] [,end])</code> 返回子数组，拷贝后的，复制一个数组简单地 <code>slice()</code>。</li><li><code>join(seperator)</code> 返回以 <code>seperator</code> 作为间隔的字符串，默认为 <code>,</code>。</li><li><code>concat([arr1][,arr2]...)</code> 连接数组并返回新的数组，<code>concat()</code> 复制数组。</li><li>其他：<code>indexOf(val)</code>,<code>includes(val)</code>,<code>toString</code>(同 <code>join()</code> 或 <code>join(&quot;,&quot;)</code>),<code>forEach()</code>,<code>every</code>,<code>findIndex</code>,<code>map</code>,<code>reduce</code>,<code>keys</code>,<code>values</code>。</li></ol><a id="more"></a><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><p>1.字符串反向：例：<code>123abc</code> =&gt; <code>cba321</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'123abc'</span></span><br><span class="line">  .split(<span class="string">''</span>)</span><br><span class="line">  .reverse()</span><br><span class="line">  .join(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>2.拍平数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>], <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      arr.splice(i, <span class="number">1</span>, ...flatten(arr[i]))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line">flatten(arr)</span><br></pre></td></tr></table></figure><p>3.打印数组全排列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allRange</span> (<span class="params">arr, path, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) &#123;</span><br><span class="line">        res.push(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">v, idx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> t = arr.slice()</span><br><span class="line">        <span class="keyword">const</span> p = path.slice()</span><br><span class="line">        t.splice(idx, <span class="number">1</span>)</span><br><span class="line">        p.push(v)</span><br><span class="line">        allRange(t, p, res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> b = []</span><br><span class="line">allRange(a, [], b)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;push(val1,val2,...)&lt;/code&gt;、&lt;code&gt;pop&lt;/code&gt; 操作，增加和删除，后进先出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unshift(val1,val2,...)&lt;/code&gt;、&lt;code&gt;shift()&lt;/code&gt; 对应在开头添加元素和删除元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;splice(start,deleteCount,val1,val2,...)&lt;/code&gt; 从开始位置删除一定数量的元素，并从这个位置插入新的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse()&lt;/code&gt; 反向。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort([orderfunction])&lt;/code&gt; 排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice([start] [,end])&lt;/code&gt; 返回子数组，拷贝后的，复制一个数组简单地 &lt;code&gt;slice()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join(seperator)&lt;/code&gt; 返回以 &lt;code&gt;seperator&lt;/code&gt; 作为间隔的字符串，默认为 &lt;code&gt;,&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;concat([arr1][,arr2]...)&lt;/code&gt; 连接数组并返回新的数组，&lt;code&gt;concat()&lt;/code&gt; 复制数组。&lt;/li&gt;
&lt;li&gt;其他：&lt;code&gt;indexOf(val)&lt;/code&gt;,&lt;code&gt;includes(val)&lt;/code&gt;,&lt;code&gt;toString&lt;/code&gt;(同 &lt;code&gt;join()&lt;/code&gt; 或 &lt;code&gt;join(&amp;quot;,&amp;quot;)&lt;/code&gt;),&lt;code&gt;forEach()&lt;/code&gt;,&lt;code&gt;every&lt;/code&gt;,&lt;code&gt;findIndex&lt;/code&gt;,&lt;code&gt;map&lt;/code&gt;,&lt;code&gt;reduce&lt;/code&gt;,&lt;code&gt;keys&lt;/code&gt;,&lt;code&gt;values&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://1016990109.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Linux 命令 —— 学习 Shell</title>
    <link href="http://1016990109.github.io/2018/07/12/Linux-%E5%91%BD%E4%BB%A4-%E5%AD%A6%E4%B9%A0Shell/"/>
    <id>http://1016990109.github.io/2018/07/12/Linux-命令-学习Shell/</id>
    <published>2018-07-12T14:38:04.000Z</published>
    <updated>2018-07-19T07:18:06.294Z</updated>
    
    <content type="html"><![CDATA[<p>系统学习 <code>Linux</code> 命令可以参考这本书：<a href="http://billie66.github.io/TLCL/book/index.html" target="_blank" rel="noopener">《The Linux Command Line》</a>。</p><h2 id="学习-Shell"><a href="#学习-Shell" class="headerlink" title="学习 Shell"></a>学习 Shell</h2><ul><li>如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。</li><li>如果是仿终端鼠标选中或者双击选中默认拷贝到缓冲区，按下鼠标中键可以粘贴。</li><li><code>ls</code> 命令选项：<code>-F</code> 如果是目录后面会加 <code>/</code>；<code>-h</code> 大小已可读的形式显示；<code>-S</code> 大小排序，<code>-t</code> 修改时间排序。</li><li><code>file</code> 命令打印文件内容简单描述，<code>file log.log</code>。</li><li><code>Linux</code> 系统中的目录：</li></ul><a id="more"></a><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>/</td><td>根目录。</td></tr><tr><td>/bin</td><td>包含系统启动和运行所必须的二进制程序。</td></tr><tr><td>/boot</td><td>包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。</td></tr><tr><td>/dev</td><td>这是一个包含设备结点的特殊目录。在这个目录里，内核维护着所有设备的列表。</td></tr><tr><td>/etc</td><td>这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。<code>crontab</code> 定时任务，<code>fstab</code> 存储设备列表和相应挂载点，<code>password</code> 用户账户列表。</td></tr><tr><td>/home</td><td>每个用户一个目录。</td></tr><tr><td>/lib</td><td>核心系统程序用的共享文件</td></tr><tr><td>/lost+found</td><td>每个使用 Linux 文件系统的格式化分区或设备，例如 ext3 文件系统， 都会有这个目录。</td></tr><tr><td>/media 或 /mnt(老的 Linux 版本)</td><td>包含可移动介质的挂载点。</td></tr><tr><td>/<strong>proc</strong></td><td>Linux 内核维护的虚拟文件系统，内核窥视孔。</td></tr><tr><td>/sbin</td><td>系统二进制文件，通常为超级用户保留。</td></tr><tr><td>/tmp</td><td>临时目录，<strong>重启会清空</strong>。</td></tr><tr><td>/usr/bin</td><td>系统安装的可执行程序。</td></tr><tr><td>/usr/lib</td><td>包含由/usr/bin 目录中的程序所用的共享库。</td></tr><tr><td>/usr/sbin</td><td>包含许多系统管理程序。</td></tr><tr><td>/usr/share</td><td>由/usr/bin 目录中的程序使用的共享数据。</td></tr><tr><td>/var</td><td>存放动态文件，各种数据库，假脱机文件， 用户邮件等等。</td></tr><tr><td>/var/log</td><td>这个/var/log 目录包含日志文件、各种系统活动的记录。其中最重要的一个文件是/var/log/messages。超级用户才能查看这些日志文件。</td></tr></tbody></table><ul><li>关于命令的命令<ul><li>type:解释一个命令</li><li>which:显示会执行哪个应用程序(查看命令在哪)</li><li>man:显示命令手册</li><li>apropos:在一些特定的包含系统命令的简短描述的数据库文件里查找关键字，然后把结果送到标准输出(和 <code>man -k</code> 相同)</li><li>info:显示命令 info(类似于网页，可以跳转，方便阅读命令文档)</li><li>whatis:显示一个命令简洁描述</li><li>alias:创建命令(给详细的命令取别名)，取消使用 <code>unalias</code></li></ul></li><li>重定向<ul><li>cat:连接文件</li><li>sort:排序</li><li>uniq:打印去除重复行</li><li>grep:匹配</li><li>wc:打印文件中换行符，字，和字节个数</li><li>head/tail:打印头部或尾部</li><li>tee:从 <code>Stdin</code> 读取数据，并同时输出到 <code>Stdout</code> 和文件，<code>ls | tee out.txt</code>。</li><li><code>&gt;</code> 重定向覆盖；<code>&gt;&gt;</code> 不覆盖。</li><li><code>&gt;ls-output.txt 2&gt;&amp;1</code> 先重定向到 <code>ls-output.txt</code> 再将标准错误(<code>2</code>)重定向到标准输出(<code>1</code>)，注意顺序反的是不行的；缩写：<code>&amp;&gt; ls-output.txt</code>。</li><li>重定向输出结果到一个叫做”/dev/null”的特殊文件可以忽略输出。</li><li><code>grep -v</code> 只打印不匹配的行；<code>grep -i</code> 忽略大小写。</li><li><code>tail -f</code> 实时浏览文件。</li></ul></li><li><code>echo</code><ul><li>支持正则表达式，如打印隐藏文件：<code>echo .[!.]?*</code>，直接 <code>echo .*</code> 会将代表当前工作目录和父目录的 <code>.</code> 和 <code>..</code> 也打印出来。</li><li>支持算数表达式，<code>echo $((expression))</code>，如 <code>echo $((2+2))</code>。注意：只支持整数。</li><li>花括号展开，<code>echo {Z..A}</code>。花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。可嵌套，如 <code>echo a{A{1,2},B{3,4}}b</code>。</li><li>通过 <code>$</code> 调用变量，<code>printenv</code> 打印有效的变量列表。</li><li>命令替换，允许把一个命令的输出作为展开模式来用，例如 <code>echo $(ls)</code> 把 <code>ls</code> 命令的结果作为一个临时变量打印出来。注意：除了圆括号加美元符，倒引号也可以支持命令替换，<code>echo `ls`</code>。</li><li>双引号，双引号可以阻止单词的分割，如 <code>ls -l two word.txt</code> 是意味着列出 <code>two</code> 和 <code>word.txt</code> 的内容，改为 <code>ls -l &quot;two word.txt&quot;</code> 就可以解决这个问题了。</li><li>单引号，禁止所有展开，不存在什么表达式，写啥就是啥。</li><li>转义字符，经常在双引号中使用转义字符，能转义的字符有 “$”, “!”, “&amp;”, “ “ 等等，如 <code>\$5.00</code>，单引号中反斜杠失去意义。<code>echo</code> 命令带上 <code>-e</code> 选项，能够解释转义序列，可以把转义序列放在 <code>$&#39; &#39;</code> 里面，例如 <code>echo -e &quot;Time&#39;s up\a&quot;</code> 或 <code>echo &quot;Time&#39;s up&quot; $&#39;\a&#39;</code> 都是可以的。</li></ul></li><li>命令行编辑<ul><li><code>clear</code> 清除屏幕，<code>history</code> 显示历史命令。</li><li><code>ctrl-a</code>(ahead) 移动到行首，<code>ctrl-e</code>(end) 移动到行尾，<code>ctrl-l</code> 相当于 <code>clear</code>，<code>alt-f</code>(forward) 前一个单词，<code>alt-b</code>(behind) 后一个单词。</li></ul></li><li><p>权限</p><ul><li><code>r</code> 可读，<code>w</code> 可写，<code>x</code> 可执行。</li><li><code>ls</code> 命令显示的十个字符，第一个代表文件类型，后面九个字符分 3 组，分别表示用户、用户组、其他的权限。</li><li>八进制数可以表示各种权限，因为权限有 3 类，组合方式就刚好只有 <code>2^3=8</code> 种，例如 <code>0</code> 代表 <code>000</code> – <code>---</code>，<code>7</code> 代表 <code>111</code> – <code>rwx</code>，所以我们经常看到有 <code>chmod 777</code> 这样类似的命令，就是通过 3 个数字用来修改文件或者文件夹的所有者、用户组、其他人的权限。</li><li><code>chmod</code> 命令符号表示法:</li></ul><p><code>u</code> 是所有者(<code>user</code>)，<code>g</code> 是用户组(<code>group</code>)，<code>o</code> 是其他人(<code>other</code>)；<code>+</code> 用来添加权限，<code>-</code> 用来删除权限，<code>=</code> 用来设置权限(除设置外的其他权限都删除)。例如 <code>chmod go=rw file</code> 意思是指定该文件的用户组和其他人拥有读权限和写权限，如果群组或者其他人之前拥有可执行权限则会被移除，<strong>而所有者的权限不会变动</strong>，<code>-R</code> 为递归赋予权限，只对文件夹有效。</p><ul><li><code>umask</code> 设置默认权限，使用掩码设置，类似网络 <code>ip</code> 之类的，<code>umask 0022</code> 展开就是 <code>000 000 010 010</code>，前三位先不管，后面依次对应所有者、用户组、其他人的权限，某一位如果为 <code>1</code> 就把该位代表的权限删除，<code>0022</code> 就意味着删除用户组和其他人的写权限，只能读，默认的权限是 <code>--- rw- rw- rw-</code>，是默认没有可执行权限的。</li><li>特殊权限，<code>setuid</code>(程序运行时从运行的用户切换到程序所有者用户)、<code>setgid</code>(类似于 <code>setuid</code> 把文件运行的所有组<code>id</code>换成文件所有组<code>id</code>))、<code>sticky</code>(阻止用户删除和重命名文件)，具体的可以查看 <a href="http://billie66.github.io/TLCL/book/chap10.html" target="_blank" rel="noopener">权限</a>。</li><li><code>chown [owner][:[group]] file</code> 更改文件的所有者或所有组。</li></ul></li><li><p>进程</p><ul><li>当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 <code>init</code> 的程序。<code>init</code>， 依次地，再运行一系列的称为 <code>init</code> 脚本的 <code>shell</code> 脚本（位于 <code>/etc</code>），它们可以启动所有的系统服务。</li><li><code>ps</code> 简单查看进程。<code>x</code>(注意不是 <code>-x</code>)选项显示进程在哪个终端控制的、状态(<code>STAT</code>， <code>R</code> 正在运行，<code>S</code> 正在睡眠，<code>D</code> 不可中断睡眠，<code>T</code> 已停止，<code>Z</code> 一个死进程，<code>&lt;</code> 一个高优先级级才能更，<code>N</code> 低优先级进程)，<strong>启用的命令</strong>(这个可能很有用)。<code>ps aux</code> 是经常用的一个显示更加详细信息的命令，</li><li><code>top</code> 程序以进程活动顺序显示连续更新的系统进程列表。以 <code>CPU</code> 使用率排序。</li><li>一个进程放到后台执行，只要在后面加上 <code>&amp;</code> 字符，如 <code>vi foo.txt &amp;</code>。</li><li>将进程放回前台执行，先用 <code>jobs</code> 找到对应的任务，比如 <code>[1] suspended(tty output) vi foo.txt</code>，任务就是 <code>1</code>，接着使用 <code>fg</code>(可以 <code>foreground</code> 记忆) 命令 <code>fg %1</code>。</li><li><code>Ctrl-Z</code> 停止一个前台任务，将任务移动到后台。同样地使用 <code>fg</code> 命令可以将后台进程移动到前台。</li><li><code>kill [-signal] PID</code>，发送信号给对应 <code>PID</code> 的进程，默认是终止信号(<code>TERM</code>)。<code>signal</code> 可以用数字也可以用字母，建议用字母，好记，<code>HUP</code> 挂起，<code>INT</code> 中断(类似 <code>Ctrl-C</code>)，<code>KILL</code> 杀死(不通知进程，直接在内核杀死)，<code>TERM</code> 终止，<code>CONT</code> 发送停止信号后可以使用这个来恢复，<code>STOP</code> 停止进程。<strong><code>kill -l</code> 列出完整信号列表</strong>。</li><li><code>pstree</code> 输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系统学习 &lt;code&gt;Linux&lt;/code&gt; 命令可以参考这本书：&lt;a href=&quot;http://billie66.github.io/TLCL/book/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《The Linux Command Line》&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;学习-Shell&quot;&gt;&lt;a href=&quot;#学习-Shell&quot; class=&quot;headerlink&quot; title=&quot;学习 Shell&quot;&gt;&lt;/a&gt;学习 Shell&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。&lt;/li&gt;
&lt;li&gt;如果是仿终端鼠标选中或者双击选中默认拷贝到缓冲区，按下鼠标中键可以粘贴。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls&lt;/code&gt; 命令选项：&lt;code&gt;-F&lt;/code&gt; 如果是目录后面会加 &lt;code&gt;/&lt;/code&gt;；&lt;code&gt;-h&lt;/code&gt; 大小已可读的形式显示；&lt;code&gt;-S&lt;/code&gt; 大小排序，&lt;code&gt;-t&lt;/code&gt; 修改时间排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file&lt;/code&gt; 命令打印文件内容简单描述，&lt;code&gt;file log.log&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Linux&lt;/code&gt; 系统中的目录：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://1016990109.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="http://1016990109.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第六章</title>
    <link href="http://1016990109.github.io/2018/07/04/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/07/04/Node-js-设计模式读书笔记-第六章/</id>
    <published>2018-07-04T02:37:30.000Z</published>
    <updated>2018-07-24T11:51:00.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Design-Patterns-设计模式"><a href="#Design-Patterns-设计模式" class="headerlink" title="Design Patterns(设计模式)"></a>Design Patterns(设计模式)</h1><h2 id="Factory-工厂"><a href="#Factory-工厂" class="headerlink" title="Factory(工厂)"></a>Factory(工厂)</h2><h3 id="A-generic-interface-for-creating-objects-创建对象的通用接口"><a href="#A-generic-interface-for-creating-objects-创建对象的通用接口" class="headerlink" title="A generic interface for creating objects(创建对象的通用接口)"></a>A generic interface for creating objects(创建对象的通用接口)</h3><p>调用一个工厂，而不是直接使用 <code>new</code> 运算符或 <code>Object.create()</code> 从一个原型创建一个新的对象，在很多方面是非常方便和灵活的。</p><a id="more"></a><p>首先最重要的是，工厂允许我们将对象创建与实现分离开来；从本质上讲，一个工厂包装了一个新实例的创建，给了我们更多的灵活性和怎么创建的控制权。</p><p>在工厂内部，我们可以使用闭包，使用原型和 <code>new</code> 运算符，使用 <code>Object.create()</code> 创建新实例，甚至根据特定条件返回不同的实例。对于对象的使用者而言，是完全不知道这个实例是怎么进行创建的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name.match(<span class="regexp">/\.jpeg$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpegImage(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.match(<span class="regexp">/\.gif$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GifImage(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.match(<span class="regexp">/\.png$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PngImage(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">'Unsupported format'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> image = createImage(<span class="string">'photo.jpeg'</span>)</span><br></pre></td></tr></table></figure><h3 id="A-mechanism-to-enforce-encapsulation-强制封装的机制"><a href="#A-mechanism-to-enforce-encapsulation-强制封装的机制" class="headerlink" title="A mechanism to enforce encapsulation(强制封装的机制)"></a>A mechanism to enforce encapsulation(强制封装的机制)</h3><blockquote><p>封装需要做的是隐藏对象信息，外部代码只能通过暴露的公开接口修改对象而不能直接作用于对象，这又要叫做信息隐藏，和继承、多态、抽象一起都是面向对象的基本原则。</p></blockquote><p>在 <code>JavaScript</code> 中，没有权限修饰符（不能声明私有变量），所以强制封装的唯一方法是通过函数作用域和闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> privateProperties = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> person = &#123;</span><br><span class="line">    setName: <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!name) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'A person must have a name'</span>)</span><br><span class="line">      privateProperties.name = name</span><br><span class="line">    &#125;,</span><br><span class="line">    getName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> privateProperties.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  person.setName(name)</span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中创建了两个对象：<code>person</code> 是通过工厂返回的公开接口；<code>privateProperties</code> 是只能通过 <code>person</code> 公开接口更改的私有属性。</p><blockquote><p>工厂只是我们创建私有成员变量的技术之一，事实上，也有很多其它的方法定义私有成员变量。在构造函数中定义私有变量；使用约定，用下划线 <code>_</code> 或美元符号 <code>$</code>（实际上并不能阻止从外部访问内部成员）的属性名称前缀；使用<code>ES2015 WeakMaps</code>。更加详细的可以看看 <code>Mozilla</code> 的 <a href="https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Add-on_SDK/Guides/Contributor_s_Guide/Private_Properties" target="_blank" rel="noopener">Private Properties</a> 的文章。</p></blockquote><h3 id="Build-a-simple-code-profiler-构建一个简单的-profiler"><a href="#Build-a-simple-code-profiler-构建一个简单的-profiler" class="headerlink" title="Build a simple code profiler(构建一个简单的 profiler)"></a>Build a simple code profiler(构建一个简单的 profiler)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(label) &#123;</span><br><span class="line">    <span class="keyword">this</span>.label = label</span><br><span class="line">    <span class="keyword">this</span>.lastTime = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastTime = process.hrtime()</span><br><span class="line">  &#125;</span><br><span class="line">  end() &#123;</span><br><span class="line">    <span class="keyword">const</span> diff = process.hrtime(<span class="keyword">this</span>.lastTime)</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`Timer "<span class="subst">$&#123;<span class="keyword">this</span>.label&#125;</span>" took <span class="subst">$&#123;diff[<span class="number">0</span>]&#125;</span> seconds and <span class="subst">$&#123;diff[<span class="number">1</span>]&#125;</span></span></span><br><span class="line"><span class="string">           nanoseconds.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用这样一个 <code>profiler</code> 来记录每个程序的执行时间，在生产环境中就会产生大量的输出，我们想做的可能是将这些信息重定向到另一个源，或者在生产环境下完全禁用，如果直接通过 <code>new</code> 来创建 <code>Profiler</code> 对象的话需要做一些额外的逻辑以便在不同的逻辑间来切换。而使用工厂模式就可以很好地解决这个问题，根据传入参数的不同创建不同逻辑的 <code>Profiler</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">label</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Profiler(label) <span class="comment">// [1]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// [2]</span></span><br><span class="line">      start: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">      end: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Must set NODE_ENV'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Composable-factory-functions-可组合的工厂函数"><a href="#Composable-factory-functions-可组合的工厂函数" class="headerlink" title="Composable factory functions(可组合的工厂函数)"></a>Composable factory functions(可组合的工厂函数)</h3><p>可组合的工厂函数，它代表了一种特定类型的工厂函数，可以“组合”在一起构建新的更强大的工厂函数。</p><p>可组合工厂函数可以使用实现了 <a href="https://github.com/stampit-org/stamp-specification" target="_blank" rel="noopener">Stamp 规范</a> 的 <code>npm</code> 库 <a href="https://www.npmjs.com/package/stampit" target="_blank" rel="noopener">stampit</a>。详细的例子可直接查看官方文档 <a href="https://stampit.js.org/essentials/overview" target="_blank" rel="noopener">stampit</a>。</p><blockquote><p><code>Stamp</code> 是一个可组合的工厂函数(<code>composable factory function</code>)，根据描述符返回对象实例。它有一个 <code>compose</code> 的方法，该方法使用当前的 <code>Stamp</code> 作为一个基础，将其他的 <code>Composable</code> 组合进来，返回一个新的 <code>Stamp</code>。可以通过 <code>staticProperties</code> 属性来重写 <code>compose</code> 方法，方法在<a href="https://github.com/stampit-org/stamp-specification#overriding-compose-method" target="_blank" rel="noopener">这里</a>。</p></blockquote><h3 id="In-the-wild-实际应用"><a href="#In-the-wild-实际应用" class="headerlink" title="In the wild(实际应用)"></a>In the wild(实际应用)</h3><p>很多的 <code>Node.js</code> 的库都有使用工厂模式，利用工厂返回实例，这里就不一一举例说明了，比较有意思的可以看看 <code>Node.js</code> 的核心模块 <code>HTTP</code> (<code>http.createServer()</code>创建实例)，使用 <code>Stamp</code> 规范的包，如 <a href="https://www.npmjs.com/package/react-stampit" target="_blank" rel="noopener">react-stampit</a> 可以轻松地组合组件的功能。</p><h2 id="Revealing-constructor-揭露构造器"><a href="#Revealing-constructor-揭露构造器" class="headerlink" title="Revealing constructor(揭露构造器)"></a>Revealing constructor(揭露构造器)</h2><p>其实简单说就是将要暴露的接口返回（<code>return</code>）出去。</p><p>我们分析一下 <code>Promise</code> 的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Promise</code> 接收一个函数作为构造器的参数，这个函数被称为执行函数，在 <code>Promise</code> 内部被调用，它提供了一种暴露可以被外界调用的 <code>resolve</code> 和 <code>reject</code> 方法的机制去修改 <code>Promise</code> 内部的状态。这样的好处是，只有构造器才有对 <code>resolve</code> 和 <code>reject</code> 的访问权限，一旦 <code>Promise</code> 对象被创建，<code>resolve</code> 和 <code>reject</code> 就能安全地传递，在其他地方是调用不了的。</p><h3 id="A-read-only-event-emitter-一个只读的事件触发器"><a href="#A-read-only-event-emitter-一个只读的事件触发器" class="headerlink" title="A read-only event emitter(一个只读的事件触发器)"></a>A read-only event emitter(一个只读的事件触发器)</h3><p>使用这个模式我们创建一个只读的 <code>event emitter</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Roee</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">const</span> emit = <span class="keyword">this</span>.emit.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.emit = <span class="literal">undefined</span></span><br><span class="line">    executor(emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，现在之后通过 <code>executor</code> 传入的参数才能获取到 <code>emit</code> 的访问权限了，关键就在于 <code>this.emit = undefined</code> 这一语句使得从外面不能访问 <code>emit</code> 方法了，只能通过传入构造器的函数中的参数访问，使用方式像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Roee = <span class="built_in">require</span>(<span class="string">'./roee'</span>)</span><br><span class="line"><span class="keyword">const</span> ticker = <span class="keyword">new</span> Roee(<span class="function"><span class="params">emit</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tickCount = <span class="number">0</span></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> emit(<span class="string">'tick'</span>, tickCount++), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = ticker</span><br></pre></td></tr></table></figure><blockquote><p>注意：上面这种方式并不是完美的，有的方法可以绕过：<code>require(&#39;events&#39;).prototype.emit.call(ticker, &#39;someEvent&#39;, {});</code>。</p></blockquote><h3 id="In-the-wild"><a href="#In-the-wild" class="headerlink" title="In the wild"></a>In the wild</h3><p>除了 <code>Promise</code> 外其实很难再找到这样的库了，现在 <code>Streams</code> 议案中有一个新的规范，可以尝试使用揭示构造函数模式替代现今的模板模式，以便能够描述各种 <code>Streams</code> 对象的行为：可以看 <a href="https://streams.spec.whatwg.org" target="_blank" rel="noopener">https://streams.spec.whatwg.org</a>。</p><h2 id="Proxy-代理模式"><a href="#Proxy-代理模式" class="headerlink" title="Proxy(代理模式)"></a>Proxy(代理模式)</h2><p><code>Proxy</code> 是用来控制访问一个被称为主题（<code>subject</code>）的对象的，这种模式也可以叫做 <code>代替模式</code>，<code>Proxy</code> 拦截对 <code>subject</code> 的操作，并对行为进行增强和补充。</p><p><img src="/assets/img/proxy.png" alt="Proxy"></p><p>上图说明 <code>Proxy</code> 和 <code>Subject</code> 是有相同的接口的，对客户端都是透明的，<code>Proxy</code> 将操作转发给 <code>Subject</code> 只不过通过额外的预处理增强其行为。</p><p>代理的应用场景：</p><ul><li>数据验证：在 <code>Proxy</code> 向 <code>Subject</code> 转发数据前验证其数据输入的合法性。</li><li>安全性：代理验证客户端是否有权限，仅仅当有权限时才会向 <code>Subject</code> 发送相关请求。</li><li>缓存：代理对象保存内部缓存，仅仅当缓存未命中时才向 <code>Subject</code> 发送相关请求。</li><li>懒加载：如果 <code>Subject</code> 的创建需要消耗大量资源，代理可以推迟创建 <code>Subject</code> 的时机。</li><li>日志：代理拦截方法和对应的参数调用，并在他们执行前后实现日志打印。</li><li>远程对象：代理可以接收远程对象，并使得其呈现为本地对象。</li></ul><h3 id="Techniques-for-implementing-proxies-实现代理的方法"><a href="#Techniques-for-implementing-proxies-实现代理的方法" class="headerlink" title="Techniques for implementing proxies(实现代理的方法)"></a>Techniques for implementing proxies(实现代理的方法)</h3><h4 id="Object-Composition-对象组合"><a href="#Object-Composition-对象组合" class="headerlink" title="Object Composition(对象组合)"></a>Object Composition(对象组合)</h4><p>创建具有与主体对象相同接口的新对象，并且对该主体的引用以实例变量或闭包变量的形式存储在代理内部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(subject)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Proxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subject = subject</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Proxy</span>.prototype = <span class="built_in">Object</span>.create(proto)</span><br><span class="line">  <span class="comment">//proxied method</span></span><br><span class="line">  <span class="built_in">Proxy</span>.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subject.hello() + <span class="string">' world!'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//delegated method</span></span><br><span class="line">  <span class="built_in">Proxy</span>.prototype.goodbye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subject.goodbye.apply(<span class="keyword">this</span>.subject, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(subject)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = createProxy</span><br></pre></td></tr></table></figure><p>可以发现这个 <code>Proxy</code> 对象提供了和 <code>Subject</code> 一样的接口，加强了 <code>hello()</code> 方法，直接委托了 <code>goodbye()</code> 方法。</p><p>前面的代码也显示了一个特定情况：主体对象有一个原型，我们希望维护正确的原型链，以便执行 <code>proxy instanceof Subject</code> 将返回 <code>true</code>，使用继承实现了这一点。</p><p>更多时候由于 <code>js</code> 的动态类型，我们可以简单化，使用对象字面量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">//proxied method</span></span><br><span class="line">    hello: <span class="function"><span class="params">()</span> =&gt;</span> subject.hello() + <span class="string">' world!'</span>,</span><br><span class="line">    <span class="comment">//delegated method</span></span><br><span class="line">    goodbye: <span class="function"><span class="params">()</span> =&gt;</span> subject.goodbye.apply(subject, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-augmentation-对象增强"><a href="#Object-augmentation-对象增强" class="headerlink" title="Object augmentation(对象增强)"></a>Object augmentation(对象增强)</h4><p>对象增强(或称为猴子补丁)是最为实用的实现代理的方式了，直接更改代理对象的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> helloOrig = subject.hello</span><br><span class="line">  subject.hello = <span class="function"><span class="params">()</span> =&gt;</span> helloOrig.call(<span class="keyword">this</span>) + <span class="string">' world!'</span></span><br><span class="line">  <span class="keyword">return</span> subject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-comparision-of-the-different-techniques-不同方法的比较"><a href="#A-comparision-of-the-different-techniques-不同方法的比较" class="headerlink" title="A comparision of the different techniques(不同方法的比较)"></a>A comparision of the different techniques(不同方法的比较)</h3><p>对象组合方式是比较安全的，因为不修改原对象，缺点是需要委托所有的方法，尽管可能只需要代理某一个或某几个方法，甚至有时候还需要委托属性。</p><p>对象增强就与对象组合方式相反，通常来讲，如果更改对象影响不是很大的话首选对象增强方式。</p><h3 id="Creating-a-Writable-stream"><a href="#Creating-a-Writable-stream" class="headerlink" title="Creating a Writable stream"></a>Creating a Writable stream</h3><p>实现一个代理的 <code>Writable Stream</code>，增加写入日志的功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLoggingWritable</span>(<span class="params">writableOrig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(writableOrig)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">LoggingWritable</span>(<span class="params">writableOrig</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writableOrig = writableOrig</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LoggingWritable.prototype = <span class="built_in">Object</span>.create(proto)</span><br><span class="line"></span><br><span class="line">  LoggingWritable.prototype.write = <span class="function"><span class="keyword">function</span>(<span class="params">chunk, encoding, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback &amp;&amp; <span class="keyword">typeof</span> encoding === <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = encoding</span><br><span class="line">      encoding = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Writing '</span>, chunk)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writableOrig.write(chunk, encoding, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Finished writing '</span>, chunk)</span><br><span class="line">      callback &amp;&amp; callback()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LoggingWritable.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writableOrig.on.apply(<span class="keyword">this</span>.writableOrig, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LoggingWritable.prototype.end = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writableOrig.end.apply(<span class="keyword">this</span>.writableOrig, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoggingWritable(writableOrig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的实现方式是用对象组合的方式的，这里为了简单只委托重要的几个方法，我们覆盖了 <code>write()</code> 方法，每次调用 <code>write()</code> 时都会将消息记录到标准输出，并且每次异步操作完成时都会记录消息。</p><h3 id="Proxy-in-the-ecosystem-function-hooks-and-AOP-生态中的代理——函数钩子和-AOP"><a href="#Proxy-in-the-ecosystem-function-hooks-and-AOP-生态中的代理——函数钩子和-AOP" class="headerlink" title="Proxy in the ecosystem - function hooks and AOP(生态中的代理——函数钩子和 AOP)"></a>Proxy in the ecosystem - function hooks and AOP(生态中的代理——函数钩子和 AOP)</h3><p><code>npm</code> 中有几个库帮助开发人员使用函数钩子可以看下：<a href="https://npmjs.org/package/hooks" target="_blank" rel="noopener">hooks</a>、<a href="https://npmjs.org/package/hooker" target="_blank" rel="noopener">hooker</a>、<a href="https://npmjs.org/package/meld" target="_blank" rel="noopener">meld</a>。</p><h3 id="ES2015-Proxy"><a href="#ES2015-Proxy" class="headerlink" title="ES2015 Proxy"></a>ES2015 Proxy</h3><p><code>ES2015</code> 规范引入了一个名为 <code>Proxy</code> 的全局对象，它可以从开始在 <code>Node.js v6.0</code> 中使用。</p><p><code>Proxy API</code> 包含了一个接受 <code>target</code> 和 <code>handler</code> 的构造函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p><code>handler</code> 对象包含一系列具有预定义名称的可选方法，这些方法称为陷阱方法（例如，<code>apply</code>，<code>get</code>，<code>set</code> 和 <code>has</code>），这些方法在代理实例上执行相应的操作时会自动调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scientist = &#123;</span><br><span class="line">  name: <span class="string">'nikola'</span>,</span><br><span class="line">  surname: <span class="string">'tesla'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> uppercaseScientist = <span class="keyword">new</span> <span class="built_in">Proxy</span>(scientist, &#123;</span><br><span class="line">  get: <span class="function">(<span class="params">target, property</span>) =&gt;</span> target[property].toUpperCase()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(uppercaseScientist.name, uppercaseScientist.surname)</span><br><span class="line"><span class="comment">// prints NIKOLA TESLA</span></span><br></pre></td></tr></table></figure><p>这个例子使用 <code>Proxy API</code> 来拦截所有对 <code>scientist</code> 属性的访问，并将属性的原始值转换为大写字符串。</p><p>再看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evenNumbers = <span class="keyword">new</span> <span class="built_in">Proxy</span>([], &#123;</span><br><span class="line">  get: <span class="function">(<span class="params">target, index</span>) =&gt;</span> index * <span class="number">2</span>,</span><br><span class="line">  has: <span class="function">(<span class="params">target, number</span>) =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">in</span> evenNumbers) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> <span class="keyword">in</span> evenNumbers) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(evenNumbers[<span class="number">7</span>]) <span class="comment">// 14</span></span><br></pre></td></tr></table></figure><p>这个例子创建了一个虚拟数组，因为是不真正存储数据的，只是定义了 <code>has</code> 和 <code>get</code> 就完成了虚拟数组（包含了所有的偶数）。</p><p>更多详细的有关 <code>Proxy</code> 的用法可以查看<a href="https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">官方文档</a> 或者 <code>Google</code> 的 <a href="https://developers.google.com/web/updates/2016/02/es2015-proxies" target="_blank" rel="noopener">Introducing ES2015 Proxies</a>。</p><h3 id="In-the-wild-1"><a href="#In-the-wild-1" class="headerlink" title="In the wild"></a>In the wild</h3><p><code>Mongoose</code> 是 <code>MongoDB</code> 的一个流行的对象文档映射（<code>ODM</code>）库。 在内部，它使用 <code>hooks</code> 为 <code>init</code>，<code>validate</code>，<code>save</code> 和 <code>remove</code> 函数提供预处理和后处理的钩子函数。有关官方文档，请参阅 <a href="http://mongoosejs.com/docs/middleware.html" target="_blank" rel="noopener">Mongoose</a> 的官方文档。</p><h2 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="Decorator(装饰器)"></a>Decorator(装饰器)</h2><p>装饰器模式：动态增强已有的一个对象实例，而不是对整个类增强；与 <code>Proxy</code> 模式类似，但是不增强或者修改现有的接口，而是新增接口。</p><p><img src="/assets/decorator.png" alt="Decorator"></p><p>从图中可以推断出，<code>Decorator</code> 模式可以和 <code>Proxy</code> 模式组合，装饰器模式负责新增接口，代理模式负责增强或修改现有的接口(拦截对主体的访问，并做增强)。</p><h3 id="Techniques-for-implementing-Decorators-实现装饰器的方法"><a href="#Techniques-for-implementing-Decorators-实现装饰器的方法" class="headerlink" title="Techniques for implementing Decorators(实现装饰器的方法)"></a>Techniques for implementing Decorators(实现装饰器的方法)</h3><h4 id="Composition-组合"><a href="#Composition-组合" class="headerlink" title="Composition(组合)"></a>Composition(组合)</h4><p>一般使用一个新的对象包含被装饰的组件，该对象继承组件，并新增需要的方法，同时委托已有的方法给源组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(component)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Decorator</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.component = component</span><br><span class="line">  &#125;</span><br><span class="line">  Decorator.prototype = <span class="built_in">Object</span>.create(proto)</span><br><span class="line">  <span class="comment">// new method</span></span><br><span class="line">  Decorator.prototype.greetings = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hi!'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// delegated method</span></span><br><span class="line">  Decorator.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.component.hello.apply(<span class="keyword">this</span>.component, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Decorator(component)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-augmentation-对象增强-1"><a href="#Object-augmentation-对象增强-1" class="headerlink" title="Object augmentation(对象增强)"></a>Object augmentation(对象增强)</h4><p>对象装饰器也可以直接在源对象上添加新的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// new method</span></span><br><span class="line">  component.greetings = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> component</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Decorating-a-LevelUP-database-装饰一个-LevelUP-数据库"><a href="#Decorating-a-LevelUP-database-装饰一个-LevelUP-数据库" class="headerlink" title="Decorating a LevelUP database(装饰一个 LevelUP 数据库)"></a>Decorating a LevelUP database(装饰一个 LevelUP 数据库)</h3><h4 id="Introducing-LevelUP-and-LevelDB-介绍-LevelUP-和-LevelDB"><a href="#Introducing-LevelUP-and-LevelDB-介绍-LevelUP-和-LevelDB" class="headerlink" title="Introducing LevelUP and LevelDB(介绍 LevelUP 和 LevelDB)"></a>Introducing LevelUP and LevelDB(介绍 LevelUP 和 LevelDB)</h4><p><a href="https://www.npmjs.com/package/levelup" target="_blank" rel="noopener">LevelUP</a> 是 <code>Google</code> 的 <code>LevelDB</code> 上的一个 <code>Node.js</code> 包装器，它是最初为了在 <code>Chrome</code> 浏览器中实现 <code>IndexedDB</code> 而创建的 <code>key/value</code> 存储库。详细的 <code>LevelUP</code> 生态可查看 <a href="https://github.com/rvagg/node-levelup/wiki/Modules" target="_blank" rel="noopener">https://github.com/rvagg/node-levelup/wiki/Modules</a>。</p><h4 id="Implementing-a-LevelUP-plugin"><a href="#Implementing-a-LevelUP-plugin" class="headerlink" title="Implementing a LevelUP plugin"></a>Implementing a LevelUP plugin</h4><p>我们想要构建的是一个 <code>LevelUP</code> 的插件，当将具有特定模式的对象保存到数据库时让我们接到通知。例如如果我们订阅 <code>{a:1}</code> 模式，那么当类似 <code>{a:1,b:3}</code> 或 <code>{a:1,c:&#39;x&#39;}</code> 的数据存储到数据库时，我们会收到一个通知。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">levelSubscribe</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  db.subscribe = <span class="function">(<span class="params">pattern, listener</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//[1]</span></span><br><span class="line">    db.on(<span class="string">'put'</span>, (key, val) =&gt; &#123;</span><br><span class="line">      <span class="comment">//[2]</span></span><br><span class="line">      <span class="keyword">const</span> match = <span class="built_in">Object</span>.keys(pattern).every(</span><br><span class="line">        k =&gt; pattern[k] === val[k] <span class="comment">//[3]</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        listener(key, val) <span class="comment">//[4]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用对象增强的方法直接将新方法附加到 <code>db</code> 实例上。</p><h2 id="Adapter-适配器模式"><a href="#Adapter-适配器模式" class="headerlink" title="Adapter(适配器模式)"></a>Adapter(适配器模式)</h2><p>适配器模式其实是包装接口来供不同的调用，例如升级接口后用适配器包装新接口给老代码调用。</p><p><img src="/assets/img/adapter.png" alt="Adapter"></p><h3 id="Using-LevelUP-througn-the-filesystem-API-通过-fs-的-API-来使用-LevelUP"><a href="#Using-LevelUP-througn-the-filesystem-API-通过-fs-的-API-来使用-LevelUP" class="headerlink" title="Using LevelUP througn the filesystem API(通过 fs 的 API 来使用 LevelUP)"></a>Using LevelUP througn the filesystem API(通过 fs 的 API 来使用 LevelUP)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">createFsAdapter</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fs = &#123;&#125;</span><br><span class="line">  fs.readFile = <span class="function"><span class="keyword">function</span>(<span class="params">filename, options, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = options</span><br><span class="line">      options = &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'string'</span>) &#123;</span><br><span class="line">      options = &#123;</span><br><span class="line">        encoding: options</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    db.get(</span><br><span class="line">      path.resolve(filename),</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//[1]</span></span><br><span class="line">        valueEncoding: options.encoding</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">err, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err.type === <span class="string">'NotFoundError'</span>) &#123;</span><br><span class="line">            <span class="comment">//[2]</span></span><br><span class="line">            err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"ENOENT, open '"</span> + filename + <span class="string">"'"</span>)</span><br><span class="line">            err.code = <span class="string">'ENOENT'</span></span><br><span class="line">            err.errno = <span class="number">34</span></span><br><span class="line">            err.path = filename</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> callback &amp;&amp; callback(err)</span><br><span class="line">        &#125;</span><br><span class="line">        callback &amp;&amp; callback(<span class="literal">null</span>, value) <span class="comment">//[3]</span></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.writeFile = <span class="function">(<span class="params">filename, contents, options, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &#123;</span><br><span class="line">    callback = options</span><br><span class="line">    options = &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'string'</span>) &#123;</span><br><span class="line">    options = &#123; <span class="attr">encoding</span>: options &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  db.put(</span><br><span class="line">    path.resolve(filename),</span><br><span class="line">    contents,</span><br><span class="line">    &#123;</span><br><span class="line">      valueEncoding: options.encoding</span><br><span class="line">    &#125;,</span><br><span class="line">    callback</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fs</span><br></pre></td></tr></table></figure><h3 id="In-the-wild-2"><a href="#In-the-wild-2" class="headerlink" title="In the wild"></a>In the wild</h3><p><code>LevelUP</code> 能在浏览器中能以不同的存储后端运行，从 <code>LevelDB</code> 到 <code>IndexedDB</code>。这是通过那些适应了内部 <code>LevelUP API</code> 接口的适配器(<code>Adapter</code>)来实现的。具体有哪些实现方式查看 <a href="https://github.com/rvagg/node-levelup/wiki/Modules#storage-back-ends" target="_blank" rel="noopener">https://github.com/rvagg/node-levelup/wiki/Modules#storage-back-ends</a>。</p><h2 id="Strategy-策略模式"><a href="#Strategy-策略模式" class="headerlink" title="Strategy(策略模式)"></a>Strategy(策略模式)</h2><p><img src="/assets/img/strategy.png" alt="Strategy"></p><p>从图中看出该模式其实是根据配置(或用户输入之类)来做不同逻辑的事，都实现了相同的接口。比大量的 <code>if...else</code> 或 <code>swtich</code> 更易懂。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> objectPath = <span class="built_in">require</span>(<span class="string">'object-path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(strategy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(path) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.get(<span class="keyword">this</span>.data, path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(path, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.set(<span class="keyword">this</span>.data, path, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  read(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Deserializing from <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">this</span>.strategy.deserialize(fs.readFileSync(file, <span class="string">'utf-8'</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  save(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Serializing to <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    fs.writeFileSync(file, <span class="keyword">this</span>.strategy.serialize(<span class="keyword">this</span>.data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Config</span><br></pre></td></tr></table></figure><p>上面代码可以传入不同的配置来做不同的序列化与反序列化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strategy 1</span></span><br><span class="line"><span class="built_in">module</span>.exports.json = &#123;</span><br><span class="line">  deserialize: <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.parse(data),</span><br><span class="line">  serialize: <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">'  '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strategy 2</span></span><br><span class="line"><span class="keyword">const</span> ini = <span class="built_in">require</span>(<span class="string">'ini'</span>) <span class="comment">// https://npmjs.org/package/ini</span></span><br><span class="line"><span class="built_in">module</span>.exports.ini = &#123;</span><br><span class="line">  deserialize: <span class="function"><span class="params">data</span> =&gt;</span> ini.parse(data),</span><br><span class="line">  serialize: <span class="function"><span class="params">data</span> =&gt;</span> ini.stringify(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="State-状态模式"><a href="#State-状态模式" class="headerlink" title="State(状态模式)"></a>State(状态模式)</h2><p>状态模式是策略模式的变种，策略模式一旦确定策略在整个过程中策略(也就是处理逻辑不变)，而状态模式可以动态地改变状态来间接地影响策略：</p><p><img src="/assets/img/state.png" alt="State"></p><p>想象一下，我们有一个酒店预订系统和一个 <code>Reservation</code> 对象来模拟房间预订。</p><p>这是一个经典的情况，我们必须根据其状态来调整对象的行为。考虑以下一系列事件：</p><ul><li>当订单初始创建时，用户可以使用 <code>confirm()</code> 方法确认订单；当然，他们不能使用 <code>cancel()</code> 方法取消预约，因为订单还没有被确认。但是，如果他们在购买之前改变主意，他们可以使用 <code>delete()</code> 方法删除它。</li><li>一旦确认订单，再次使用 <code>confirm()</code> 方法没有任何意义；不过，现在应该可以取消预约，但不能再删除，因为要保留对应记录。</li><li>在预约日期前一天，不应取消订单。因为这太迟了。</li></ul><h3 id="Implementing-a-basic-fail-safe-socket-实现一个基本的-fail-safe-socket"><a href="#Implementing-a-basic-fail-safe-socket-实现一个基本的-fail-safe-socket" class="headerlink" title="Implementing a basic fail-safe socket(实现一个基本的 fail-safe socket)"></a>Implementing a basic fail-safe socket(实现一个基本的 fail-safe socket)</h3><p>尝试一个例子，建立一个 <code>socket</code>，当与服务器断开连接时保存客户端的请求，并将这些请求按顺序排队，等到下次重新连接时按照顺序一一请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file offlineState.js</span></span><br><span class="line"><span class="keyword">const</span> jot = <span class="built_in">require</span>(<span class="string">'json-over-tcp'</span>) <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">OfflineState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(failsafeSocket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket = failsafeSocket</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="comment">// [2]</span></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue.push(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  activate() &#123;</span><br><span class="line">    <span class="comment">// [3]</span></span><br><span class="line">    <span class="keyword">const</span> retry = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.activate(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket = jot.connect(</span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.options,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.socket.removeListener(<span class="string">'error'</span>, retry)</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.changeState(<span class="string">'online'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.once(<span class="string">'error'</span>, retry)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file onlineState.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">OnlineState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(failsafeSocket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket = failsafeSocket</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.write(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  activate() &#123;</span><br><span class="line">    <span class="comment">// [2]</span></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue.forEach(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.socket.write(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.once(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.changeState(<span class="string">'offline'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file failsafeSocket.js</span></span><br><span class="line"><span class="keyword">const</span> OfflineState = <span class="built_in">require</span>(<span class="string">'./offlineState'</span>)</span><br><span class="line"><span class="keyword">const</span> OnlineState = <span class="built_in">require</span>(<span class="string">'./onlineState'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FailsafeSocket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.socket = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.states = &#123;</span><br><span class="line">      offline: <span class="keyword">new</span> OfflineState(<span class="keyword">this</span>),</span><br><span class="line">      online: <span class="keyword">new</span> OnlineState(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.changeState(<span class="string">'offline'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeState(state) &#123;</span><br><span class="line">    <span class="comment">// [2]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Activating state: '</span> + state)</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="keyword">this</span>.states[state]</span><br><span class="line">    <span class="keyword">this</span>.currentState.activate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="comment">// [3]</span></span><br><span class="line">    <span class="keyword">this</span>.currentState.send(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FailsafeSocket(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FailsafeSocket</code> 从一个状态切换到另一个状态，只是切换了实例，具体的发送方法根据状态来选择，离线则使用 <code>OfflineState</code> 来发送，连接则使用 <code>OnlineState</code> 来发送。</p><h2 id="Template-模板模式"><a href="#Template-模板模式" class="headerlink" title="Template(模板模式)"></a>Template(模板模式)</h2><p>和策略模式差不多，只是需要预先定义变体，使用继承改变原有的方法，注意在 <code>js</code> 中模板类是总是抛出异常的类或未定义的方法(因为一定要有实现类才能使用)。</p><p><img src="/assets/img/template.png" alt="Template"></p><h3 id="In-the-wild-3"><a href="#In-the-wild-3" class="headerlink" title="In the wild"></a>In the wild</h3><p>其实在第五章中流的实现就是用了这种模式，自定义的流需要实现 <code>_read</code> 和 <code>_write</code> 这类的方法。</p><h2 id="Middleware-中间件模式"><a href="#Middleware-中间件模式" class="headerlink" title="Middleware(中间件模式)"></a>Middleware(中间件模式)</h2><h3 id="Middleware-in-Express-Express-中的中间件"><a href="#Middleware-in-Express-Express-中的中间件" class="headerlink" title="Middleware in Express(Express 中的中间件)"></a>Middleware in Express(Express 中的中间件)</h3><p>在 <code>Express</code> 中，中间件表示一组服务，通常是函数，它们被组织在一个 <code>pipeline</code> 中，负责处理传入的 <code>HTTP</code> 请求和进行响应。</p><p>一个 <code>Express</code> 的中间件有下面这种形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>req</code> 是传入的 <code>HTTP</code> 请求，<code>res</code> 是响应，<code>next</code> 是当前中间件完成其任务时调用的回调，用来触发 <code>pipeline</code> 中的下一个中间件。可能的 <code>Express</code> 中间件任务有:</p><ul><li>解析请求的 <code>body</code></li><li>压缩/解压 <code>req</code> 和 <code>res</code> 对象</li><li>生成访问日志</li><li>管理 <code>sessions</code></li><li>管理加密的 <code>cookie</code></li><li>提供跨站请求伪造（<code>CSRF</code>）保护</li></ul><p>这些都是与应用程序的主要业务逻辑没有严格关联的任务，也不是 Web 服务器最核心的部分；它们是应用程序公共功能的中间件，使得实际的请求处理程序只关注其主要业务逻辑。</p><h3 id="Middleware-as-a-pattern-中间件作为一种模式"><a href="#Middleware-as-a-pattern-中间件作为一种模式" class="headerlink" title="Middleware as a pattern(中间件作为一种模式)"></a>Middleware as a pattern(中间件作为一种模式)</h3><p>其实类似于 <code>Pipe-Filter</code> 模式，通过看一张图更能明白：</p><p><img src="/assets/img/middleware.png" alt="Middleware"></p><p>最重要的就是这个 <code>Middleware Manager</code>，负责组织和执行中间件功能。</p><ol><li>新的中间件通过 <code>use()</code>(一般约定，当然也可以用别的名称) 来注册，一般是管道末尾。</li><li>注册的中间件在异步顺序执行流中被调用，后一个的输入是前一个中间件的输出。</li><li>中间件只负责处理正常流程，错误通常会触发另一个专门的中间件序列。</li></ol><h3 id="Creating-a-middleware-for-OMQ-为-OMQ-创建一个中间件框架"><a href="#Creating-a-middleware-for-OMQ-为-OMQ-创建一个中间件框架" class="headerlink" title="Creating a middleware for ØMQ(为 ØMQ 创建一个中间件框架)"></a>Creating a middleware for ØMQ(为 ØMQ 创建一个中间件框架)</h3><p><code>ØMQ</code>（也称为 <code>ZMQ</code> 或 <code>ZeroMQ</code>）提供了一个简单的接口，用于通过各种协议在网络中交换原子消息；它的性能绝佳，其基本的抽象集是专门构建的，以促进自定义消息体系结构的实现。因此，经常选择 <code>ØMQ</code> 来构建复杂的分布式系统。</p><p>我们将构建一个中间件基础结构，以抽象通过 <code>ØMQ</code> 套接字传递的数据的预处理和后处理，以便我们可以透明地处理 <code>JSON</code> 对象，同时无缝地压缩通过线路传递的消息。</p><h4 id="The-Middleware-Manager-中间件管理器"><a href="#The-Middleware-Manager-中间件管理器" class="headerlink" title="The Middleware Manager(中间件管理器)"></a>The Middleware Manager(中间件管理器)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">ZmqMiddlewareManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(socket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.socket = socket</span><br><span class="line">    <span class="keyword">this</span>.inboundMiddleware = [] <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">this</span>.outboundMiddleware = []</span><br><span class="line">    socket.on(<span class="string">'message'</span>, message =&gt; &#123;</span><br><span class="line">      <span class="comment">// [2]</span></span><br><span class="line">      <span class="keyword">this</span>.executeMiddleware(<span class="keyword">this</span>.inboundMiddleware, &#123;</span><br><span class="line">        data: message</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = &#123;</span><br><span class="line">      data: data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.executeMiddleware(<span class="keyword">this</span>.outboundMiddleware, message, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.socket.send(message.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  use(middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (middleware.inbound) &#123;</span><br><span class="line">      <span class="keyword">this</span>.inboundMiddleware.push(middleware.inbound)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (middleware.outbound) &#123;</span><br><span class="line">      <span class="keyword">this</span>.outboundMiddleware.unshift(middleware.outbound)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executeMiddleware(middleware, arg, finish) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (index === middleware.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> finish &amp;&amp; finish()</span><br><span class="line">      &#125;</span><br><span class="line">      middleware[index].call(<span class="keyword">this</span>, arg, err =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 这里本应该有对应的错误中间件去处理，为了简洁直接输出</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'There was an error: '</span> + err.message)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个中间件处理完参数后，传递给下一个中间件</span></span><br><span class="line">        iterator.call(<span class="keyword">this</span>, ++index)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator.call(<span class="keyword">this</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理器接收 <code>ØMQ</code> 套接字作为参数，定义一个近站中间件列表和一个出站中间件列表，当有消息来时依次调用进站中间件(按照 <code>use</code> 的顺序来)，需要发送消息时就依次调用出站中间件，被处理后的参数也是一一传播。</p><h4 id="A-middleware-to-support-JSON-messages-一个支持-JSON-消息的中间件"><a href="#A-middleware-to-support-JSON-messages-一个支持-JSON-消息的中间件" class="headerlink" title="A middleware to support JSON messages(一个支持 JSON 消息的中间件)"></a>A middleware to support JSON messages(一个支持 JSON 消息的中间件)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file jsonMiddleware.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.json = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    inbound: <span class="function"><span class="keyword">function</span>(<span class="params">message, next</span>) </span>&#123;</span><br><span class="line">      message.data = <span class="built_in">JSON</span>.parse(message.data.toString())</span><br><span class="line">      next()</span><br><span class="line">    &#125;,</span><br><span class="line">    outbound: <span class="function"><span class="keyword">function</span>(<span class="params">message, next</span>) </span>&#123;</span><br><span class="line">      message.data = <span class="keyword">new</span> Buffer(<span class="built_in">JSON</span>.stringify(message.data))</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要使用的时候只需要 <code>use(jsonMiddleware)</code> 就行了，很方便。</p><h4 id="Using-the-OMQ-middleware-framework-使用-OMQ-中间件框架"><a href="#Using-the-OMQ-middleware-framework-使用-OMQ-中间件框架" class="headerlink" title="Using the ØMQ middleware framework(使用 ØMQ 中间件框架)"></a>Using the ØMQ middleware framework(使用 ØMQ 中间件框架)</h4><h5 id="The-server"><a href="#The-server" class="headerlink" title="The server"></a>The server</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmq = <span class="built_in">require</span>(<span class="string">'zmq'</span>)</span><br><span class="line"><span class="keyword">const</span> ZmqMiddlewareManager = <span class="built_in">require</span>(<span class="string">'./zmqMiddlewareManager'</span>)</span><br><span class="line"><span class="keyword">const</span> jsonMiddleware = <span class="built_in">require</span>(<span class="string">'./jsonMiddleware'</span>)</span><br><span class="line"><span class="keyword">const</span> reply = zmq.socket(<span class="string">'rep'</span>)</span><br><span class="line">reply.bind(<span class="string">'tcp://127.0.0.1:5000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zmqm = <span class="keyword">new</span> ZmqMiddlewareManager(reply)</span><br><span class="line">zmqm.use(jsonMiddleware.json())</span><br></pre></td></tr></table></figure><h5 id="The-client"><a href="#The-client" class="headerlink" title="The client"></a>The client</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmq = <span class="built_in">require</span>(<span class="string">'zmq'</span>)</span><br><span class="line"><span class="keyword">const</span> ZmqMiddlewareManager = <span class="built_in">require</span>(<span class="string">'./zmqMiddlewareManager'</span>)</span><br><span class="line"><span class="keyword">const</span> jsonMiddleware = <span class="built_in">require</span>(<span class="string">'./jsonMiddleware'</span>)</span><br><span class="line"><span class="keyword">const</span> request = zmq.socket(<span class="string">'req'</span>)</span><br><span class="line">request.connect(<span class="string">'tcp://127.0.0.1:5000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zmqm = <span class="keyword">new</span> ZmqMiddlewareManager(request)</span><br><span class="line">zmqm.use(jsonMiddleware.json())</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理服务器响应的中间件</span></span><br><span class="line">zmqm.use(&#123;</span><br><span class="line">  inbound: <span class="function"><span class="keyword">function</span>(<span class="params">message, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Echoed back: '</span>, message.data)</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  zmqm.send(&#123;</span><br><span class="line">    action: <span class="string">'ping'</span>,</span><br><span class="line">    echo: <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="Middleware-using-generators-in-Koa-在-Koa-中使用生成器中间件"><a href="#Middleware-using-generators-in-Koa-在-Koa-中使用生成器中间件" class="headerlink" title="Middleware using generators in Koa(在 Koa 中使用生成器中间件)"></a>Middleware using generators in Koa(在 Koa 中使用生成器中间件)</h3><p><code>Koa</code> 不像 <code>Express</code> 一样使用回调函数来完成中间件模式，而是使用生成器(<code>generator</code>)，使用中间件包装核心应用程序，这种形式更像是洋葱一样：</p><p><img src="/assets/img/koa_middleware.png" alt="Koa Middleware"></p><p>我们来看一个官方的例子(<code>ES7</code>)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start</span><br><span class="line">  ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>可以发现 <code>response</code> 部分才是核心应用程序部分，只不过被其他的中间件包裹起来了，通过 <code>await</code> 分割。</p><blockquote><p>注意，现在 <code>Koa</code> 已经开始使用 <code>ES7</code> 的语法 <code>async</code>/<code>await</code> 了，详情查看<a href="https://koajs.com" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><h2 id="Command-命令模式"><a href="#Command-命令模式" class="headerlink" title="Command(命令模式)"></a>Command(命令模式)</h2><p>可以认为一个命令(<code>Command</code>)是一个封装了重要的信息以便之后去执行一个特定的动作的对象。我们不直接在主体对象上调用一个方法或一个函数，而是创建一个对象来执行这样一次调用；而实现这个意图将是另一个组件的责任，该组件将意图转化为一系列操作。</p><p><img src="/assets/img/command.png" alt="Command"></p><p>命令模式典型的架构：</p><ul><li><code>Command</code>:这是一个封装了足够的信息去调用方法或函数的对象，就像是定义了一个接口。</li><li><code>Client</code>:创建命令对象并提供给调用者(<code>Invoker</code>)。</li><li><code>Invoker</code>:负责执行目标(<code>Target</code>)上的命令，负责调用 <code>Command</code>。</li><li><code>Target</code>(或 <code>Receiver</code>):调用的主体，它可以是一个对象上的单独的方法或函数。</li></ul><p>命令模式有点：</p><ul><li>命令可以稍后执行。</li><li>命令可以被序列化并在网络上传输。这使得我们可以远程分配任务，通过浏览器传输命令给服务器，创建 <code>RPC</code> 系统等等。</li><li>很容易记录操作历史。</li><li>命令是数据同步和冲突解决某些算法的重要部分。</li><li>定时执行的命令可以取消；命令也可以撤销(<code>undone</code>)。</li><li>命令可以组合起来，用来创建原子事务或实现同时执行一些操作的机制。</li><li>一组命令可以有不同的变化，例如可以删除、插入、分割等等。</li></ul><h3 id="A-flexible-pattern-一个灵活的模式"><a href="#A-flexible-pattern-一个灵活的模式" class="headerlink" title="A flexible pattern(一个灵活的模式)"></a>A flexible pattern(一个灵活的模式)</h3><p>正如上面所说，命令模式可以有很多种实现方式，我们来看看其中几个。</p><h4 id="A-task-pattern-任务模式"><a href="#A-task-pattern-任务模式" class="headerlink" title="A task pattern(任务模式)"></a>A task pattern(任务模式)</h4><p>最简单的方式就是创建一个闭包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTask</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    target.apply(<span class="literal">null</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种技术允许我们使用单独的组件来控制和调度任务的执行，这在本质上等同于命令模式的调用者(<code>Invoker</code>，其实是同时创建了命令(<code>Command</code>))。</p><h4 id="A-more-complex-command-一个更复杂的命令"><a href="#A-more-complex-command-一个更复杂的命令" class="headerlink" title="A more complex command(一个更复杂的命令)"></a>A more complex command(一个更复杂的命令)</h4><p>我们希望撤销和序列化。命令的目标(<code>Target</code>) 是一个负责发送状态更新的对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> statusUpdateService = &#123;</span><br><span class="line">  statusUpdates: &#123;&#125;,</span><br><span class="line">  sendUpdate: <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Status sent: '</span> + status)</span><br><span class="line">    <span class="keyword">let</span> id = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">1000000</span>)</span><br><span class="line">    statusUpdateService.statusUpdates[id] = status</span><br><span class="line">    <span class="keyword">return</span> id</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyUpdate: <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Status removed: '</span> + id)</span><br><span class="line">    <span class="keyword">delete</span> statusUpdateService.statusUpdates[id]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着创建一个命令来新状态的发布：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSendStatusCmd</span>(<span class="params">service, status</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> postId = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> command = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    postId = service.sendUpdate(status)</span><br><span class="line">  &#125;</span><br><span class="line">  command.undo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (postId) &#123;</span><br><span class="line">      service.destroyUpdate(postId)</span><br><span class="line">      postId = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  command.serialize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">'status'</span>,</span><br><span class="line">      action: <span class="string">'post'</span>,</span><br><span class="line">      status: status</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> command</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>command</code> 本身是一个函数，使用目标的方法发送状态更新，附在上面的 <code>undo</code> 函数直接调用目标的 <code>destroyUpdate</code> 函数来完成命令撤销，<code>serialize</code> 函数构建了一个 <code>JSON</code> 对象记录执行命令所需要的重要信息。</p><p>然后再来创建执行者 <code>Invoker</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.history = []</span><br><span class="line">  &#125;</span><br><span class="line">  run(cmd) &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.push(cmd)</span><br><span class="line">    cmd()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Command executed'</span>, cmd.serialize())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行者还可以做一些额外的操作，如记录命令的执行，远程调用，延迟执行命令，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.history = []</span><br><span class="line">  &#125;</span><br><span class="line">  run(cmd) &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.push(cmd)</span><br><span class="line">    cmd()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Command executed'</span>, cmd.serialize())</span><br><span class="line">  &#125;</span><br><span class="line">  delay(cmd, delay) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.run(cmd)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">  runRemotely(cmd) &#123;</span><br><span class="line">    request.post(</span><br><span class="line">      <span class="string">'http://localhost:3000/cmd'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        json: cmd.serialize()</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Command executed remotely'</span>, cmd.serialize())</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后编写客户端(<code>Client</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invoker = <span class="keyword">new</span> Invoker()</span><br><span class="line"><span class="keyword">const</span> command = createSendStatusCmd(statusUpdateService, <span class="string">'HI!'</span>)</span><br><span class="line">invoker.run(command)</span><br><span class="line">invoker.runRemotely(command)</span><br></pre></td></tr></table></figure><blockquote><p>命令模式最好在需要一些复杂的代码来调用目标上的函数或方法时使用，不然只是简单地调用一个方法就显得非常多余了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Design-Patterns-设计模式&quot;&gt;&lt;a href=&quot;#Design-Patterns-设计模式&quot; class=&quot;headerlink&quot; title=&quot;Design Patterns(设计模式)&quot;&gt;&lt;/a&gt;Design Patterns(设计模式)&lt;/h1&gt;&lt;h2 id=&quot;Factory-工厂&quot;&gt;&lt;a href=&quot;#Factory-工厂&quot; class=&quot;headerlink&quot; title=&quot;Factory(工厂)&quot;&gt;&lt;/a&gt;Factory(工厂)&lt;/h2&gt;&lt;h3 id=&quot;A-generic-interface-for-creating-objects-创建对象的通用接口&quot;&gt;&lt;a href=&quot;#A-generic-interface-for-creating-objects-创建对象的通用接口&quot; class=&quot;headerlink&quot; title=&quot;A generic interface for creating objects(创建对象的通用接口)&quot;&gt;&lt;/a&gt;A generic interface for creating objects(创建对象的通用接口)&lt;/h3&gt;&lt;p&gt;调用一个工厂，而不是直接使用 &lt;code&gt;new&lt;/code&gt; 运算符或 &lt;code&gt;Object.create()&lt;/code&gt; 从一个原型创建一个新的对象，在很多方面是非常方便和灵活的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://1016990109.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第五章</title>
    <link href="http://1016990109.github.io/2018/06/29/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/06/29/Node-js-设计模式读书笔记-第五章/</id>
    <published>2018-06-29T02:35:28.000Z</published>
    <updated>2018-07-04T02:16:09.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Coding-with-Streams-使用流编程"><a href="#Coding-with-Streams-使用流编程" class="headerlink" title="Coding with Streams(使用流编程)"></a>Coding with Streams(使用流编程)</h1><h2 id="Discovering-the-importance-of-streams-流的重要性"><a href="#Discovering-the-importance-of-streams-流的重要性" class="headerlink" title="Discovering the importance of streams(流的重要性)"></a>Discovering the importance of streams(流的重要性)</h2><h3 id="Buffering-versus-streaming-缓存-vs-流"><a href="#Buffering-versus-streaming-缓存-vs-流" class="headerlink" title="Buffering versus streaming(缓存 vs 流)"></a>Buffering versus streaming(缓存 vs 流)</h3><ul><li><code>Buffering</code>:等到所有数据都收集完了才发送给消费者。</li><li><code>Streaming</code>:实时发送数据到消费者。</li></ul><a id="more"></a><p>我们从几个方面来对比这两种方式：</p><h4 id="Spatial-efficiency-空间效率"><a href="#Spatial-efficiency-空间效率" class="headerlink" title="Spatial efficiency(空间效率)"></a>Spatial efficiency(空间效率)</h4><p>当我们需要去读一个非常大的文件时，比方说数百 MB 或 GB，如果等到文件全部读取完了再返回一个巨大的 <code>buffer</code> 就会很快耗尽内存，在 <code>V8</code> 中 <code>buffer</code> 最大不能超过 <code>0x3FFFFFFF</code>(比 1GB 略小)。</p><blockquote><p>在 64 位系统中，<code>buffer</code> 的最大大小为 <code>2^31 - 1</code>(约 2GB)，书中默认是 32 位系统了，详情可查看官方文档给出的<a href="https://nodejs.org/api/buffer.html#buffer_buffer_constants_max_length" target="_blank" rel="noopener">buffer.constants.MAX_LENGTH</a>。</p></blockquote><h5 id="Gzipping-using-a-buffered-API-使用缓冲-API-压缩"><a href="#Gzipping-using-a-buffered-API-使用缓冲-API-压缩" class="headerlink" title="Gzipping using a buffered API(使用缓冲 API 压缩)"></a>Gzipping using a buffered API(使用缓冲 API 压缩)</h5><p>使用下面代码读一个非常大的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>)</span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>]</span><br><span class="line">fs.readFile(file, (err, buffer) =&gt; &#123;</span><br><span class="line">  zlib.gzip(buffer, (err, buffer) =&gt; &#123;</span><br><span class="line">    fs.writeFile(file + <span class="string">'.gz'</span>, buffer, err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'File successfully compressed'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node gzip &lt;big file path&gt;</span><br></pre></td></tr></table></figure><p>会抛出异常，<code>RangeError: File size is greater than possible Buffer:0x7FFFFFFF</code>。</p><h5 id="Gzipping-using-streams-使用流压缩"><a href="#Gzipping-using-streams-使用流压缩" class="headerlink" title="Gzipping using streams(使用流压缩)"></a>Gzipping using streams(使用流压缩)</h5><p>使用流 <code>API</code> 来压缩就没有上面的问题了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>)</span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>]</span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(fs.createWriteStream(file + <span class="string">'.gz'</span>))</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'File successfully compressed'</span>))</span><br></pre></td></tr></table></figure><h4 id="Time-efficiency-时间效率"><a href="#Time-efficiency-时间效率" class="headerlink" title="Time efficiency(时间效率)"></a>Time efficiency(时间效率)</h4><p>考虑一个压缩文件并将该文件上传到远程服务器的例子，如果使用 <code>buffer</code> 来实现，那么就需要等待文件全部读完才能开始上传，服务器也要等到完全接收完才能进行下一步处理，这很明显就浪费了很多时间去等待上一步任务的完成，使用 <code>stream</code> 来处理则没有这些瓶颈，可以一步步处理一个数据块而不是全部的数据，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file gzipReceive.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = req.headers.filename</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'File request received: '</span> + filename)</span><br><span class="line">  req</span><br><span class="line">    .pipe(zlib.createGunzip())</span><br><span class="line">    .pipe(fs.createWriteStream(filename))</span><br><span class="line">    .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      res.end(<span class="string">"That's it\n"</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;filename&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Listening'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// file gzipSend.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> server = process.argv[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  hostname: server,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  method: <span class="string">'PUT'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    filename: path.basename(file),</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/octet-stream'</span>,</span><br><span class="line">    <span class="string">'Content-Encoding'</span>: <span class="string">'gzip'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> req = http.request(options, res =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server response: '</span> + res.statusCode)</span><br><span class="line">&#125;)</span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File successfully sent'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>stream</code> 更像是流水线，我们用一张图来说明这个问题：</p><p><img src="/assets/img/bufferVSstream.png" alt="buffer vs stream"></p><p>一个文件被处理的过程，它经过以下阶段：</p><ol><li>客户端从文件系统中读取</li><li>客户端压缩数据</li><li>客户端将数据发送到服务器</li><li>服务端接收数据</li><li>服务端解压数据</li><li>服务端将数据写入磁盘</li></ol><p>当我们使用 <code>Streams</code> 时，只要我们收到第一个数据块，流水线就会被启动，而不需要等待整个文件的读取。当有多个块时，就会有多条流水线，每个操作又是异步的，完成任务的顺序就变得不确定了，所以需要保证的就是每个阶段数据块的到达顺序了（还好<code>Node.js</code> 的流已经帮我做好了这件事了）。</p><p>总结：使用 <code>stream</code> 的时间效率也要更高。</p><h4 id="Composability-组合型"><a href="#Composability-组合型" class="headerlink" title="Composability(组合型)"></a>Composability(组合型)</h4><p>其实从前面的代码就可以看到，通过 <code>pipe</code> 函数可以很方便的组合处理函数，也就是使用了我们所熟知的 <code>Pipe-Fillter</code> 模式。</p><p>这种模式可以很方便地组合过滤器，使得代码更加清晰，便于维护，同时也加强了功能模块的复用。</p><h2 id="Getting-started-with-streams-开始使用-streams"><a href="#Getting-started-with-streams-开始使用-streams" class="headerlink" title="Getting started with streams(开始使用 streams)"></a>Getting started with streams(开始使用 streams)</h2><h3 id="Anatomy-of-streams-流的结构"><a href="#Anatomy-of-streams-流的结构" class="headerlink" title="Anatomy of streams(流的结构)"></a>Anatomy of streams(流的结构)</h3><p><code>Node.js</code> 中的流都是下面四种抽象类的实现:</p><ul><li>stream.Readable</li><li>stream.Writable</li><li>stream.Duplex(同时 Readable 和 Writable)</li><li>stream.Transform(Duplex 的扩展)</li></ul><p>每个流同时也是 <code>EventEmitter</code> 的一个实例。实际上 <code>Streams</code> 可以产生几种类型的事件，比如 <code>end</code> 事件会在一个可读的 <code>Streams</code> 完成读取后触发，或者 <code>error</code> 事件在出现错误时触发。</p><blockquote><p>注意在生产环境中最好为 <code>Stream</code> 注册错误事件的监听。</p></blockquote><p><code>Stream</code> 支持两种操作模式：</p><ul><li>二进制模式:以数据块形式（例如 <code>buffers</code> 或 <code>strings</code>）流式传输数据</li><li>对象模式:将流数据视为一系列离散对象（这使得我们几乎可以使用任何 <code>JavaScript</code> 值）</li></ul><h3 id="Readable-streams-可读的流"><a href="#Readable-streams-可读的流" class="headerlink" title="Readable streams(可读的流)"></a>Readable streams(可读的流)</h3><p>一个可读的 <code>Streams</code> 表示一个数据源，在 <code>Node.js</code> 中，它使用 <code>stream</code> 模块中的 <code>Readable</code> 抽象类实现。</p><h4 id="Reading-from-a-stream-从一个流中读数据"><a href="#Reading-from-a-stream-从一个流中读数据" class="headerlink" title="Reading from a stream(从一个流中读数据)"></a>Reading from a stream(从一个流中读数据)</h4><p>从可读 <code>Streams</code> 接收数据有两种方式：<code>non-flowing</code>(<code>paused</code>) 模式和 <code>flowing</code> 模式。</p><h5 id="The-non-flowing-mode-paused"><a href="#The-non-flowing-mode-paused" class="headerlink" title="The non-flowing mode(paused)"></a>The non-flowing mode(paused)</h5><p>从可读的 <code>Streams</code> 中读取数据的默认模式是为其附加一个可读事件侦听器，标识已经有数据可以读了。</p><p>然后，在一个循环中，我们读取所有的数据，直到内部 <code>buffer</code> 被清空。这可以使用 <code>read()</code> 方法完成，该方法同步从内部缓冲区中读取数据，并返回表示数据块的 <code>Buffer</code> 或 <code>String</code> 对象。然后，在一个循环中，我们读取所有的数据，直到内部 <code>buffer</code> 被清空。这可以使用 <code>read()</code> 方法完成，该方法同步从内部缓冲区中读取数据，并返回表示数据块的 <code>Buffer</code> 或 <code>String</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="keyword">while</span> ((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Chunk read: (<span class="subst">$&#123;chunk.length&#125;</span>) "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, () =&gt; process.stdout.write(<span class="string">'End of stream'</span>))</span><br></pre></td></tr></table></figure><p><code>read()</code> 方法是一个同步操作，它从可读 <code>Streams</code> 的内部 <code>Buffers</code> 区中提取数据块。如果 <code>Streams</code> 在二进制模式下工作，返回的数据块默认为一个 <code>Buffer</code> 对象。当没有数据消费时，<code>read()</code> 会返回 <code>undefined</code>。</p><p>我们也可以尝试将我们的程序与其他程序连接起来;这可以使用管道运算符（|），它将程序的标准输出重定向到另一个程序的标准输入:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;path to a file&gt; | node readStdin</span><br></pre></td></tr></table></figure><h5 id="The-flowing-mode"><a href="#The-flowing-mode" class="headerlink" title="The flowing mode"></a>The flowing mode</h5><p>另外一种读取流的方式是使用流动模式，给 <code>data</code> 事件添加一个监听，这种模式是一有数据就会推送到这个监听器中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">'data'</span>, chunk =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk read: (<span class="subst">$&#123;chunk.length&#125;</span>) "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, () =&gt; process.stdout.write(<span class="string">'End of stream'</span>))</span><br></pre></td></tr></table></figure><p><code>flowing</code> 模式是旧版 <code>Streams</code> 接口（也称为 <code>Streams1</code>）的继承，这里补充一下从 <code>Stream1</code> 到 <code>Stream3</code> 的比较:</p><h5 id="从-Stream1-到-Stream3"><a href="#从-Stream1-到-Stream3" class="headerlink" title="从 Stream1 到 Stream3"></a>从 Stream1 到 Stream3</h5><ul><li>Stream1 推流</li></ul><p>在最初的流实现中，每次当有数据可用时，都有一个数据事件发生，开发者可以使用 <code>pause()</code> 和 <code>resume()</code> 来控制流，调用 <code>pause()</code> 将引起底层停止发送数据事件的发生。<br>存在的问题:</p><ol><li>暂停 <code>pause()</code> 方法并不暂停，它只是建议 <code>advisory-only</code>。</li><li>无论你是否准备好，’数据’ 事件就立即来了。</li><li>没有办法消费使用指定数量的字节，然后将剩余的交给程序其他部分来处理。</li></ol><ul><li>Stream2 拉流</li></ul><p><code>Node</code> <code>0.10</code> 引入了 <code>Stream2</code>，增加了 <code>Pull</code> 拉方式，也就是从数据流读取时可以采取拉方式，这样解决了以前的问题，流总是从暂停状态开始，通过 <code>read(numBytes)</code> 读取，此外，当数据可用时，一个可读的事件将被触发。</p><p><code>Stream2</code> 预设模式就是拉方式也就是非流动模式，想要转回流动模式只要给 <code>data</code> 事件加上监听就行了。</p><blockquote><p>注意：Flowing/Non-flowing 模式只能择一使用。也就是 <code>data</code> 和 <code>readable</code> 事件监听只能有一个，虽然二者同时监听程序也不会挂掉，但是还是会出现预期之外的现象。</p></blockquote><ul><li>Stream3 混合流</li></ul><p>可以看看<a href="https://nodejs.org/dist/latest-v10.x/docs/api/stream.html#stream_readable_streams" target="_blank" rel="noopener">官方文档</a>对现在可读流的描述。<br>从 <code>Node</code> <code>0.12</code> 开始，<code>Stream</code> 就已经使用这种方式了，可以在 <code>flowing</code> 模式和 <code>paused</code> 模式之间切换，延续至今。</p><p><code>Readable</code> 流初始为 <code>paused</code> 模式，有以下行为会转为 <code>flowing</code> 模式：</p><ul><li>添加 <code>data</code> 事件监听</li><li>调用 <code>stream.resume()</code></li><li>调用 <code>stream.pipe()</code> 将数据发送到一个 <code>Writable Stream</code></li></ul><p>使用下面某一种方法可以切换回 <code>paused</code> 模式：</p><ul><li>如果没有定义过管道，直接调用 <code>stream.pause()</code></li><li>如果有管道定义过，必须先删除所有管道，</li></ul><blockquote><p>注意：移除 <code>data</code> 事件的监听并不会自动切回 <code>paused</code> 模式；如果还有管道没有被移除，调用 <code>stream.pause()</code> 也不能保证就是 <code>paused</code> 模式。</p></blockquote><blockquote><p>注意：在 <code>flowing</code> 模式下如果没有消费者消费数据，那么数据会丢失。举个例子：调用 <code>readable.resume</code> 时没有绑定 <code>data</code> 事件或该事件已被移除，这样数据就丢失了。</p></blockquote><p>推荐使用 <code>stream.pipe()</code> 来处理，这种方式是比较容易处理流数据的。</p><h4 id="Implementing-Readable-streams-实现可读流"><a href="#Implementing-Readable-streams-实现可读流" class="headerlink" title="Implementing Readable streams(实现可读流)"></a>Implementing Readable streams(实现可读流)</h4><p>需要实现 <code>_read([size])</code> 方法，<code>push()</code> 方法将数据放到缓冲区：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">'stream'</span>)</span><br><span class="line"><span class="keyword">const</span> Chance = <span class="built_in">require</span>(<span class="string">'chance'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _read(size) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string() <span class="comment">//[1]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Pushing chunk of size: <span class="subst">$&#123;chunk.length&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.push(chunk, <span class="string">'utf8'</span>) <span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      chance.bool(&#123;</span><br><span class="line">        likelihood: <span class="number">5</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">//[3]</span></span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = RandomStream</span><br></pre></td></tr></table></figure><h3 id="Writable-streams-可写流"><a href="#Writable-streams-可写流" class="headerlink" title="Writable streams(可写流)"></a>Writable streams(可写流)</h3><p>一个可写的 <code>stream</code> 表示一个数据目标点，在 <code>Node.js</code> 中，它使用 <code>stream</code> 模块中的 <code>Writable</code> 抽象类来实现。</p><h4 id="Writing-to-a-stream"><a href="#Writing-to-a-stream" class="headerlink" title="Writing to a stream"></a>Writing to a stream</h4><p><code>writable.write(chunk, [encoding], [callback])</code> 写数据。</p><p><code>writable.end([chunk], [encoding], [callback])</code> 表示没有更多的数据写入了，也就是流的结束，这种情况 <code>callback</code> 相当于给 <code>finish</code> 事件加了个监听。</p><h4 id="Back-pressure-回压"><a href="#Back-pressure-回压" class="headerlink" title="Back-pressure(回压)"></a>Back-pressure(回压)</h4><p>当写入数据比消费该数据要快时，可以先缓冲数据，如果超过某个限制就需要通知 <code>writer</code> 不能再写了。</p><p>内部 <code>buffer</code> 超过 <code>highWaterMark</code> 的限制时，<code>write()</code> 方法会返回 <code>false</code>。</p><p>看一个使用例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Chance = <span class="built_in">require</span>(<span class="string">'chance'</span>)</span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance()</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateMore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//[1]</span></span><br><span class="line">      <span class="keyword">while</span> (</span><br><span class="line">        chance.bool(&#123;</span><br><span class="line">          likelihood: <span class="number">95</span></span><br><span class="line">        &#125;)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">const</span> shouldContinue = res.write(</span><br><span class="line">          chance.string(&#123;</span><br><span class="line">            length: <span class="number">16</span> * <span class="number">1024</span> - <span class="number">1</span></span><br><span class="line">          &#125;) <span class="comment">//[2]</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (!shouldContinue) &#123;</span><br><span class="line">          <span class="comment">//[3]</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'Backpressure'</span>)</span><br><span class="line">          <span class="keyword">return</span> res.once(<span class="string">'drain'</span>, generateMore)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.end(<span class="string">'\nThe end...\n'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'All data was sent'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    generateMore()</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8080</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Listening on http://localhost:8080'</span>))</span><br></pre></td></tr></table></figure><blockquote><p>注意当 <code>write()</code> 返回 <code>false</code> 时，跳出函数，等到队列释放后，<code>Writable Stream</code> 会触发一个 <code>drain</code> 事件，这时候再继续启动写入程序继续写入数据。</p></blockquote><h4 id="Implementing-Writabel-streams-实现可写流"><a href="#Implementing-Writabel-streams-实现可写流" class="headerlink" title="Implementing Writabel streams(实现可写流)"></a>Implementing Writabel streams(实现可写流)</h4><p>实现可写流需要实现 <code>_wirte()</code> 方法。</p><p>让我们构建一个可写入的 <code>stream</code>，它接收对象的格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &lt;path to a file&gt;</span><br><span class="line">  content: &lt;string or buffer&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个对象，我们的 <code>stream</code> 必须将 <code>content</code> 部分保存到在给定路径中创建的文件中。 我们可以立即看到，我们 <code>stream</code> 的输入是对象，而不是 <code>Strings</code> 或 <code>Buffers</code>，这意味着我们的 <code>stream</code> 必须以 <strong>对象模式</strong> 工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">'stream'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> mkdirp = <span class="built_in">require</span>(<span class="string">'mkdirp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToFileStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Writable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;</span><br><span class="line">      objectMode: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _write(chunk, encoding, callback) &#123;</span><br><span class="line">    mkdirp(path.dirname(chunk.path), err =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(err)</span><br><span class="line">      &#125;</span><br><span class="line">      fs.writeFile(chunk.path, chunk.content, callback)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = ToFileStream</span><br></pre></td></tr></table></figure><p>传入 <code>options</code> 为 <code>{objectMode: true}</code> 设置可写流为 <strong>对象模式</strong>，接收的其他选项如下：</p><ul><li><code>highWaterMark</code>（默认值是 <code>16KB</code>）：控制 <code>back-pressure</code> 的上限。</li><li><code>decodeStrings</code>（默认为 <code>true</code>）：在字符串传递给 <code>_write()</code> 方法之前，将字符串自动解码为二进制 <code>buffer</code>，<strong>在对象模式下这个参数被忽略</strong>。</li></ul><h3 id="Duplex-streams-复用流，同时可写可读"><a href="#Duplex-streams-复用流，同时可写可读" class="headerlink" title="Duplex streams(复用流，同时可写可读)"></a>Duplex streams(复用流，同时可写可读)</h3><p>同时实现 <code>stream.Readable</code> 和 <code>stream.Writable</code>。</p><p><code>options</code> 和上文提到的都一样，有一个额外的选项 <code>allowHalfOpen</code> (默认是 <code>true</code>)，如果设置为 <code>false</code> 那么当读/写一方关闭时，整个都会关闭。</p><p>常见的 <code>Deplex Stream</code> 就是 <code>net</code> 的 <code>Socket</code>。</p><h3 id="Transform-streams-转换流"><a href="#Transform-streams-转换流" class="headerlink" title="Transform streams(转换流)"></a>Transform streams(转换流)</h3><p>转换流是复用流的扩展，在同时实现了 <code>Readable</code> 和 <code>Writable</code> 的基础上，加了一层转换，</p><p><img src="/assets/img/transform_stream.png" alt="Transform Stream"></p><h4 id="Implementing-Transform-streams-实现转换流"><a href="#Implementing-Transform-streams-实现转换流" class="headerlink" title="Implementing Transform streams(实现转换流)"></a>Implementing Transform streams(实现转换流)</h4><p>我们来实现一个 <code>Transform Stream</code>，它将替换给定所有出现的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file replaceStream.js</span></span><br><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">'stream'</span>)</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(searchString, replaceString) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.searchString = searchString</span><br><span class="line">    <span class="keyword">this</span>.replaceString = replaceString</span><br><span class="line">    <span class="keyword">this</span>.tailPiece = <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="keyword">const</span> pieces = (<span class="keyword">this</span>.tailPiece + chunk) <span class="comment">//[1]</span></span><br><span class="line">      .split(<span class="keyword">this</span>.searchString)</span><br><span class="line">    <span class="keyword">const</span> lastPiece = pieces[pieces.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> tailPieceLen = <span class="keyword">this</span>.searchString.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.tailPiece = lastPiece.slice(-tailPieceLen) <span class="comment">//[2]</span></span><br><span class="line">    pieces[pieces.length - <span class="number">1</span>] = lastPiece.slice(<span class="number">0</span>, -tailPieceLen)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.push(pieces.join(<span class="keyword">this</span>.replaceString)) <span class="comment">//[3]</span></span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _flush(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.tailPiece)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ReplaceStream</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReplaceStream = <span class="built_in">require</span>(<span class="string">'./replaceStream'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = <span class="keyword">new</span> ReplaceStream(<span class="string">'World'</span>, <span class="string">'Node.js'</span>)</span><br><span class="line">rs.on(<span class="string">'data'</span>, chunk =&gt; <span class="built_in">console</span>.log(chunk.toString()))</span><br><span class="line"></span><br><span class="line">rs.write(<span class="string">'Hello W'</span>)</span><br><span class="line">rs.write(<span class="string">'orld!'</span>)</span><br><span class="line">rs.end()</span><br></pre></td></tr></table></figure><p>上面代码的思路是将新来的数据块与上次处理后剩下的数据(最大长度为搜索字符串长度减 1，这样长度的字符串是不可能包含搜索字符串的，保证前面的出现的搜索字符串已被处理完)拼接起来，按照搜索字符串分割，最后一片除掉尾部搜索字符串长度减 1 长度的字符串，然后重新拼接处理后的字符串 <code>pieces.join(this.replaceString)</code>，再 <code>push</code> 进可读流，这里是触发 <code>data</code> 事件。</p><h3 id="Connecting-streams-using-pipes-使用管道连接流"><a href="#Connecting-streams-using-pipes-使用管道连接流" class="headerlink" title="Connecting streams using pipes(使用管道连接流)"></a>Connecting streams using pipes(使用管道连接流)</h3><p><code>readable.pipe(writable, [options])</code>，使用管道连接了 <code>Readable Stream</code> 和 <code>Writable Stream</code>，很显然，<code>pipe()</code> 方法将从 <code>Readable Stream</code> 中发出的数据抽取到所提供的 <code>Writable Stream</code> 中，该方法返回作为参数提供的 <code>writable</code>。</p><p>将两个 <code>Streams</code> 连接到一起时，则允许数据自动流向 <code>Wratable Stream</code>，所以不需要调用 <code>read()</code> 或 <code>write()</code> 方法；但最重要的是不需要控制 <code>back-pressure</code>，因为它会自动处理。</p><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReplaceStream = <span class="built_in">require</span>(<span class="string">'./replaceStream'</span>)</span><br><span class="line">process.stdin</span><br><span class="line">  .pipe(<span class="keyword">new</span> ReplaceStream(process.argv[<span class="number">2</span>], process.argv[<span class="number">3</span>]))</span><br><span class="line">  .pipe(process.stdout)</span><br></pre></td></tr></table></figure><blockquote><p>注意：error 事件不会通过管道自动传播。也就是说</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.pipe(stream2).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>是不会监听到 <code>stream1</code> 的错误的，要想监听 <code>stream1</code> 的错误只能另外加一个监听函数。</p></blockquote><h4 id="Through-and-form-for-working-with-streams-through-和-form-库"><a href="#Through-and-form-for-working-with-streams-through-和-form-库" class="headerlink" title="Through and form for working with streams(through 和 form 库)"></a>Through and form for working with streams(through 和 form 库)</h4><p>总是去自定义一个流是比较繁琐的，这里提供两个库能简单地创建流：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transform = through2([options], [_transform], [_flush])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readable = from2([options], _read)</span><br></pre></td></tr></table></figure><h2 id="Asynchorous-control-flow-with-streams-使用流的异步控制流"><a href="#Asynchorous-control-flow-with-streams-使用流的异步控制流" class="headerlink" title="Asynchorous control flow with streams(使用流的异步控制流)"></a>Asynchorous control flow with streams(使用流的异步控制流)</h2><h3 id="Sequential-execution-顺序执行"><a href="#Sequential-execution-顺序执行" class="headerlink" title="Sequential execution(顺序执行)"></a>Sequential execution(顺序执行)</h3><p>默认情况 <code>stream</code> 是顺序处理数据的，这是 <code>Stream</code> 的一个重要属性，可以利用这个属性实现传统的异步控制流：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fromArray = <span class="built_in">require</span>(<span class="string">'from2-array'</span>)</span><br><span class="line"><span class="keyword">const</span> through = <span class="built_in">require</span>(<span class="string">'through2'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatFiles</span>(<span class="params">destination, files, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> destStream = fs.createWriteStream(destination)</span><br><span class="line">  fromArray</span><br><span class="line">    .obj(files) <span class="comment">//[1]</span></span><br><span class="line">    .pipe(</span><br><span class="line">      through.obj(<span class="function">(<span class="params">file, enc, done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//[2]</span></span><br><span class="line">        <span class="keyword">const</span> src = fs.createReadStream(file)</span><br><span class="line">        src.pipe(</span><br><span class="line">          destStream,</span><br><span class="line">          &#123; <span class="attr">end</span>: <span class="literal">false</span> &#125;</span><br><span class="line">        )</span><br><span class="line">        src.on(<span class="string">'end'</span>, done) <span class="comment">//[3]</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">//[4]</span></span><br><span class="line">      destStream.end()</span><br><span class="line">      callback()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = concatFiles</span><br></pre></td></tr></table></figure><ol><li>首先从文件数组创建 <code>Readable Stream</code>。</li><li>创建 <code>Transform Stream</code> 来处理每个文件，对于每个文件创建一个 <code>Readable Stream</code>，通过管道将读取的数据传递给目标 <code>Writable Stream</code>，指定第二个参数 <code>end</code> 为 <code>false</code> 确保处理完每个文件后 <code>Writable Stream</code> 不会被关闭。</li><li>所有文件处理完后，触发 <code>finish</code> 事件，关闭 <code>Writable Stream</code>，调用 <code>concatFiles</code> 的 <code>callback</code>。</li></ol><h3 id="Unordered-parallel-execution-无序并行执行"><a href="#Unordered-parallel-execution-无序并行执行" class="headerlink" title="Unordered parallel execution(无序并行执行)"></a>Unordered parallel execution(无序并行执行)</h3><p>有时候数据块之间没有任何关系，这时候可以并行执行异步任务，这通常发生在 <strong>对象模式</strong> 中，而对于 <strong>二进制模式</strong> 流是非常罕见的。</p><h4 id="Implementing-an-unordered-parallel-stream-实现无序并行流"><a href="#Implementing-an-unordered-parallel-stream-实现无序并行流" class="headerlink" title="Implementing an unordered parallel stream(实现无序并行流)"></a>Implementing an unordered parallel stream(实现无序并行流)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">'stream'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParallelStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(userTransform) &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123; <span class="attr">objectMode</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="keyword">this</span>.userTransform = userTransform</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.terminateCallback = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(chunk, enc, done) &#123;</span><br><span class="line">    <span class="keyword">this</span>.running++</span><br><span class="line">    <span class="keyword">this</span>.userTransform(</span><br><span class="line">      chunk,</span><br><span class="line">      enc,</span><br><span class="line">      <span class="keyword">this</span>._onComplete.bind(<span class="keyword">this</span>),</span><br><span class="line">      <span class="keyword">this</span>.push.bind(<span class="keyword">this</span>)</span><br><span class="line">    )</span><br><span class="line">    done()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _flush(done) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.running &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.terminateCallback = done</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      done()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _onComplete(err) &#123;</span><br><span class="line">    <span class="keyword">this</span>.running--</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.running === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.terminateCallback &amp;&amp; <span class="keyword">this</span>.terminateCallback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ParallelStream</span><br></pre></td></tr></table></figure><p>这个同步执行流接收一个 <code>userTransform</code> 作为参数，这个是用户规定的异步转换流（用来真实处理流数据的），<code>_transform()</code> 函数中不用等待 <code>userTransform()</code> 执行完成，直接执行 <code>done()</code> 通知改转换已完成，另一方面将 <code>this._onComplete()</code> 传递给 <code>userTransform()</code>，使得在真正的处理完成后调用 <code>this._onComplete()</code>。</p><p>在 <code>Stream</code> 终止前会调用 <code>_flush()</code> 方法，如果这个时候还有异步任务在执行(<code>running &gt; 0</code>)那么将会持有 <code>done</code> 的引用，等到所有异步任务完成调用 <code>this._onComplete()</code> 回调函数时才会调用真实的 <code>done</code> 方法即 <code>this.terminateCallback</code>，调用后会结束 <code>Stream</code>，触发 <code>finish</code> 事件。</p><h4 id="Implementing-a-URL-status-monitoring-application-实现一个-URL-状态监听应用"><a href="#Implementing-a-URL-status-monitoring-application-实现一个-URL-状态监听应用" class="headerlink" title="Implementing a URL status monitoring application(实现一个 URL 状态监听应用)"></a>Implementing a URL status monitoring application(实现一个 URL 状态监听应用)</h4><p>看一个使用上面实现的 <code>Paralle Stream</code> 的一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> split = <span class="built_in">require</span>(<span class="string">'split'</span>)</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</span><br><span class="line"><span class="keyword">const</span> ParallelStream = <span class="built_in">require</span>(<span class="string">'./parallelStream'</span>)</span><br><span class="line"></span><br><span class="line">fs.createReadStream(process.argv[<span class="number">2</span>]) <span class="comment">//[1]</span></span><br><span class="line">  .pipe(split()) <span class="comment">//[2]</span></span><br><span class="line">  .pipe(</span><br><span class="line">    <span class="keyword">new</span> ParallelStream(<span class="function">(<span class="params">url, enc, done, push</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//[3]</span></span><br><span class="line">      <span class="keyword">if</span> (!url) <span class="keyword">return</span> done()</span><br><span class="line">      request.head(url, (err, response) =&gt; &#123;</span><br><span class="line">        push(url + <span class="string">' is '</span> + (err ? <span class="string">'down'</span> : <span class="string">'up'</span>) + <span class="string">'\n'</span>)</span><br><span class="line">        done()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">'results.txt'</span>)) <span class="comment">//[4]</span></span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'All urls were checked'</span>))</span><br></pre></td></tr></table></figure><ol><li>首先，我们通过给定的文件参数创建一个可读的 <code>Streams</code>，便于接下来读取文件。</li><li>我们通过 <code>split</code> 将输入的文件内容输出到一个 <code>Transform Stream</code> 管道中，并且将数据的每一行分成不同的块。</li><li>然后，使用 <code>ParallelStream</code> 来检查 <code>URL</code>，我们发送一个 <code>HEAD</code> 请求然后等待请求的 <code>response</code>。当请求返回时，我们把请求的结果 <code>push</code> 到 <code>stream</code> 中。</li><li>最后，通过管道把结果保存到 <code>results.txt</code> 文件中。</li></ol><h3 id="Unordered-limited-parallel-execution-无序限制并行执行"><a href="#Unordered-limited-parallel-execution-无序限制并行执行" class="headerlink" title="Unordered limited parallel execution(无序限制并行执行)"></a>Unordered limited parallel execution(无序限制并行执行)</h3><p>和第三种中异步控制流实现限制并行执行一样，改变 <code>_transform</code> 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.running++</span><br><span class="line"><span class="keyword">this</span>.userTransform(</span><br><span class="line">  chunk,</span><br><span class="line">  enc,</span><br><span class="line">  <span class="keyword">this</span>.push.bind(<span class="keyword">this</span>),</span><br><span class="line">  <span class="keyword">this</span>._onComplete.bind(<span class="keyword">this</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.running &lt; <span class="keyword">this</span>.concurrency) &#123;</span><br><span class="line">  done()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.continueCallback = done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_flush</code> 方法保持不变，更改 <code>_onComplete</code> 方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_onComplete(err) &#123;</span><br><span class="line">  <span class="keyword">this</span>.running--</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tmpCallback = <span class="keyword">this</span>.continueCallback</span><br><span class="line">  <span class="keyword">this</span>.continueCallback = <span class="literal">null</span></span><br><span class="line">  tmpCallback &amp;&amp; tmpCallback()</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.running === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.terminateCallback &amp;&amp; <span class="keyword">this</span>.terminateCallback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，调用 <code>_transform</code> 需要检查是否达到最大执行任务数，达到则不会立即调用 <code>done</code>，即流处理会阻塞在那里，直到正在执行的任务中某一个结束调用 <code>_onComplete</code> 才会执行 <code>done</code>，这样才能继续处理下一个 <code>chunk</code>。</p><h4 id="Ordered-parallel-execution-有序并行执行"><a href="#Ordered-parallel-execution-有序并行执行" class="headerlink" title="Ordered parallel execution(有序并行执行)"></a>Ordered parallel execution(有序并行执行)</h4><p>对接收顺序有要求的场景下仍然可以使用并行执行，只不过需要对每个任务发出的数据排序（和接收到数据的顺序一致），这里不再累述，可以使用第三方库 <a href="https://npmjs.org/package/through2-parallel" target="_blank" rel="noopener">throught2-parallel</a>。</p><h2 id="Piping-patterns-管道模式"><a href="#Piping-patterns-管道模式" class="headerlink" title="Piping patterns(管道模式)"></a>Piping patterns(管道模式)</h2><h3 id="Combining-streams-组合流"><a href="#Combining-streams-组合流" class="headerlink" title="Combining streams(组合流)"></a>Combining streams(组合流)</h3><p>单个 <code>Stream</code> 使得我们可以复用一条流，那当我们想要复用整条流水线时怎么办，即合并多个 <code>Stream</code> 使得看起来是一整个 <code>Stream</code>，如下图：</p><p><img src="/assets/img/combining_streams.png" alt="Combining Streams"></p><p>从图中可以看出，组合流其实就是 <strong>写入第一个流，然后从最后一个流读</strong>。</p><p>一个组合流通常是一个 <code>Duplex Stream</code>，通过连接第一个流到写入端和连接最后一个流到读取端构建这个复用流。</p><p>我们知道错误在管道中是不能冒泡出去，这就意味着我们得为每一个流都添加一个错误监听，然而组合流实际上是个黑盒，作为一个流错误的聚合器。</p><p>总之，组合流有两个优点：</p><ul><li>管道内部是一个黑盒，对使用者不可见。</li><li>简化了错误管理，因为我们不必为管道中的每个单元附加一个错误侦听器，而只需要给组合流自身附加上就可以了。</li></ul><p>组合流是非常普遍的用法，所以已经有现成的库做了这些封装了，可以看看 <a href="https://www.npmjs.com/package/multipipe" target="_blank" rel="noopener">multipipe</a> 或 <a href="https://www.npmjs.org/package/combine-stream" target="_blank" rel="noopener">combine-stream</a>。</p><h4 id="Implementing-a-combined-stream-实现一个组合流"><a href="#Implementing-a-combined-stream-实现一个组合流" class="headerlink" title="Implementing a combined stream(实现一个组合流)"></a>Implementing a combined stream(实现一个组合流)</h4><p>看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"><span class="keyword">const</span> combine = <span class="built_in">require</span>(<span class="string">'multipipe'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports.compressAndEncrypt = <span class="function"><span class="params">password</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> combine(zlib.createGzip(), crypto.createCipher(<span class="string">'aes192'</span>, password))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.decryptAndDecompress = <span class="function"><span class="params">password</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> combine(crypto.createDecipher(<span class="string">'aes192'</span>, password), zlib.createGunzip())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个组合流是压缩并加密，一个组合流是解密并解压。</p><blockquote><p>注意：<code>compressAndEcrypt</code> 或 <code>decryptAndDecompress</code> 直接监听 <code>error</code> 事件是能监听整个流水线中的任何流错误的，这要得益于组合流的黑盒模式了。</p></blockquote><h3 id="Forking-streams-分流"><a href="#Forking-streams-分流" class="headerlink" title="Forking streams(分流)"></a>Forking streams(分流)</h3><p>我们可以通过将一个 <code>Readable Stream</code> 用管道传输给多个 <code>Writable Stream</code> 来达到分流的目的。</p><p><img src="/assets/img/forking_streams.png" alt="Forking Streams"></p><h4 id="Implementing-a-multiple-checksum-generator-实现一个多重检验生成器"><a href="#Implementing-a-multiple-checksum-generator-实现一个多重检验生成器" class="headerlink" title="Implementing a multiple checksum generator(实现一个多重检验生成器)"></a>Implementing a multiple checksum generator(实现一个多重检验生成器)</h4><p>创建一个工具类用来输出给定文件的 <code>md5</code> 和 <code>sha1</code> 的 <code>hash</code> 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"><span class="keyword">const</span> sha1Stream = crypto.createHash(<span class="string">'sha1'</span>)</span><br><span class="line">sha1Stream.setEncoding(<span class="string">'base64'</span>)</span><br><span class="line"><span class="keyword">const</span> md5Stream = crypto.createHash(<span class="string">'md5'</span>)</span><br><span class="line">md5Stream.setEncoding(<span class="string">'base64'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputFile = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> inputStream = fs.createReadStream(inputFile)</span><br><span class="line">inputStream.pipe(sha1Stream).pipe(fs.createWriteStream(inputFile + <span class="string">'.sha1'</span>))</span><br><span class="line">inputStream.pipe(md5Stream).pipe(fs.createWriteStream(inputFile + <span class="string">'.md5'</span>))</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li><p>当 <code>inputStream</code> 结束时，<code>md5Stream</code> 和 <code>sha1Stream</code> 会自动结束，除非当调用 <code>pipe()</code> 时指定了 <code>end</code> 选项为 <code>false</code>。</p></li><li><p><code>Stream</code> 的两个分支会接受相同的数据块，因此当对数据执行一些副作用的操作时我们必须非常谨慎，因为那样会影响分流的另一个分支。</p></li><li><p>黑盒外会产生回压，来自 <code>inputStream</code> 的数据流的流速会和接收最慢的分支的流速相同。</p></li></ul><h3 id="Merging-streams-合并流"><a href="#Merging-streams-合并流" class="headerlink" title="Merging streams(合并流)"></a>Merging streams(合并流)</h3><p>合并流和分流相对，是将多个 <code>Readable Stream</code> 通过管道输入到一个 <code>Writable Stream</code> 中。</p><p><img src="/assets/img/merging_streams.png" alt="Merging Streams"></p><p>这是一个比较简单的操作，唯一需要注意的是 <code>Writable Stream</code> 的关闭，选项 <code>end</code> 需要设置为 <code>false</code>，否则在一个输入流结束后，写入流也就跟着结束了，尽管另一个输入流还没处理完，需要在所有输入流都被读过之后才能调用 <code>end()</code> 方法。</p><h4 id="Creating-a-tarball-from-multiple-directories-从多个文件夹创建压缩包"><a href="#Creating-a-tarball-from-multiple-directories-从多个文件夹创建压缩包" class="headerlink" title="Creating a tarball from multiple directories(从多个文件夹创建压缩包)"></a>Creating a tarball from multiple directories(从多个文件夹创建压缩包)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tar = <span class="built_in">require</span>(<span class="string">'tar'</span>)</span><br><span class="line"><span class="keyword">var</span> fstream = <span class="built_in">require</span>(<span class="string">'fstream'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> destination = path.resolve(process.argv[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">var</span> sourceA = path.resolve(process.argv[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">var</span> sourceB = path.resolve(process.argv[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pack = tar.Pack()</span><br><span class="line">pack.pipe(fstream.Writer(destination))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> endCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onEnd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (++endCount === <span class="number">2</span>) &#123;</span><br><span class="line">    pack.end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sourceStreamA = fstream</span><br><span class="line">  .Reader(&#123;</span><br><span class="line">    type: <span class="string">'Directory'</span>,</span><br><span class="line">    path: sourceA</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, onEnd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sourceStreamB = fstream</span><br><span class="line">  .Reader(&#123;</span><br><span class="line">    type: <span class="string">'Directory'</span>,</span><br><span class="line">    path: sourceB</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, onEnd)</span><br><span class="line"></span><br><span class="line">sourceStreamA.pipe(</span><br><span class="line">  pack,</span><br><span class="line">  &#123; <span class="attr">end</span>: <span class="literal">false</span> &#125;</span><br><span class="line">)</span><br><span class="line">sourceStreamB.pipe(</span><br><span class="line">  pack,</span><br><span class="line">  &#123; <span class="attr">end</span>: <span class="literal">false</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>两个源文件通过 <code>pack</code> 压缩到一个流中: <code>node mergeTar dest.tar /path/to/sourceA /path/to/sourceB</code>。</p><p>这种合并是无顺序的，这在某些对象流中是可以接收的，但是二进制流通常就不行了。</p><p>合并流还有一种变种，是按顺序合并流的，一个接一个地合并源 <code>Stream</code>，当前一个结束时，开始发送第二段数据块（就像连接所有源 <code>Stream</code> 的输出一样）。有个 <code>npm</code> 的包 <a href="https://npmjs.org/package/multistream" target="_blank" rel="noopener">multistream</a> 可以处理这种场景。</p><h3 id="Multiplexing-and-demultiplexing-多路复用和多路分解"><a href="#Multiplexing-and-demultiplexing-多路复用和多路分解" class="headerlink" title="Multiplexing and demultiplexing(多路复用和多路分解)"></a>Multiplexing and demultiplexing(多路复用和多路分解)</h3><p>合并流的一种特殊情况是保持各个流在一个共享流中是逻辑分离的，等到到达共享流的出口时又重新分流，这就是多路复用和多路分解：</p><p><img src="/assets/img/multiplexingAndDemultiplexing.png" alt="Multiplexing and Demultiplexing"></p><h4 id="Building-a-remote-logger-创建一个远程日志记录器"><a href="#Building-a-remote-logger-创建一个远程日志记录器" class="headerlink" title="Building a remote logger(创建一个远程日志记录器)"></a>Building a remote logger(创建一个远程日志记录器)</h4><p>假设我们需要将一个程序的标准输出和标准错误都重定向到一个远程服务器，服务器接收后存为两个文件，共享通道是 <code>TCP</code> 连接，需要多路复用的两个渠道是 <code>stdout</code> 和 <code>stderr</code>，我们利用一个叫做 <strong>分组交换</strong> 的技术将数据打包进包中，协议大概是这样，数据被封装成具有以下结构的数据包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 byte Channel ID | 4 bytes Data length | Data</span><br></pre></td></tr></table></figure><h6 id="客户端——多路复用"><a href="#客户端——多路复用" class="headerlink" title="客户端——多路复用"></a>客户端——多路复用</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplexChannels</span>(<span class="params">sources, destination</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalChannels = sources.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sources.length; i++) &#123;</span><br><span class="line">    sources[i]</span><br><span class="line">      .on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// [1]</span></span><br><span class="line">        <span class="keyword">let</span> chunk</span><br><span class="line">        <span class="keyword">while</span> ((chunk = <span class="keyword">this</span>.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> outBuff = <span class="keyword">new</span> Buffer(<span class="number">1</span> + <span class="number">4</span> + chunk.length) <span class="comment">// [2]</span></span><br><span class="line">          outBuff.writeUInt8(i, <span class="number">0</span>)</span><br><span class="line">          outBuff.writeUInt32BE(chunk.length, <span class="number">1</span>)</span><br><span class="line">          chunk.copy(outBuff, <span class="number">5</span>)</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'Sending packet to channel: '</span> + i)</span><br><span class="line">          destination.write(outBuff) <span class="comment">// [3]</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">//[4]</span></span><br><span class="line">        <span class="keyword">if</span> (--totalChannels === <span class="number">0</span>) &#123;</span><br><span class="line">          destination.end()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>multiplexChannels()</code> 方法接收多个源，监听每个源，使用 <code>non-flowing</code>(<code>paused</code>) 模式读取流数据，写入包结构（<code>Channel ID</code> 为流在源数组中的下标），然后都往远程流中写数据，完成多路复用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">const</span> socket = net.connect(</span><br><span class="line">  <span class="number">3000</span>,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">const</span> child = child_process.fork(</span><br><span class="line">      <span class="comment">// [2]</span></span><br><span class="line">      process.argv[<span class="number">2</span>],</span><br><span class="line">      process.argv.slice(<span class="number">3</span>),</span><br><span class="line">      &#123;</span><br><span class="line">        silent: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    multiplexChannels([child.stdout, child.stderr], socket) <span class="comment">// [3]</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="服务端——多路分解"><a href="#服务端——多路分解" class="headerlink" title="服务端——多路分解"></a>服务端——多路分解</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demultiplexChannel</span>(<span class="params">source, destinations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentChannel = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> currentLength = <span class="literal">null</span></span><br><span class="line">  source</span><br><span class="line">    .on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">//[1]</span></span><br><span class="line">      <span class="keyword">let</span> chunk</span><br><span class="line">      <span class="keyword">if</span> (currentChannel === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//[2]</span></span><br><span class="line">        chunk = source.read(<span class="number">1</span>)</span><br><span class="line">        currentChannel = chunk &amp;&amp; chunk.readUInt8(<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currentLength === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//[3]</span></span><br><span class="line">        chunk = source.read(<span class="number">4</span>)</span><br><span class="line">        currentLength = chunk &amp;&amp; chunk.readUInt32BE(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (currentLength === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      chunk = source.read(currentLength) <span class="comment">//[4]</span></span><br><span class="line">      <span class="keyword">if</span> (chunk === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Received packet from: '</span> + currentChannel)</span><br><span class="line"></span><br><span class="line">      destinations[currentChannel].write(chunk) <span class="comment">//[5]</span></span><br><span class="line">      currentChannel = <span class="literal">null</span></span><br><span class="line">      currentLength = <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">//[6]</span></span><br><span class="line">      destinations.forEach(<span class="function"><span class="params">destination</span> =&gt;</span> destination.end())</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Source channel closed'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们开始使用 <code>non-flowing</code>(<code>paused</code>) 模式从流中读取数据。</li><li>首先，如果我们还没有读取 <code>Channel ID</code>，我们尝试从流中读取 1 个字节，然后将其转换为 <code>Channel ID</code>。</li><li>下一步是读取数据块的长度。我们需要读取 4 个字节，所以有可能在内部 <code>Buffer</code> 还没有足够的数据，这将导致 <code>this.read()</code> 调用返回 <code>null</code>。在这种情况下，我们只是中断解析，然后重试下一个 <code>readable</code> 事件。</li><li>当知道了数据长度后，就知道要从内部 <code>Buffer</code> 中拉出多少数据了，所以我们尝试读取所有数据。</li><li>当我们读取所有的数据时，我们可以把它写到正确的目标通道，一定要记得重置 <code>currentChannel</code> 和 <code>currentLength</code> 变量（这些变量将被用来解析下一个数据包）。</li><li>最后，当所有的源流结束时，一定不要忘记调用所有目标流的 <code>end()</code> 方法来结束目标流。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端代码</span></span><br><span class="line">net</span><br><span class="line">  .createServer(<span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> stdoutStream = fs.createWriteStream(<span class="string">'stdout.log'</span>)</span><br><span class="line">    <span class="keyword">const</span> stderrStream = fs.createWriteStream(<span class="string">'stderr.log'</span>)</span><br><span class="line">    demultiplexChannel(socket, [stdoutStream, stderrStream])</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Server started'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Coding-with-Streams-使用流编程&quot;&gt;&lt;a href=&quot;#Coding-with-Streams-使用流编程&quot; class=&quot;headerlink&quot; title=&quot;Coding with Streams(使用流编程)&quot;&gt;&lt;/a&gt;Coding with Streams(使用流编程)&lt;/h1&gt;&lt;h2 id=&quot;Discovering-the-importance-of-streams-流的重要性&quot;&gt;&lt;a href=&quot;#Discovering-the-importance-of-streams-流的重要性&quot; class=&quot;headerlink&quot; title=&quot;Discovering the importance of streams(流的重要性)&quot;&gt;&lt;/a&gt;Discovering the importance of streams(流的重要性)&lt;/h2&gt;&lt;h3 id=&quot;Buffering-versus-streaming-缓存-vs-流&quot;&gt;&lt;a href=&quot;#Buffering-versus-streaming-缓存-vs-流&quot; class=&quot;headerlink&quot; title=&quot;Buffering versus streaming(缓存 vs 流)&quot;&gt;&lt;/a&gt;Buffering versus streaming(缓存 vs 流)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Buffering&lt;/code&gt;:等到所有数据都收集完了才发送给消费者。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Streaming&lt;/code&gt;:实时发送数据到消费者。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第四章</title>
    <link href="http://1016990109.github.io/2018/06/23/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/06/23/Node-js-设计模式读书笔记-第四章/</id>
    <published>2018-06-23T02:05:34.000Z</published>
    <updated>2018-07-05T03:06:42.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Asynchronous-Control-Flow-Patterns-with-ES2015-and-Beyond-使用-ES2015-以上异步控制流模式"><a href="#Asynchronous-Control-Flow-Patterns-with-ES2015-and-Beyond-使用-ES2015-以上异步控制流模式" class="headerlink" title="Asynchronous Control Flow Patterns with ES2015 and Beyond(使用 ES2015 以上异步控制流模式)"></a>Asynchronous Control Flow Patterns with ES2015 and Beyond(使用 ES2015 以上异步控制流模式)</h1><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><code>Promise</code> 是一种抽象的对象，我们通常允许函数返回一个名为 <code>Promise</code> 的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说 <code>Promise</code> 对象处于 <code>pending</code> 状态，当操作成功完成时，我们说 <code>Promise</code> 对象处于 <code>fulfilled</code> 状态，当操作错误终止时，我们说 <code>Promise</code> 对象处于 <code>rejected</code> 状态。一旦 <code>Promise</code> 处于 <code>fulfilled</code> 或 <code>rejected</code>，我们认为当前异步操作结束。</p><a id="more"></a><p>接收异步操作的结果（<code>settled</code>）使用 <code>then</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then([onFulfilled], [onRejected])</span><br></pre></td></tr></table></figure><p>使用 <code>then</code> 后就不必像 <code>CPS</code> 风格代码那样多重嵌套了，而是像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asyncOperation(arg).then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 正常结果处理</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>then</code> 方法同步返回另一个 <code>Promise</code>，<code>onFulfilled</code> 或 <code>onRejected</code> 返回的 <code>x</code> 不同时 <code>then</code> 方法返回的 <code>Promise</code> 也会不同：</p><ul><li>如果 <code>x</code> 是一个值，则这个 <code>Promise</code> 对象会正确处理 <code>resolve(x)</code></li><li>如果 <code>x</code> 是一个 <code>Promise</code> 对象或 <code>thenable</code>，则会正确处理 <code>x</code> 的处理后的结果 <code>resolve(x_fulfilled)</code></li><li>如果 x 是一个异常，则会捕获异常 <code>reject(x)</code></li></ul><p><code>Promise</code> 始终是异步的，就算直接同步地 <code>resolve</code> 也是一样，这能很好地避免 <a href="https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md" target="_blank" rel="noopener"><code>Zalgo</code></a>。</p><p>处理过程中抛出异常那么 <code>then</code> 返回的 <code>Promise</code> 会自动 <code>reject</code>，这个异常被作为 <code>reject</code> 的原因。</p><p><a href="https://promisesaplus.com" target="_blank" rel="noopener"><code>Promises/A+</code></a> 规范描述了 <code>then</code> 方法的行为，使得不同库的 <code>Promise</code> 能够兼容。</p><h3 id="Promise-A-implementations-Promise-A-规范实现"><a href="#Promise-A-implementations-Promise-A-规范实现" class="headerlink" title="Promise/A+ implementations(Promise/A+ 规范实现)"></a>Promise/A+ implementations(Promise/A+ 规范实现)</h3><p>有很多实现了 <code>Promise/A+</code> 规范的库，但是目前基本上都用 <code>ES2015</code> 的 <code>Promise</code> 了，这个 <code>Promise</code> 是没有在标准上新加其他功能的。</p><p><code>API</code> 可查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">官方文档</a></p><h3 id="Promisifying-a-Node-js-style-function-使一个函数-Promise-化"><a href="#Promisifying-a-Node-js-style-function-使一个函数-Promise-化" class="headerlink" title="Promisifying a Node.js style function(使一个函数 Promise 化)"></a>Promisifying a Node.js style function(使一个函数 Promise 化)</h3><p>并不是所有的异步函数和库都支持 <code>promise</code>，有的时候得将一个基于回调的函数转换为返回 <code>Promise</code> 的函数，这个过程被称为 <code>Promise化</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.promisify = <span class="function"><span class="keyword">function</span>(<span class="params">callbackBasedApi</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">promisified</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      args.push(<span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve([].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      callbackBasedApi.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数能把本来是基于 <code>callback</code> 的异步回调函数改为 <code>Promise</code> 风格的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">'./promisify'</span>).promisify</span><br><span class="line"><span class="keyword">let</span> newCallbackBaseApi = promisify(<span class="function">(<span class="params">input, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> callback(<span class="literal">null</span>, input + <span class="number">1</span>), <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">newCallbackBaseApi(<span class="number">999</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><h3 id="Sequential-execution-顺序执行"><a href="#Sequential-execution-顺序执行" class="headerlink" title="Sequential execution(顺序执行)"></a>Sequential execution(顺序执行)</h3><h4 id="Sequential-iteration-顺序迭代"><a href="#Sequential-iteration-顺序迭代" class="headerlink" title="Sequential iteration(顺序迭代)"></a>Sequential iteration(顺序迭代)</h4><p>更改上一章爬虫程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, body, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = utilities.getPageLinks(currentUrl, body)</span><br><span class="line">  links.forEach(<span class="function"><span class="params">link</span> =&gt;</span> &#123;</span><br><span class="line">    promise = promise.then(<span class="function"><span class="params">()</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个 <code>resolve</code> 了 <code>undefined</code> 的 <code>Promise</code>，再将需要顺序执行的异步函数一个个按顺序填入 <code>then</code> 即完成了。等到最后一个 <code>then</code> 函数 <code>resolve</code> 了结果后整个顺序任务也就全部完成了。</p><h4 id="Sequential-iteration-the-pattern-顺序迭代模式"><a href="#Sequential-iteration-the-pattern-顺序迭代模式" class="headerlink" title="Sequential iteration - the pattern(顺序迭代模式)"></a>Sequential iteration - the pattern(顺序迭代模式)</h4><p>写一个通用的顺序处理任务模型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> promise = tasks.reduce(<span class="function">(<span class="params">prev, task</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prev.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> task()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="built_in">Promise</span>.resolve())</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//All tasks completed</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过这种模式，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个 <code>mapping</code> 算法，或者构建一个 <code>filter</code> 等等。</p><h3 id="Parallel-execution-并行执行"><a href="#Parallel-execution-并行执行" class="headerlink" title="Parallel execution(并行执行)"></a>Parallel execution(并行执行)</h3><p><code>Promise.all()</code> 并行执行多个异步任务。</p><h3 id="Limited-parallel-execution-限制并行执行任务数"><a href="#Limited-parallel-execution-限制并行执行任务数" class="headerlink" title="Limited parallel execution(限制并行执行任务数)"></a>Limited parallel execution(限制并行执行任务数)</h3><p>限制并行任务数可以简单地实现一个 <code>TaskQueue</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(concurrency) &#123;</span><br><span class="line">    <span class="keyword">this</span>.concurrency = concurrency</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pushTask(task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(task)</span><br><span class="line">    <span class="keyword">this</span>.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.running &lt; <span class="keyword">this</span>.concurrency &amp;&amp; <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> task = <span class="keyword">this</span>.queue.shift()</span><br><span class="line">      task().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.running--</span><br><span class="line">        <span class="keyword">this</span>.next()</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.running++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要将任务放到队列里就行了，然后开始 <code>next()</code>。</p><h3 id="Exposing-callbacks-and-promises-in-public-APIs-在公共-API-中暴露回调函数和-Promise"><a href="#Exposing-callbacks-and-promises-in-public-APIs-在公共-API-中暴露回调函数和-Promise" class="headerlink" title="Exposing callbacks and promises in public APIs(在公共 API 中暴露回调函数和 Promise)"></a>Exposing callbacks and promises in public APIs(在公共 API 中暴露回调函数和 Promise)</h3><p><code>Promise</code> 固然有它的优点——易于理解和容易处理结果（<code>resolve</code>或<code>reject</code>），但是这要求开发者理解其中的原理，所以有些时候开发者更愿意使用回调函数模式。</p><p>像 <code>request</code> <code>redis</code> <code>mysql</code> 就使用回调函数的方式提供 <code>API</code>，<code>mongoose</code> <code>sequelize</code> 既支持回调函数的方式，又支持 <code>Promise</code> 的方式（不传回调函数时返回一个 <code>Promise</code>）。</p><p>最好是同时提供两种方式，这样方便开发者选择自己熟悉或者需要的方式，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">asyncDivision</span>(<span class="params">dividend, divisor, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// [1]</span></span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = dividend / divisor</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isNaN</span>(result) || !<span class="built_in">Number</span>.isFinite(result)) &#123;</span><br><span class="line">        <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid operands'</span>)</span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">          cb(error) <span class="comment">// [2]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, result) <span class="comment">// [3]</span></span><br><span class="line">      &#125;</span><br><span class="line">      resolve(result)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数的方式</span></span><br><span class="line">asyncDivision(<span class="number">10</span>, <span class="number">2</span>, (error, result) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(error)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise化的调用方式</span></span><br><span class="line">asyncDivision(<span class="number">22</span>, <span class="number">11</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error))</span><br></pre></td></tr></table></figure><p>可以发现这种异步函数是默认返回一个 <code>Promise</code> 的，但是在异步处理完操作会判断回调函数是否已经传入，传入时会调用 <code>cb(null, result)</code> 或 <code>cb(error)</code>，然后始终都执行 <code>Promise</code> 需要的 <code>resolve</code> 或 <code>reject</code>。</p><h2 id="Generator-生成器"><a href="#Generator-生成器" class="headerlink" title="Generator(生成器)"></a>Generator(生成器)</h2><h3 id="The-basics-of-generators-生成器基础"><a href="#The-basics-of-generators-生成器基础" class="headerlink" title="The basics of generators(生成器基础)"></a>The basics of generators(生成器基础)</h3><p>在 <code>function</code> 后面加上 <code>*</code> 就是声明生成器函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>makeGenerator()</code> 函数内部，使用关键字 <code>yield</code> 暂停执行并返回给调用者值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Hello World'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Re-entered'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makeGenerator()</code> 函数本质上是一个工厂，它在被调用时返回一个新的 <code>Generator</code> 对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = makeGenerator()</span><br></pre></td></tr></table></figure><p><code>next()</code> 函数用于启动/恢复 <code>Generator</code> 函数，并返回如下格式对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: &lt;yielded value&gt;</span><br><span class="line">  done: &lt;true if the execution reached the end&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Generators-as-iterators-生成器函数作为迭代器"><a href="#Generators-as-iterators-生成器函数作为迭代器" class="headerlink" title="Generators as iterators(生成器函数作为迭代器)"></a>Generators as iterators(生成器函数作为迭代器)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iteratorGenerator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> arr[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = iteratorGenerator([<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'watermelon'</span>])</span><br><span class="line"><span class="keyword">let</span> currentItem = iterator.next()</span><br><span class="line"><span class="keyword">while</span> (!currentItem.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(currentItem.value)</span><br><span class="line">  currentItem = iterator.next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">orange</span><br><span class="line">watermelon</span><br></pre></td></tr></table></figure><p>每次 <code>yield</code> 会暂停生成器函数并返回一个值，<code>next</code> 会恢复生成器函数的执行，恢复的时候的状态与暂停时候的状态一致。</p><h4 id="Passing-values-back-to-a-generator-传值给生成器函数"><a href="#Passing-values-back-to-a-generator-传值给生成器函数" class="headerlink" title="Passing values back to a generator(传值给生成器函数)"></a>Passing values back to a generator(传值给生成器函数)</h4><p>想要传递值给 <code>Generator</code> 只需要添加 <code>next</code> 的参数就行了，传递的值会赋予给 <code>yield</code> 的返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">twoWayGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> what = <span class="keyword">yield</span> <span class="literal">null</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + what)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> twoWay = twoWayGenerator()</span><br><span class="line">twoWay.next()</span><br><span class="line">twoWay.next(<span class="string">'world'</span>)</span><br></pre></td></tr></table></figure><p>第一个 <code>next</code> 启动 <code>Generator</code>，接着 <code>yield</code> 暂定函数执行，再然后 <code>next(&#39;world&#39;)</code> 恢复函数执行并传递值 <code>world</code> 给 <code>Generator</code>，<code>yield</code> 收到该参数作为返回值返回（<code>what</code> 的值为 world）。</p><blockquote><p>注意也可以返回一个异常，<code>next(new Error())</code>，这个错误就像是在生成器中抛出的一样，可以使用 <code>try...catch</code> 捕获。</p></blockquote><h3 id="Asynchoronous-control-flow-with-generators-使用生成器做异步控制流"><a href="#Asynchoronous-control-flow-with-generators-使用生成器做异步控制流" class="headerlink" title="Asynchoronous control flow with generators(使用生成器做异步控制流)"></a>Asynchoronous control flow with generators(使用生成器做异步控制流)</h3><p>直接看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFlow</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> generator.throw(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> results = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    generator.next(results.length &gt; <span class="number">1</span> ? results : results[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> generator = generatorFunction(callback)</span><br><span class="line">  generator.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">asyncFlow(<span class="function"><span class="keyword">function</span>*(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fileName = path.basename(__filename)</span><br><span class="line">  <span class="keyword">const</span> myself = <span class="keyword">yield</span> fs.readFile(fileName, <span class="string">'utf8'</span>, callback)</span><br><span class="line">  <span class="keyword">yield</span> fs.writeFile(<span class="string">`clone_of_<span class="subst">$&#123;filename&#125;</span>`</span>, myself, callback)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Clone created'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>asyncFlow</code> 接收一个 <code>Generator</code> 函数，这个生成器函数里可以做一些异步的操作，异步操作完成时会调用 <code>asyncFlow</code> 中的 <code>callback</code> 将结果返回或者将错误抛出，不管如何都会被 <code>Generator</code> 函数中获取到（<code>yield</code> 返回值或者 <code>try...catch</code> 捕获异常，上面例子是获取返回值），<code>myself</code> 能拿到 <code>readFile</code> 的结果。</p><p>可以发现使用异步控制流后，可以像同步代码方式那样书写异步代码了，它的原理就是每个异步函数操作完后会恢复 <code>Generator</code> 函数的运行并返回处理的结果值给暂停的地方。</p><blockquote><p>上述异步控制流还有两种变体，一种使用 <code>Promise</code>，另一种使用 <code>thunks</code>。<code>thunk</code> 指的是一个函数，接收原函数中除了回调函数以外的参数，返回一个只接收回调函数的函数，如 <code>fs.readFile()</code>:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileThunk</span>(<span class="params">filename, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, options, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种变种允许我们创建没有回调函数作为参数的 <code>Generator</code>，就像下面(<code>thunk</code>)这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFlowWithThunks</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> generator.throw(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> results = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> thunk = generator.next(results.length &gt; <span class="number">1</span> ? results : results[<span class="number">0</span>])</span><br><span class="line">      .value</span><br><span class="line">    thunk &amp;&amp; thunk(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> generator = generatorFunction()</span><br><span class="line">  <span class="keyword">const</span> thunk = generator.next().value</span><br><span class="line">  thunk &amp;&amp; thunk(callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFlowWithThunks(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fileName = path.basename(__filename)</span><br><span class="line">  <span class="keyword">const</span> myself = <span class="keyword">yield</span> readFileThunk(__filename, <span class="string">'utf8'</span>)</span><br><span class="line">  <span class="keyword">yield</span> writeFileThunk(<span class="string">`clone_of_<span class="subst">$&#123;fileName&#125;</span>`</span>, myself)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Clone created'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从 <code>generator.next().value</code> 取到 <code>thunk</code> 的返回函数，再将回调函数传入，这样 <code>Generator</code> 函数就不用接收回调函数作为参数了。更详细有关 <code>thunk</code> 的介绍可以移步 <code>Github</code> 的 <a href="https://github.com/thunks/thunks" target="_blank" rel="noopener">thunks</a>。</p><p><code>Promise</code> 也是类似的，使用上面有提到的 <code>promisify</code> 将异步函数转为 <code>Promise</code> 形式，然后类似处理（这里是我自己实现的一个版本）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFlowWithPromise</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">processPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    promise</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">          promise = generator.next(res.length &gt; <span class="number">1</span> ? res : res[<span class="number">0</span>]).value</span><br><span class="line">          promise &amp;&amp; processPromise()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> generator.throw(err))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> generator = generatorFunction()</span><br><span class="line">  <span class="keyword">let</span> promise = generator.next().value</span><br><span class="line">  promise &amp;&amp; processPromise()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFlowWithPromise(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// readFilePromise() 生成一个Promise，使用promisify转换而来</span></span><br><span class="line">  <span class="keyword">const</span> fileName = path.basename(__filename)</span><br><span class="line">  <span class="keyword">const</span> myself = <span class="keyword">yield</span> readFilePromise(__filename, <span class="string">'utf8'</span>)</span><br><span class="line">  <span class="keyword">yield</span> writeFilePromise(<span class="string">`clone_of_<span class="subst">$&#123;fileName&#125;</span>`</span>, myself)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Clone created'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Generator-based-control-flow-using-co-使用-co-的基于-Generator-的控制流"><a href="#Generator-based-control-flow-using-co-使用-co-的基于-Generator-的控制流" class="headerlink" title="Generator-based control flow using co(使用 co 的基于 Generator 的控制流)"></a>Generator-based control flow using co(使用 co 的基于 Generator 的控制流)</h4><p><code>co</code> 已经包含了以上两种形式的异步控制流了，可以支持 5 种 <code>yieldable</code> 的类型：</p><ul><li>Promises</li><li>Thunks (functions)</li><li>array (parallel execution)</li><li>objects (parallel execution)</li><li>Generators and GeneratorFunctions</li></ul><p><code>co</code> 源码的理解可以查看<a href="https://i5ting.github.io/wechat-dev-with-nodejs/async/co.html" target="_blank" rel="noopener">这里</a></p><h4 id="Sequential-execution-顺序执行-1"><a href="#Sequential-execution-顺序执行-1" class="headerlink" title="Sequential execution(顺序执行)"></a>Sequential execution(顺序执行)</h4><p>使用 <code>co</code> 库可以很简单地实现任务的顺序执行，我们更改爬虫程序为下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thunkify 可以将接收回调函数的异步函数变为 thunk，使用 promisify 也是一样的，代码不需要变动</span></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>)</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</span><br><span class="line"><span class="keyword">const</span> request = thunkify(<span class="built_in">require</span>(<span class="string">'request'</span>))</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> mkdirp = thunkify(<span class="built_in">require</span>(<span class="string">'mkdirp'</span>))</span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile)</span><br><span class="line"><span class="keyword">const</span> writeFile = thunkify(fs.writeFile)</span><br><span class="line"><span class="keyword">const</span> nextTick = thunkify(process.nextTick)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">download</span>(<span class="params">url, filename</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloading <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">yield</span> request(url);</span><br><span class="line">  <span class="keyword">const</span> body = response[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">yield</span> mkdirp(path.dirname(filename));</span><br><span class="line">  <span class="keyword">yield</span> writeFile(filename, body);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloaded and saved <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">spider</span>(<span class="params">url, nesting</span>) </span>&#123;</span><br><span class="line">  cost filename = utilities.urlToFilename(url);</span><br><span class="line">  <span class="keyword">let</span> body;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    body = <span class="keyword">yield</span> readFile(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code !== <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    body = <span class="keyword">yield</span> download(url, filename);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> spiderLinks(url, body, nesting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">spiderLinks</span>(<span class="params">currentUrl, body, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextTick();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = utilities.getPageLinks(currentUrl, body);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; links.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> spider(links[i], nesting - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有开始的入口需要调用 co，因为 co 是可以递归处理 yieldable 的数据，Generators 也是 yieldable 的</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> spider(process.argv[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Download complete`</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Parallel-execution-并行执行-1"><a href="#Parallel-execution-并行执行-1" class="headerlink" title="Parallel execution(并行执行)"></a>Parallel execution(并行执行)</h4><p>并行执行就很简单了，将需要并行的任务包装成一个数组就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">spiderLinks</span>(<span class="params">currentUrl, body, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextTick()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = utilities.getPageLinks(currentUrl, body)</span><br><span class="line">  <span class="keyword">const</span> tasks = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">yield</span> tasks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用基于回调函数的方式实现并行执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, body, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextTick()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个thunk</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> completed = <span class="number">0</span>,</span><br><span class="line">      hasErrors = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> links = utilities.getPageLinks(currentUrl, body)</span><br><span class="line">    <span class="keyword">if</span> (links.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> process.nextTick(callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err &amp;&amp; !hasErrors) &#123;</span><br><span class="line">        hasErrors = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> callback(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (++completed === links.length &amp;&amp; !hasErrors) &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; links.length; i++) &#123;</span><br><span class="line">      co(spider(links[i], nesting - <span class="number">1</span>)).then(done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>spiderLinks</code> 改为上面这种代码后就不再是 <code>Generator</code> 函数了，它返回的是一个 <code>thunk</code>，这样有利于支持其他的基于回调函数或者 <code>Promise</code> 的控制流算法。</p><h4 id="Limited-parallel-execution-限制并行执行"><a href="#Limited-parallel-execution-限制并行执行" class="headerlink" title="Limited parallel execution(限制并行执行)"></a>Limited parallel execution(限制并行执行)</h4><p>这里有几种凡是可以限制并行的任务数：</p><ul><li><code>TaskQueue</code>(基于 <code>Promise</code> 或者 <code>callback</code>)</li><li>使用库，<code>async</code> 或者 <code>co-limiter</code></li><li>自己实现算法（生产者-消费者）</li></ul><p>这里主要看看第三种，直接看修改后的 <code>TaskQueue</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(concurrency) &#123;</span><br><span class="line">    <span class="keyword">this</span>.concurrency = concurrency</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.taskQueue = []</span><br><span class="line">    <span class="keyword">this</span>.consumerQueue = []</span><br><span class="line">    <span class="keyword">this</span>.spawnWorkers(concurrency)</span><br><span class="line">  &#125;</span><br><span class="line">  pushTask(task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.consumerQueue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.consumerQueue.shift()(<span class="literal">null</span>, task)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.taskQueue.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  spawnWorkers(concurrency) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; concurrency; i++) &#123;</span><br><span class="line">      co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> task = <span class="keyword">yield</span> self.nextTask()</span><br><span class="line">          <span class="keyword">yield</span> task</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nextTask() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.taskQueue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, <span class="keyword">this</span>.taskQueue.shift())</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.consumerQueue.push(callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解上述代码最好是自己手动去跑一边，一步步 <code>debug</code>，看到是如何进行的。</p><ol><li>第一步初始化 <code>TaskQueue</code>，传入最大并行任务数（假设为 <code>n</code>），这个时候会创建 <code>n</code> 个消费者，也就是通过 <code>nextTask</code> 创建的 <code>callback</code>(在 <code>co</code> 中的 <code>thunkToPromise</code> 中创建的) 函数，<code>nextTask</code> 返回一个 <code>thunk</code> 函数，在 <code>while</code> 循环中 <code>yield self.nextTask()</code> 来执行 <code>thunk</code> 的函数体，这个时候任务队列 <code>taskQueue</code> 还是空的，所以这个消费者会被暂时挂起（被 <code>push</code> 到消费者队列 <code>consumerQueue</code>中），之后该 <code>TaskQueue</code> 等待新任务的到来。</li><li>生产者生产任务，也就是通过 <code>pushTask</code> 生产任务，这个时候判断是否有空闲的消费者，从消费者队列中取出 <code>callback</code>(<code>yield self.nextTask()</code> 时 <code>push</code> 进去的)，执行这个 <code>callback</code> 传入异步任务作为参数。</li><li>收到异步任务后，立即 <code>resolve</code> 掉，接着恢复 <code>Generator</code> 函数的执行，继续执行时 <code>task</code> 能拿到 <code>next(ret)</code> 的参数也就是这个异步任务，接着继续执行这个 <code>task</code>，这个任务结束后又会回到 <code>while</code> 循环取下一个任务执行，以此类推。</li><li>没有多余的消费者时会暂时将任务存到任务队列，等待消费者被释放。</li></ol><h3 id="Async-await-using-Babel-利用-Babel-使用-async-和-await"><a href="#Async-await-using-Babel-利用-Babel-使用-async-和-await" class="headerlink" title="Async await using Babel(利用 Babel 使用 async 和 await)"></a>Async await using Babel(利用 Babel 使用 async 和 await)</h3><p>我们发现，要理解上面那种 <code>Generator</code> 式的代码实在太难了，还好 <code>ES7</code> 规范发布了新的关键字 <code>async</code> 和 <code>await</code>，先来看看这两个关键字是怎么提高代码可读性的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageHtml</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    request(url, <span class="function"><span class="keyword">function</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">      resolve(body)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> html = <span class="keyword">await</span> getPageHtml(<span class="string">'http://google.com'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(html)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Loading...'</span>)</span><br></pre></td></tr></table></figure><p><code>getPageHtml</code> 返回一个 <code>Promise</code>，<code>async</code> 关键字修饰函数表明这个函数是处理异步操作的，并且可以使用 <code>await</code> 关键字了，<code>await</code> 关键字告诉 <code>JavaScript</code> 解释器在执行下面的语句之前要等待 <code>getPageHtml</code> 返回的 <code>Promise</code> 的结果。程序中只有 <code>main</code> 那段代码是异步，其他的还是同步的，所以是先看到 <code>Loading</code> 字样再看到网页的内容的。</p><h4 id="Installing-and-running-Babel-安装并运行-Babel"><a href="#Installing-and-running-Babel-安装并运行-Babel" class="headerlink" title="Installing and running Babel(安装并运行 Babel)"></a>Installing and running Babel(安装并运行 Babel)</h4><p><code>Babel</code> 是一个 <code>JavaScript</code> 编译器(或翻译器)，能够使用语法转换器将高版本的 <code>JavaScript</code> 代码转换成其他 <code>JavaScript</code> 代码。语法转换器允许例如我们书写并使用 <code>ES2015</code>，<code>ES2016</code>，<code>JSX</code> 和其它的新语法，来翻译成往后兼容的代码，在 <code>JavaScript</code> 运行环境如浏览器或 <code>Node.js</code> 中都可以使用 <code>Babel</code>。</p><p>详细的安装与运行参考<a href="https://babeljs.io/docs/en/index.html" target="_blank" rel="noopener">官方文档</a>。</p><p><code>ES7</code> 的语法可以使用 <a href="https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator" target="_blank" rel="noopener">babel-plugin-transform-async-to-generator</a>。</p><h3 id="Comparison-比较"><a href="#Comparison-比较" class="headerlink" title="Comparison(比较)"></a>Comparison(比较)</h3><p>这里是几种处理 <code>JavaScript</code> 异步的方式的比较：</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>原生 js</td><td>不需要额外的库 <br> 性能最高 <br> 兼容性好 <br> 允许简单或更复杂算法的创建</td><td>可能需要更多的代码和相对复杂的算法</td></tr><tr><td>Async 库</td><td>简化常见的控制流模式 <br> 基于 callback 的方式 <br> 较好的性能</td><td>需要额外的库 <br> 不适用于更高级的流控制</td></tr><tr><td>Promises</td><td>简化常见的控制流模式 <br> 鲁棒的 error 处理 <br> ES6 规范一部分 <br>确保 onFulfilled 和 onRejected 延迟调用</td><td>需要将基于 callback 的函数 promisify <br> 带来了较小的性能上的损失</td></tr><tr><td>Generators</td><td>使得非阻塞 API 用起来和阻塞 API 一样 <br> 简化错误处理 <br> ES6 的特征</td><td>需要辅助的流控制库 <br> 需要 callback 或 promise 来实现非顺序流 <br>需要 thunkify 或 promisify 不是基于 generator 的 API</td></tr><tr><td>Async await</td><td>使得非阻塞 API 用起来和阻塞 API 一样 <br> 简单直观的语法</td><td>需要 Babel （为了兼容浏览器，Promise 和 Generators 也要用 Babel）</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实我个人建议是使用 <code>async await</code> 的方式的，这种方式使得代码看起来十分清爽，比原生 <code>js</code> 要好太多了，而其他的几种太过繁琐，这几种为了兼容浏览器也不得不使用 <code>Babel</code>、<code>polyfill</code>，所以 <code>asycn await</code> 的缺点也就不那么明显了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Asynchronous-Control-Flow-Patterns-with-ES2015-and-Beyond-使用-ES2015-以上异步控制流模式&quot;&gt;&lt;a href=&quot;#Asynchronous-Control-Flow-Patterns-with-ES2015-and-Beyond-使用-ES2015-以上异步控制流模式&quot; class=&quot;headerlink&quot; title=&quot;Asynchronous Control Flow Patterns with ES2015 and Beyond(使用 ES2015 以上异步控制流模式)&quot;&gt;&lt;/a&gt;Asynchronous Control Flow Patterns with ES2015 and Beyond(使用 ES2015 以上异步控制流模式)&lt;/h1&gt;&lt;h2 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt; 是一种抽象的对象，我们通常允许函数返回一个名为 &lt;code&gt;Promise&lt;/code&gt; 的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说 &lt;code&gt;Promise&lt;/code&gt; 对象处于 &lt;code&gt;pending&lt;/code&gt; 状态，当操作成功完成时，我们说 &lt;code&gt;Promise&lt;/code&gt; 对象处于 &lt;code&gt;fulfilled&lt;/code&gt; 状态，当操作错误终止时，我们说 &lt;code&gt;Promise&lt;/code&gt; 对象处于 &lt;code&gt;rejected&lt;/code&gt; 状态。一旦 &lt;code&gt;Promise&lt;/code&gt; 处于 &lt;code&gt;fulfilled&lt;/code&gt; 或 &lt;code&gt;rejected&lt;/code&gt;，我们认为当前异步操作结束。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kryo vs avro vs protobuf vs thrift vs jce</title>
    <link href="http://1016990109.github.io/2018/06/20/kryo-vs-avro-vs-protobuf-vs-thrift-vs-jce/"/>
    <id>http://1016990109.github.io/2018/06/20/kryo-vs-avro-vs-protobuf-vs-thrift-vs-jce/</id>
    <published>2018-06-20T08:16:03.000Z</published>
    <updated>2018-06-22T08:56:16.497Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道结构化数据存储方式多种多样，有 <code>json</code>、<code>xml</code>、<code>kryo</code>等等，而 <code>json</code> 与 <code>xml</code> 虽然可读性较强，但是需要的额外空间太多，当数据量过大的时候很浪费性能，所以就需要压缩率更高的编码方式，这里对比比较流行的几种存储（编码）方式：<code>kryo</code>、<code>avro</code>、<code>protobuf</code>、<code>thrift</code>、<code>jce</code>：</p><a id="more"></a><h2 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h2><h3 id="结构化数据："><a href="#结构化数据：" class="headerlink" title="结构化数据："></a>结构化数据：</h3><p>需要预定义结构体（<code>.proto</code> 文件），消息经过序列化后会成为一个二进制数据流，该流中的数据为一系列的 <code>Key-Value</code> 对，定义好结构体的优势就是不用多余的数据来分隔不同的键值对。<code>Key</code> 用来标识具体的 <code>field</code>，在解包的时候，<code>Protocol Buffer</code> 根据 <code>Key</code> 就可以知道相应的 <code>Value</code> 应该对应于消息中的哪一个 <code>field</code>。</p><p><code>Key</code> 定义：(field_number &lt;&lt; 3) | wire_type</p><p><code>field_number</code> 代表在 <code>.proto</code> 中定义的编号，1~15 用一个字节，16~2047 用两个字节，结合公式 （field_number &lt;&lt; 3）| wire_type ，如果 <code>filed_number</code> 大于等于 16，两个字节共 16 位，去掉移位的 3 位，去掉两个字节中第一个比特位(<code>msb</code>)，总共 16 个比特位只有 16-5=11 个比特位用来表示 <code>Key</code>，所以 <code>Key</code> 的 <code>filed_number</code> 要小于 2^11== 2048。</p><p>更大的以此类推，主要就是看一个字节的 <code>msb</code> 是否为 1，最大可以为 2^29 - 1。</p><p><code>wire_type</code> 表示该数据的类型，有 <code>Vaint</code>、<code>64-bit</code>、<code>Length-delimi</code>、<code>Start group</code>、<code>End group</code>、<code>32-bit</code>共 6 中类型，具体可查看<a href="https://developers.google.com/protocol-buffers/docs/encoding#order" target="_blank" rel="noopener">官方文档</a></p><h3 id="Varint"><a href="#Varint" class="headerlink" title="Varint"></a>Varint</h3><p>了解 <code>protobuf</code> 首先就要了解 <code>Varint</code>，是它的一大核心，变长整数存储。长整数存储多的位数，短整数存储少的位数，来减少空间的浪费。除了最后一字节外每字节第一位都是 <code>most significant big</code>(<strong>msb</strong>)，表示是否后面是否还有字节表示该整数。例如：</p><p><code>0000 0001</code> 就表示 1</p><p><code>1010 1100 0000 0010</code> 第一个字节第一位为 1 表示后面还有数据，直到字节第一位为 0（这里就是第二个字节 <code>0000 0010</code>），将字节顺序逆向，变为 <code>0000 0010 010 1100</code>：<code>100101100</code>(300)</p><h3 id="ZigZag"><a href="#ZigZag" class="headerlink" title="ZigZag"></a>ZigZag</h3><p>而有符号整数则使用 <code>ZigZag</code> 编码方式，用无符号的整数同时代表正负两种数：</p><table><thead><tr><th>Signed Original</th><th>Encoded As</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>-1</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>-2</td><td>3</td></tr><tr><td>2147483647</td><td>4294967294</td></tr><tr><td>-2147483648</td><td>4294967295</td></tr></tbody></table><p>这样就大大减少了占用的位数，算法使用：</p><p><code>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</code> sint32<br><code>(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</code> sint64</p><h2 id="float-double"><a href="#float-double" class="headerlink" title="float double"></a>float double</h2><p>不压缩，多少位就多少位存储。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><code>string</code> 则是在 <code>Value</code> 中多加了一个或多个字节表示长度（<code>msb</code>标识），剩下的内容才是真正的值。</p><h3 id="repeated"><a href="#repeated" class="headerlink" title="repeated"></a>repeated</h3><p>这里介绍压缩率更高的 <code>Packed Repeated Fields</code>。</p><p>在 <code>2.1.0</code> 版本以后，<code>protocol buffers</code> 引入了该种类型，其与 <code>repeated</code> 字段一样，只是在末尾声明了 <code>[packed=true]</code>。类似 <code>repeated</code> 字段却又不同。在 <code>proto3</code> 中 <code>Repeated</code> 字段默认就是以这种方式处理。</p><p>例如有如下 <code>message</code> 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Test4 &#123;  </span><br><span class="line">  repeated int32 d = 4 [packed=true];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个 <code>Test4</code> 字段，并且设置 <code>repeated</code> 字段 d 3 个值：3，270 和 86942，编码后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">22 // tag 0010 0010(field number 010 0 = 4, wire type 010 = 2)</span><br><span class="line"></span><br><span class="line">06 // payload size (设置的length = 6 bytes)</span><br><span class="line"></span><br><span class="line">03 // first element (varint 3)</span><br><span class="line"></span><br><span class="line">8E 02 // second element (varint 270)</span><br><span class="line"></span><br><span class="line">9E A7 05 // third element (varint 86942)</span><br></pre></td></tr></table></figure><p>形成了 Tag - Length - Value - Value - Value …… 对，增加了压缩率。</p><h2 id="jce"><a href="#jce" class="headerlink" title="jce"></a>jce</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>也需要定义结构体，头部+内容，与 <code>protobuf</code> 类似，<code>tag + type</code>(4+4) 形式，<code>tag</code> 类似 <code>filed_number</code> 也是超过 15 后继续下一字节，但是由于不是通过第一位标识后面是否有数据，故而之后后面再多一个字节，最大为 255。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag(4) type(4) [tag(8)]</span><br></pre></td></tr></table></figure><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><p>直接定义 4 种，而不是变长，int8,int16,int32,int64</p><h3 id="string-1"><a href="#string-1" class="headerlink" title="string"></a>string</h3><p>两种，string1 和 string4，分别表示 8 位代表字符串长度，4*8=32 位表示字符串长度，所以字符串长度最大 2^32 - 1。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>存放时分开存放，先存 size（大小），再根据大小存对应个数的 <code>key-value</code>，<code>key</code> 的 <code>tag</code> 为 0，<code>value</code> 的 <code>tag</code> 为 1。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>用不同的 <code>tag</code> 标识开头和结尾即可。<code>protobuf</code> 不需要，是根据定义的 <code>.proto</code> 来自动解析结构体的，类似于 <code>map</code>。</p><h2 id="avro"><a href="#avro" class="headerlink" title="avro"></a>avro</h2><p><code>avro</code> 支持两种编码，一种 <code>json</code> 一种 <code>binary</code>，<code>json</code> 一般用于 <code>Web</code> 应用等需要易读性高的场景，大多数情况下都是二进制编码的。</p><p>同其他高效序列化-反序列化库一样，也是需要定义一个数据结构，只不过是用 <code>json</code> 定义的，内容如下：</p><ul><li>type: 类型（基本的和复杂的）</li><li>name: 字段名称</li><li>其他的一些属性</li></ul><p>详情查看<a href="https://avro.apache.org/docs/1.8.2/spec.html" target="_blank" rel="noopener">官方文档</a></p><p>举个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"record"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"MyStruct"</span>,</span><br><span class="line">  <span class="attr">"fields"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"int"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"id"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"description"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>json</code> 等价于定义了一个类似于 <code>protobuf</code> 这样的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message MyStruct &#123;</span><br><span class="line">  uint32 id = 1,</span><br><span class="line">  string description =2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int-long"><a href="#int-long" class="headerlink" title="int, long"></a>int, long</h3><p>使用 <code>varlength zigzag</code>，同时使用变长和 <code>zigzag</code>，类似于 <code>protobuf</code>。</p><h3 id="string-array-map"><a href="#string-array-map" class="headerlink" title="string, array, map"></a>string, array, map</h3><p>也是先声明长度，接着才是真正的内容。</p><h2 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a>thrift</h2><h3 id="int-long-1"><a href="#int-long-1" class="headerlink" title="int, long"></a>int, long</h3><p>先进行 <code>zigzag</code>，再 <code>var int</code>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>与 <code>avro</code>、<code>protobuf</code>大同小异，具体可查看<a href="https://github.com/apache/thrift/blob/master/doc/specs/thrift-compact-protocol.md" target="_blank" rel="noopener">官方文档</a></p><p><code>map</code> 每个键值对都有 <code>key-type</code> 和 <code>value-type</code>。</p><h2 id="kryo"><a href="#kryo" class="headerlink" title="kryo"></a>kryo</h2><p><code>kryo</code> 是一种快速高效的 <code>Java</code> 对象图（<code>Object graph</code>）序列化框架，要实现跨语言是比较困难的。</p><h3 id="int-long-2"><a href="#int-long-2" class="headerlink" title="int, long"></a>int, long</h3><p>也使用 <code>varint</code> 变长存储，减少空间。</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>不像 <code>Java</code> 自带的序列化工具携带了很多信息，<code>kryo</code> 只携带了 <strong>标识+类名+字段</strong> 三部分，更加简单，而且还不用自定义结构体，省去了 <code>.proto</code> 类似文件编写的麻烦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以发现高效的序列化库都对 <code>int</code> 和 <code>long</code> 这类整型做了变长的压缩（<code>jce</code> 定义不同长度整型也是变长的一种），而对结构体的存储基本上也是存储 <strong>键值对</strong> ，每一个键值对再标记值的类型，这样能大大压缩数据的空间，提高传输的效率。</p><p>需要预先定义数据格式的有：<code>protobuf</code>、<code>jce</code>、<code>avro</code>、<code>thrift</code>。</p><p>不需要预先定义数据格式的有：<code>kryo</code>。</p><p>跨语言：<code>protobuf</code>、<code>jce</code>、<code>avro</code>、<code>thrift</code>。</p><p>性能上<code>protobuf</code>、<code>jce</code>、<code>avro</code>、<code>thrift</code> 几者差别不大，<code>kryo</code> 序列化和反序列化较慢（但是不用预先定义数据格式，可省去麻烦），但是 <code>kryo</code> 的编码后的大小略微小一点。</p><h3 id="Google-protobuf"><a href="#Google-protobuf" class="headerlink" title="Google protobuf"></a>Google protobuf</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>二进制消息，性能好/效率高（空间和时间效率都很不错）</li><li><code>proto</code> 文件生成目标代码，简单易用</li><li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(<code>XML</code>,<code>JSON</code>都是这种方式)</li><li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li><li>支持多种语言（可以把 <code>proto</code> 文件看做 <code>IDL</code> 文件）</li><li><code>Netty</code> 等一些框架集成</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>官方只支持 <code>C++</code>,<code>JAVA</code> 和 <code>Python</code> 语言绑定</li><li>二进制可读性差（貌似提供了 <code>Text_Fromat</code> 功能）</li><li>二进制不具有自描述特性</li><li>默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li><li>只涉及序列化和反序列化技术，不涉及 <code>RPC</code> 功能（类似 <code>XML</code> 或者 <code>JSON</code> 的解析器）</li></ul><h3 id="Apache-Thrift"><a href="#Apache-Thrift" class="headerlink" title="Apache Thrift"></a>Apache Thrift</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>支持非常多的语言绑定</li><li>thrift` 文件生成目标代码，简单易用</li><li>消息定义文件支持注释</li><li>数据结构与传输表现的分离，支持多种消息格式</li><li>包含完整的客户端/服务端堆栈，可快速实现 <code>RPC</code></li><li>支持同步和异步通信</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>和 <code>protobuf</code> 一样不支持动态特性</li></ul><h3 id="Apache-Avro"><a href="#Apache-Avro" class="headerlink" title="Apache Avro"></a>Apache Avro</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>二进制消息，性能好/效率高</li><li>使用 <code>JSON</code> 描述模式</li><li>模式和数据统一存储，消息自描述，不需要生成 <code>stub</code> 代码（支持生成 <code>IDL</code>）</li><li><code>RPC</code> 调用在握手阶段交换模式定义</li><li>包含完整的客户端/服务端堆栈，可快速实现 <code>RPC</code></li><li>支持同步和异步通信</li><li>支持动态消息</li><li>模式定义允许定义数据的排序（序列化时会遵循这个顺序）</li><li>提供了基于 <code>Jetty</code> 内核的服务基于 <code>Netty</code> 的服务</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>只支持 <code>Avro</code> 自己的序列化格式</li><li>语言绑定不如 <code>Thrift</code> 丰富</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道结构化数据存储方式多种多样，有 &lt;code&gt;json&lt;/code&gt;、&lt;code&gt;xml&lt;/code&gt;、&lt;code&gt;kryo&lt;/code&gt;等等，而 &lt;code&gt;json&lt;/code&gt; 与 &lt;code&gt;xml&lt;/code&gt; 虽然可读性较强，但是需要的额外空间太多，当数据量过大的时候很浪费性能，所以就需要压缩率更高的编码方式，这里对比比较流行的几种存储（编码）方式：&lt;code&gt;kryo&lt;/code&gt;、&lt;code&gt;avro&lt;/code&gt;、&lt;code&gt;protobuf&lt;/code&gt;、&lt;code&gt;thrift&lt;/code&gt;、&lt;code&gt;jce&lt;/code&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://1016990109.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="序列化" scheme="http://1016990109.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="反序列化" scheme="http://1016990109.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="kryo" scheme="http://1016990109.github.io/tags/kryo/"/>
    
      <category term="avro" scheme="http://1016990109.github.io/tags/avro/"/>
    
      <category term="protobuf" scheme="http://1016990109.github.io/tags/protobuf/"/>
    
      <category term="jce" scheme="http://1016990109.github.io/tags/jce/"/>
    
  </entry>
  
  <entry>
    <title>Node 应用性能优化</title>
    <link href="http://1016990109.github.io/2018/06/13/Node-%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://1016990109.github.io/2018/06/13/Node-应用性能优化/</id>
    <published>2018-06-13T07:22:18.000Z</published>
    <updated>2018-06-17T18:12:54.660Z</updated>
    
    <content type="html"><![CDATA[<p>在实际 <code>Node.js</code> 应用开发中可能会遇到性能上的瓶颈，在项目比较复杂的时候光阅读代码是很难发现问题所在的，这时候就需要有效的方法来发现瓶颈所在。</p><p>这里介绍一种简单的方法来帮助开发者洞察瓶颈所在，提升 <code>Node.js</code> 应用性能。</p><a id="more"></a><p>这个方法的主要目标就是度量在 <code>Node.js</code> 应用中执行每个函数所花费的 <code>CPU</code> 时间。当然也可以通过对内存的度量来检测内存泄漏，但在本篇文章只介绍对性能上面的优化。</p><h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><p>谷歌浏览器可以通过 <code>DevTools</code> 来记录每个函数信息和执行时间并将这些东西打进日志文件，来帮助开发者来发现瓶颈。而 <code>Node.js</code> 也有类似的内置工具，就是 <code>--prof</code> 配置，这个可以统计所有函数执行消耗的 <code>CPU</code> 时间片长度。</p><p>先来看个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file test.js</span></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>)</span><br><span class="line"><span class="keyword">const</span> cpuNums = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length <span class="comment">//我的机器上是8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clusters = []</span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpuNums; i++) &#123;</span><br><span class="line">    clusters[i] = cluster.fork()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n0 = <span class="built_in">parseInt</span>(n / cpuNums)</span><br><span class="line">  <span class="keyword">let</span> s = <span class="number">0</span>,</span><br><span class="line">    t = <span class="number">0</span>,</span><br><span class="line">    start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpuNums; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> worker = clusters[i]</span><br><span class="line">      worker.process.send(<span class="string">`<span class="subst">$&#123;i * n0&#125;</span>|<span class="subst">$&#123;(i + <span class="number">1</span>) * n0&#125;</span>`</span>)</span><br><span class="line">      worker.on(<span class="string">'message'</span>, s0 =&gt; &#123;</span><br><span class="line">        s += <span class="built_in">Number</span>(s0)</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (t === cpuNums) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'time:'</span>, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'sum:'</span>, s)</span><br><span class="line">          process.exit(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    process.on(<span class="string">'message'</span>, n =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> [start, end] = n.split(<span class="string">'|'</span>),</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">      <span class="built_in">console</span>.log(start, end)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Number</span>(start); i &lt; <span class="built_in">Number</span>(end); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">0</span>) s += i</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">1</span>) s -= i</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">2</span>) s *= i</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">3</span>) s /= i</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">      process.send(s)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">100000000</span>)</span><br></pre></td></tr></table></figure><p>上面的代码的主要功能是将一区间的整数分成几个部分分别对每 4 个数做加减乘除运算，最后将每个部分的结果加合得到最后的结果。可以发现上面代码为了提高性能而使用多个 <code>CPU</code> 核去执行计算任务，想充分利用 <code>CPU</code> 的性能，然而事实并非如此，在我的机器上运行结果如下：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time: 1369</span><br><span class="line">sum: -23641385.327095307</span><br></pre></td></tr></table></figure><p>再来看看只用一个 <code>CPU</code> 来执行的代码和结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file test2.js</span></span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="comment">// CPU核共8个，所以这里也分成8分，保持一致性</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="number">0</span>, result = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0 12500000'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">12500000</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">0</span>) s += i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">1</span>) s -= i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">2</span>) s *= i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">3</span>) s /= i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line">result += s</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'12500000 25000000'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">12500000</span>;i &lt; <span class="number">25000000</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">0</span>) s += i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">1</span>) s -= i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">2</span>) s *= i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">3</span>) s /= i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'87500000 1000000000'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">87500000</span>;i &lt; <span class="number">100000000</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">0</span>) s += i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">1</span>) s -= i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">2</span>) s *= i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">3</span>) s /= i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line">result += s</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'time:'</span>, <span class="built_in">Date</span>.now() - start)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sum:'</span>, result)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time: 541</span><br><span class="line">sum: -23641385.32709531</span><br></pre></td></tr></table></figure><p>可以发现使用了多个 <code>CPU</code> 来执行反而更慢了，这是为啥？我们用上面说的配置来看一下问题出在哪。运行：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --prof test.js</span><br></pre></td></tr></table></figure><p>执行完后出现一堆类似于 <code>isolate-*-v8-*.log</code> 的子进程 log(共 8 个，子进程 <code>worker</code>) 和一个主进程 log <code>isolate-*-v8.log</code>(主进程 <code>master</code>)。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用 <code>--prof-process</code> 配置运行 <code>NodeJS</code>，并提供上面生成的文件的路径。</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --prof-process isolate-0x102802400-v8-81626.log</span><br></pre></td></tr></table></figure><p>从上到下主要分为几个耗时分类，<code>Shared libraries</code>, <code>JavaScript</code>, <code>C++</code>, <code>Summary</code>, <code>C++ entry points</code>, <code>Bottom up (heavy) profile</code>:</p><h3 id="Shared-libraries"><a href="#Shared-libraries" class="headerlink" title="Shared libraries"></a>Shared libraries</h3><p><code>Node</code> 进程使用到的系统级动态链接库部分的时间消耗，会显示在这个分类下。</p><p>该分类的几列：</p><p><code>ticks</code>：每个库所占用的 <code>ticks</code> 数量<br><code>total</code>：每个库占用的 <code>ticks</code> 总量百分比<br><code>nonlib</code>：这列在当前分类不适用，因为本来这里列的就都是类库时间消耗，<code>nonlib</code> 当然没有数据<br><code>name</code>：动态链接库的文件位置</p><h3 id="JavaScript、C-、Summary"><a href="#JavaScript、C-、Summary" class="headerlink" title="JavaScript、C++、Summary"></a>JavaScript、C++、Summary</h3><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p><code>JavaScript</code> 代码部分的时间消耗，包括了当前项目源代码部分的时间消耗和第三方 <code>node_modules</code> 的时间消耗。</p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p><code>Node</code> 进程在 <code>C++</code> 代码里的时间消耗，<code>Node</code> 本身是构建在 <code>V8</code> 引擎之上的，所以一些 <code>Node</code> 标准库里的 <code>API</code>，基本上都是 <code>C++</code> 时间消耗。当然这个分类也包含了一些作为第三方 <code>addon</code> 加载的插件的时间消耗。</p><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>将所有的分类的时间消耗总量都放在一起，形成一个直观的结果。</p><h4 id="列含义"><a href="#列含义" class="headerlink" title="列含义"></a>列含义</h4><ul><li><code>ticks</code>：占用的 <code>ticks</code> 数量</li><li><code>total</code>：占用的 <code>ticks</code> 总量百分比</li><li><code>nonlib</code>：<br>这列描述的是将 <code>Shared libraries</code> 所产生的时间消耗忽略之后，当前条目自身产生的时间消耗（<code>ticks</code>）所占的百分比</li><li><code>name</code>(每个 <code>name</code> 列实际函数名之前一般会有一个 <code>*</code> 或 <code>~</code>，星号表示该函数得到了优化，而波浪号则表示没有)：<br><code>JavaScript</code>：函数名，以及其在源代码中的位置<br><code>C++</code>：函数名，一般都是 <code>Node</code> 运行时和 <code>V8</code> 相关的函数<br><code>Summary</code>：分类名</li></ul><h3 id="C-entry-points"><a href="#C-entry-points" class="headerlink" title="C++ entry points"></a>C++ entry points</h3><p>这部分描述的是当逻辑从 <code>JS</code> 代码跨界到 <code>C++</code> 代码运行时，其中消耗的时间。</p><h3 id="Bottom-up-heavy-profile"><a href="#Bottom-up-heavy-profile" class="headerlink" title="Bottom up (heavy) profile"></a>Bottom up (heavy) profile</h3><p>这部分是性能问题的暴露部分，一般看完 <code>Summery</code> 不想了解其细节就直接来看这部分是解决问题的最快方案。</p><p>和之前其他分类耗时部分不同的是，在这部分里按空行分隔的不同段落都是一个个单独的性能瓶颈点，每个段落的多行表示的是一个调用栈。</p><p>此外，这个部分的列内容也和之前的略有不同（主要是<code>parent</code>字段），<code>parent</code> 列的百分比意味着：表示上一行中的函数由当前行中的函数调用的百分比。</p><h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>先看 <code>Summary</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Summary]:</span><br><span class="line">  ticks  total  nonlib   name</span><br><span class="line">  262   23.7%   23.7%  JavaScript</span><br><span class="line">  778   70.3%   70.4%  C++</span><br><span class="line">    38    3.4%    3.4%  GC</span><br><span class="line">    1    0.1%          Shared libraries</span><br><span class="line">    65    5.9%          Unaccounted</span><br></pre></td></tr></table></figure><p>可以发现大部分性能浪费在执行 <code>C++</code> 代码上了，所以我们重点观察 <code>C++</code> 部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[C++]:</span><br><span class="line">  ticks  total  nonlib   name</span><br><span class="line">  376   34.0%   34.0%  t bool v8::internal::StringToArrayIndex&lt;v8::internal::StringCharacterStream&gt;(v8::internal::StringCharacterStream*, unsigned int*)</span><br><span class="line">    88    8.0%    8.0%  T v8::internal::String::ToNumber(v8::internal::Handle&lt;v8::internal::String&gt;)</span><br><span class="line">    81    7.3%    7.3%  T v8::internal::Runtime_StringToNumber(int, v8::internal::Object**, v8::internal::Isolate*)</span><br><span class="line">...</span><br><span class="line">[C++ entry points]:</span><br><span class="line">ticks    cpp   total   name</span><br><span class="line">687   93.3%   62.1%  T v8::internal::Runtime_StringToNumber(int, v8::internal::Object**, v8::internal::Isolate*)</span><br><span class="line">  28    3.8%    2.5%  T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*)</span><br><span class="line">...</span><br><span class="line">[Bottom up (heavy) profile]:</span><br><span class="line">  Note: percentage shows a share of a particular caller in the total</span><br><span class="line">  amount of its parent calls.</span><br><span class="line">  Callers occupying less than 1.0% are not shown.</span><br><span class="line"></span><br><span class="line">   ticks parent  name</span><br><span class="line">    376   34.0%  t bool v8::internal::StringToArrayIndex&lt;v8::internal::StringCharacterStream&gt;(v8::internal::StringCharacterStream*, unsigned int*)</span><br><span class="line">    376  100.0%    T v8::internal::Runtime_StringToNumber(int, v8::internal::Object**, v8::internal::Isolate*)</span><br><span class="line">    376  100.0%      LazyCompile: *process.on.n /Users/hongchuanwang/Desktop/test2.js:29:31</span><br><span class="line">    376  100.0%        LazyCompile: ~emitTwo events.js:124:17</span><br><span class="line">    376  100.0%          LazyCompile: ~emit events.js:156:44</span><br><span class="line">    376  100.0%            LazyCompile: ~emit internal/child_process.js:771:16</span><br><span class="line"></span><br><span class="line">    155   14.0%  LazyCompile: *process.on.n /Users/hongchuanwang/Desktop/test2.js:29:31</span><br><span class="line">    155  100.0%    LazyCompile: ~emitTwo events.js:124:17</span><br><span class="line">    155  100.0%      LazyCompile: ~emit events.js:156:44</span><br><span class="line">    155  100.0%        LazyCompile: ~emit internal/child_process.js:771:16</span><br><span class="line">    155  100.0%          LazyCompile: ~_combinedTickCallback internal/process/next_tick.js:129:33</span><br><span class="line">    155  100.0%            LazyCompile: ~_tickCallback internal/process/next_tick.js:151:25</span><br></pre></td></tr></table></figure><p>34%的耗时都在 <code>StringToArrayIndex</code>，而调用该函数的都是 <code>Runtime_StringToNumber</code>，根据调用栈我们就发现代码中有一段 <code>for (let i = Number(start); i &lt; Number(end); i++)</code> 发现问题所在，是循环的时候多次处理了 <code>end</code>，所以只需要将 <code>Number(end)</code> 放在循环外处理就行了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start = <span class="built_in">Number</span>(start)</span><br><span class="line">end = <span class="built_in">Number</span>(end)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">0</span>) s += i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">1</span>) s -= i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">2</span>) s *= i</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">4</span> === <span class="number">3</span>) s /= i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改完再分析结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[Summary]:</span><br><span class="line">  ticks  total  nonlib   name</span><br><span class="line">  123   53.0%   53.2%  JavaScript</span><br><span class="line">  103   44.4%   44.6%  C++</span><br><span class="line">    34   14.7%   14.7%  GC</span><br><span class="line">    1    0.4%          Shared libraries</span><br><span class="line">    5    2.2%          Unaccounted</span><br><span class="line">...</span><br><span class="line">[C++ entry points]:</span><br><span class="line">   ticks    cpp   total   name</span><br><span class="line">     40   65.6%   17.2%  T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*)</span><br><span class="line">     13   21.3%    5.6%  T v8::internal::Runtime_CompileLazy(int, v8::internal::Object**, v8::internal::Isolate*)</span><br><span class="line">...</span><br><span class="line">[Bottom up (heavy) profile]:</span><br><span class="line">  Note: percentage shows a share of a particular caller in the total</span><br><span class="line">  amount of its parent calls.</span><br><span class="line">  Callers occupying less than 1.0% are not shown.</span><br><span class="line"></span><br><span class="line">   ticks parent  name</span><br><span class="line">    119   51.3%  LazyCompile: *process.on.n /Users/hongchuanwang/Desktop/test2.js:29:31</span><br><span class="line">    119  100.0%    LazyCompile: ~emitTwo events.js:124:17</span><br><span class="line">    119  100.0%      LazyCompile: ~emit events.js:156:44</span><br><span class="line">    119  100.0%        LazyCompile: ~emit internal/child_process.js:771:16</span><br><span class="line">    119  100.0%          LazyCompile: ~_combinedTickCallback internal/process/next_tick.js:129:33</span><br><span class="line">    119  100.0%            LazyCompile: ~_tickCallback internal/process/next_tick.js:151:25</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以发现耗时的 <code>StringToNumber</code> 已经没有了，<code>CPU</code> 的 <code>tick</code> 也只有119了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际 &lt;code&gt;Node.js&lt;/code&gt; 应用开发中可能会遇到性能上的瓶颈，在项目比较复杂的时候光阅读代码是很难发现问题所在的，这时候就需要有效的方法来发现瓶颈所在。&lt;/p&gt;
&lt;p&gt;这里介绍一种简单的方法来帮助开发者洞察瓶颈所在，提升 &lt;code&gt;Node.js&lt;/code&gt; 应用性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://1016990109.github.io/tags/Node/"/>
    
      <category term="优化" scheme="http://1016990109.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Node 服务部署</title>
    <link href="http://1016990109.github.io/2018/06/09/Node-%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"/>
    <id>http://1016990109.github.io/2018/06/09/Node-服务部署/</id>
    <published>2018-06-09T01:36:22.000Z</published>
    <updated>2018-06-12T09:21:58.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="forever-与-pm2"><a href="#forever-与-pm2" class="headerlink" title="forever 与 pm2"></a>forever 与 pm2</h2><p>在之前部署 <code>Node.js</code> 服务都是使用 <code>forever</code> 的，现在基本上都改为 <code>pm2</code> 了，<code>pm2</code> 比 <code>forever</code> 功能更加强大，可以配置集群、集成日志、控制台监视等等，下面是两者的比较：</p><table><thead><tr><th>Feature</th><th>Forever</th><th>PM2</th></tr></thead><tbody><tr><td>Keep Alive</td><td>✔</td><td>✔</td></tr><tr><td>Coffeescript</td><td>✔</td><td></td></tr><tr><td>Log aggregation</td><td></td><td>✔</td></tr><tr><td>API</td><td></td><td>✔</td></tr><tr><td>Terminal monitoring</td><td></td><td>✔</td></tr><tr><td>Clustering</td><td></td><td>✔</td></tr><tr><td>JSON configuration</td><td></td><td>✔</td></tr></tbody></table><a id="more"></a><p>所以如果还在使用 <code>forever</code> 的读者，快快加入到 <code>pm2</code> 的阵营来吧。</p><h2 id="pm2-使用"><a href="#pm2-使用" class="headerlink" title="pm2 使用"></a>pm2 使用</h2><p>详情请看<a href="https://pm2.io/doc/en/runtime/overview/" target="_blank" rel="noopener">官方文档</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>pm2</code> 可以直接在命令行中通过参数配置，也可以用过 <code>ecosystem.config.js</code> 文件来配置，<code>pm2 init</code> 初始化一个配置文件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [&#123;</span><br><span class="line">    name: <span class="string">"app"</span>,</span><br><span class="line">    script: <span class="string">"./app.js"</span>,</span><br><span class="line">    env: &#123;</span><br><span class="line">      NODE_ENV: <span class="string">"development"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    env_production: &#123;</span><br><span class="line">      NODE_ENV: <span class="string">"production"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// deploy config(部署配置也在这里)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集成-log"><a href="#集成-log" class="headerlink" title="集成 log"></a>集成 log</h3><p>可以单独配置普通输出和错误输出到不同的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'app'</span>,</span><br><span class="line">      script: <span class="string">'app.js'</span>,</span><br><span class="line">      output: <span class="string">'./out.log'</span>,</span><br><span class="line">      error: <span class="string">'./error.log'</span>,</span><br><span class="line">      log: <span class="string">'./combined.outerr.log'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时也可以集成 <code>pm2-logrotate</code> 工具来管理日志，可以配置日志分片大小、时间、名字等等。</p><h3 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h3><p><code>pm2</code> 可以配置开机启动，通过 <code>pm2 startup</code> 命令会自动提示你该怎么配置自启动。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><code>pm2</code> 支持集群模式，可以在不更改代码的前提下自动帮你配置集群，有效利用系统的 <code>CPU</code> 资源，充分利用计算机能力，消除 <code>Node.js</code> 单线程的瓶颈，可以同时启动多个进程来监听同一个端口(这在文后会提到具体怎么实现多进程监听)，提高性能。</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i &lt;number-instances&gt;</span><br></pre></td></tr></table></figure><p>或者配置 <code>ecosystem.config.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [</span><br><span class="line">    &#123;</span><br><span class="line">      script: <span class="string">'app.js'</span>,</span><br><span class="line">      instances: <span class="string">'max'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SSH-部署"><a href="#SSH-部署" class="headerlink" title="SSH 部署"></a>SSH 部署</h3><p><code>pm2</code> 还支持自动化将代码部署到远程服务器，只需要做一些简单的配置即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [&#123;</span><br><span class="line">    name: <span class="string">"app"</span>,</span><br><span class="line">    script: <span class="string">"app.js"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  deploy: &#123;</span><br><span class="line">    <span class="comment">// "production" is the environment name</span></span><br><span class="line">    production: &#123;</span><br><span class="line">      <span class="comment">// SSH key path, default to $HOME/.ssh</span></span><br><span class="line">      key: <span class="string">"/path/to/some.pem"</span>,</span><br><span class="line">      <span class="comment">// SSH user</span></span><br><span class="line">      user: <span class="string">"ubuntu"</span>,</span><br><span class="line">      <span class="comment">// SSH host</span></span><br><span class="line">      host: [<span class="string">"192.168.0.13"</span>],</span><br><span class="line">      <span class="comment">// SSH options with no command-line flag, see 'man ssh'</span></span><br><span class="line">      <span class="comment">// can be either a single string or an array of strings</span></span><br><span class="line">      ssh_options: <span class="string">"StrictHostKeyChecking=no"</span>,</span><br><span class="line">      <span class="comment">// GIT remote/branch</span></span><br><span class="line">      ref: <span class="string">"origin/master"</span>,</span><br><span class="line">      <span class="comment">// GIT remote</span></span><br><span class="line">      repo: <span class="string">"git@github.com:Username/repository.git"</span>,</span><br><span class="line">      <span class="comment">// path in the server</span></span><br><span class="line">      path: <span class="string">"/var/www/my-repository"</span>,</span><br><span class="line">      <span class="comment">// Pre-setup command or path to a script on your local machine</span></span><br><span class="line">      pre-setup: <span class="string">"apt-get install git ; ls -la"</span>,</span><br><span class="line">      <span class="comment">// Post-setup commands or path to a script on the host machine</span></span><br><span class="line">      <span class="comment">// eg: placing configurations in the shared dir etc</span></span><br><span class="line">      post-setup: <span class="string">"ls -la"</span>,</span><br><span class="line">      <span class="comment">// pre-deploy action</span></span><br><span class="line">      pre-deploy-local: <span class="string">"echo 'This is a local executed command'"</span></span><br><span class="line">      <span class="comment">// post-deploy action</span></span><br><span class="line">      post-deploy: <span class="string">"npm install"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>如果使用集群模式需要主要应用得是个无状态应用，所以诸如 <code>sessions</code>、<code>websocket connection</code> 等不要使用，可以使用 <code>Redis</code> 等来共享应用的状态。</li><li>关闭应用之前最好确认所有的请求已经被处理，数据库连接已经释放，释放其他资源。</li></ol><h2 id="cluster-原理"><a href="#cluster-原理" class="headerlink" title="cluster 原理"></a>cluster 原理</h2><p><code>pm2</code> 集群其实是封装了 <code>cluster</code> 模块的一系列操作，自动包装代码启动集群，重加载的时候也是先启动新的 <code>worker</code> 再把之前的 <code>worker</code> 停掉等等。</p><p>这里是一个简单的 <code>cluster</code> 的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = os.cpus().length; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">    cluster.fork()</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  http</span><br><span class="line">    .createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>)</span><br><span class="line">      res.end(<span class="string">'hello world\n'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .listen(<span class="number">8000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fork</code> 的本质还是使用了 <code>child_process.fork</code> 生成的子进程，但是注意不能直接使用 <code>child_process.fork()</code> 来生成，因为这样会缺少 <code>process.env.NODE_UNIQUE_ID</code>，会导致 <code>cluster.isMaster</code> 判断总是为 <code>true</code>。</p><p>运行时，所有新建立的连接都由主进程完成，然后主进程再把 <code>TCP</code> 连接分配给指定的 <code>worker</code> 进程。分配根据 <code>Round-robin</code> 算法分发，子进程 <code>worker</code> 具体处理请求。</p><p>更加详细的 <code>cluser</code> 用法与讲解可查看<a href="http://javascript.ruanyifeng.com/nodejs/cluster.html" target="_blank" rel="noopener">阮一峰的博客</a> 和 <a href="https://nodejs.org/dist/latest-v10.x/docs/api/cluster.html" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;forever-与-pm2&quot;&gt;&lt;a href=&quot;#forever-与-pm2&quot; class=&quot;headerlink&quot; title=&quot;forever 与 pm2&quot;&gt;&lt;/a&gt;forever 与 pm2&lt;/h2&gt;&lt;p&gt;在之前部署 &lt;code&gt;Node.js&lt;/code&gt; 服务都是使用 &lt;code&gt;forever&lt;/code&gt; 的，现在基本上都改为 &lt;code&gt;pm2&lt;/code&gt; 了，&lt;code&gt;pm2&lt;/code&gt; 比 &lt;code&gt;forever&lt;/code&gt; 功能更加强大，可以配置集群、集成日志、控制台监视等等，下面是两者的比较：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Feature&lt;/th&gt;
&lt;th&gt;Forever&lt;/th&gt;
&lt;th&gt;PM2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Keep Alive&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Coffeescript&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Log aggregation&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;API&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Terminal monitoring&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clustering&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JSON configuration&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://1016990109.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第三章</title>
    <link href="http://1016990109.github.io/2018/06/07/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/06/07/Node-js-设计模式读书笔记-第三章/</id>
    <published>2018-06-07T02:39:52.000Z</published>
    <updated>2018-06-11T12:04:13.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Asynchorous-Control-Flow-Patterns-with-Callbacks-使用回调的异步控制流模式"><a href="#Asynchorous-Control-Flow-Patterns-with-Callbacks-使用回调的异步控制流模式" class="headerlink" title="Asynchorous Control Flow Patterns with Callbacks(使用回调的异步控制流模式)"></a>Asynchorous Control Flow Patterns with Callbacks(使用回调的异步控制流模式)</h1><p>异步的代码使得难以预测语句的执行顺序，所以在一些场景(比如遍历一些文件，执行一系列任务等等)下，这就要求开发者去使用一些方法或技术来防止编写出低效和难以阅读的代码。</p><h2 id="The-difficulties-of-asynchonous-programming-异步编程的困难"><a href="#The-difficulties-of-asynchonous-programming-异步编程的困难" class="headerlink" title="The difficulties of asynchonous programming(异步编程的困难)"></a>The difficulties of asynchonous programming(异步编程的困难)</h2><blockquote><p><code>KISS</code> 原则：Keep It Simple, Stupid，注重简约。</p></blockquote><a id="more"></a><p>匿名函数的闭包和原地定义使得开发者不用跳去另外一个地方写代码，这样编程就变得非常顺利。(比先去定义一个函数再回来引入要简单多了)这很好地体现了 <code>KISS</code> 原则，因为它是简单的，保持了代码编写的流(或理解为顺序吧)，开发时间少。但是当嵌套的层次变得多了起来之后，可维护性、复用性、模块性就被破坏了</p><h3 id="Creating-a-simple-web-spider-创建一个简单的-web-爬虫"><a href="#Creating-a-simple-web-spider-创建一个简单的-web-爬虫" class="headerlink" title="Creating a simple web spider(创建一个简单的 web 爬虫)"></a>Creating a simple web spider(创建一个简单的 web 爬虫)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file spider.js</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> mkdirp = <span class="built_in">require</span>(<span class="string">'mkdirp'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> utilities = <span class="built_in">require</span>(<span class="string">'./utilities'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = utilities.urlToFilename(url)</span><br><span class="line">  fs.exists(filename, exists =&gt; &#123;</span><br><span class="line">    <span class="comment">//[1]</span></span><br><span class="line">    <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Downloading <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">      request(url, (err, response, body) =&gt; &#123;</span><br><span class="line">        <span class="comment">//[2]</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          callback(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mkdirp(path.dirname(filename), err =&gt; &#123;</span><br><span class="line">            <span class="comment">//[3]</span></span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">              callback(err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              fs.writeFile(filename, body, err =&gt; &#123;</span><br><span class="line">                <span class="comment">//[4]</span></span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                  callback(err)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  callback(<span class="literal">null</span>, filename, <span class="literal">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback(<span class="literal">null</span>, filename, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数执行下面的任务：</p><ol><li>通过查看相关的文件已经是否被创建来检查 <code>URL</code> 是不是已经被下载过了:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.exists(filename, exists =&gt; ...</span><br></pre></td></tr></table></figure><ol start="2"><li>文件没有找到，则下载 <code>URL</code>:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request(url, (err, response, body) =&gt; ...</span><br></pre></td></tr></table></figure><ol start="3"><li>保证包含该文件的文件夹存在:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdirp(path.dirname(filename), err =&gt; ...</span><br></pre></td></tr></table></figure><ol start="4"><li>最后将 <code>HTTP</code> 响应内容写入文件系统的文件中:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(filename, body, err =&gt; ...</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spider(process.argv[<span class="number">2</span>], (err, filename, downloaded) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloaded) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Completed the download of "<span class="subst">$&#123;filename&#125;</span>"`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`"<span class="subst">$&#123;filename&#125;</span>" was already downloaded`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="The-callback-hell-回调地狱"><a href="#The-callback-hell-回调地狱" class="headerlink" title="The callback hell(回调地狱)"></a>The callback hell(回调地狱)</h3><p>从上面的 <code>spider()</code> 函数中可以看到，尽管我们非常直接清晰地实现这个算法，但是代码还是有很多层的缩进导致难以阅读。</p><p>当然将上面的逻辑使用同步代码的方式实现会更加直接，而且出错的概率也会变得更小，但是阻塞就会使得效率更低，而且使用异步 <code>CPS</code> 风格也是另外一种尝试了。</p><p>这种大量的闭包和内联回调函数定义导致代码变得不可读和不可控的场景称为回调地狱:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asyncFoo(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  asyncBar(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    asyncFooBar(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这种代码一个显而易见的问题就是降低了可读性，当层次变得很多的时候会看不清一个函数是什么时候结束的或者另一个函数是什么时候开始的。</p><p>另一个问题就是变量名的重叠，有时候我们不得不使用相似的甚至相同的名字来描述一个内容，例如错误处理中使用 <code>err1</code> 、<code>err2</code>、<code>err3</code> 表示错误，甚至是直接使用相同的名字如 <code>err</code>，这些都不是好的实现，并且会导致混淆，提高缺陷发生的概率。</p><p>还有一点需要注意，虽然闭包在性能和内存上代价较小，但是这可能导致不易识别的内存泄漏，因为被一个活动的闭包持有的上下文引用是不会被垃圾回收的。</p><blockquote><p>想知道闭包怎么在 <code>V8</code> 中工作的可以看<a href="https://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html" target="_blank" rel="noopener">这里</a></p></blockquote><h2 id="Using-plain-JavaScript-使用纯-JavaScript"><a href="#Using-plain-JavaScript-使用纯-JavaScript" class="headerlink" title="Using plain JavaScript(使用纯 JavaScript)"></a>Using plain JavaScript(使用纯 JavaScript)</h2><h3 id="Callback-decipline-回调准则"><a href="#Callback-decipline-回调准则" class="headerlink" title="Callback decipline(回调准则)"></a>Callback decipline(回调准则)</h3><p>写异步函数的第一准则就是不要滥用闭包。</p><p>下面是一些减少嵌套层次的原则：</p><ul><li>尽快返回。根据上下文，使用 <code>return</code>、<code>continue</code> 或 <code>break</code>，以便立即退出当前代码块，而不是写完整的 <code>if...else</code> 的语句。</li><li>给函数命名，将中间结果作为参数传递。</li><li>模块化代码。尽可能地将代码分成更小、更可复用的函数。</li></ul><h3 id="Applying-the-callback-decipline-应用回调准则"><a href="#Applying-the-callback-decipline-应用回调准则" class="headerlink" title="Applying the callback decipline(应用回调准则)"></a>Applying the callback decipline(应用回调准则)</h3><p>我们来应用这些准则来修复上面的 <code>spider</code> 应用。</p><p>第一步：移除 <code>else</code> 语句，发现错误后立即返回，可以发现很容易就较少了嵌套的层级了(少了 <code>else</code> 那一层级)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">  <span class="keyword">return</span> callback(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//code to execute when there are no errors</span></span><br></pre></td></tr></table></figure><p>第二步：识别可复用的代码，独立出来为一个函数，这里为写入字符串到一个文件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveFile</span>(<span class="params">filename, contents, callback</span>) </span>&#123;</span><br><span class="line">  mkdirp(path.dirname(filename), err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fs.writeFile(filename, contents, callback)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的也可以独立出一个 <code>download(url, filename, callback)</code> 函数来下载 <code>URL</code> 内容。</p><p>最后一步：整合上面的两步，修改 <code>spider()</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = utilities.urlToFilename(url)</span><br><span class="line">  fs.exists(filename, exists =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="literal">null</span>, filename, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    download(url, filename, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(err)</span><br><span class="line">      &#125;</span><br><span class="line">      callback(<span class="literal">null</span>, filename, <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现只是简单地重新组织了代码，嵌套的层级就降低了很多，代码也变得更易读了。</p><blockquote><p>其中的 <code>saveFile()</code> 和 <code>download</code> 还可以考虑导出给其他模块使用，增加了复用性。</p></blockquote><h3 id="Sequential-execution-顺序执行"><a href="#Sequential-execution-顺序执行" class="headerlink" title="Sequential execution(顺序执行)"></a>Sequential execution(顺序执行)</h3><p>当需要顺序执行一组任务时(比如先对数据预处理，接着在按照步骤一步步处理数据等等)，尽管使用同步代码容易实现，但是在使用异步 <code>CPS</code> 风格来做时就可能导致回调地狱了。</p><h4 id="Executing-a-known-set-of-tasks-in-sequence-顺序执行一个已知的任务集合"><a href="#Executing-a-known-set-of-tasks-in-sequence-顺序执行一个已知的任务集合" class="headerlink" title="Executing a known set of tasks in sequence(顺序执行一个已知的任务集合)"></a>Executing a known set of tasks in sequence(顺序执行一个已知的任务集合)</h4><p>直接上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  asyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    task2(callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task2</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  asyncOperation(result() =&gt; &#123;</span><br><span class="line">    task3(callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task3</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  asyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(); <span class="comment">//finally executes the callback</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task1(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//executed when task1, task2 and task3 are completed</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'tasks 1, 2 and 3 executed'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面演示了在一个任务中，当异步操作完成时如何调用下一个任务，这告诉我们处理异步代码不一定需要闭包。</p><h4 id="Sequential-iteration-顺序迭代"><a href="#Sequential-iteration-顺序迭代" class="headerlink" title="Sequential iteration(顺序迭代)"></a>Sequential iteration(顺序迭代)</h4><p>上面示例中，我们是知道有多少任务要执行的，那么当任务数量和具体任务不清楚的时候该怎么办呢，我们就不能硬编码任务执行顺序了，得动态地生成。</p><h5 id="Web-spider-version-2-Web-爬虫第-2-版"><a href="#Web-spider-version-2-Web-爬虫第-2-版" class="headerlink" title="Web spider version 2(Web 爬虫第 2 版)"></a>Web spider version 2(Web 爬虫第 2 版)</h5><p>为了显示顺序迭代的例子，让我们为 <code>Web</code> 爬虫应用程序引入一个新功能：我们现在想要递归地下载网页中的所有链接。</p><p>第一步是修改我们的 <code>spider()</code> 函数，以便通过调用一个名为 <code>spiderLinks()</code> 的函数触发页面所有链接的递归下载。</p><p>此外，我们现在尝试读取文件，而不是检查文件是否已经存在，并开始爬取其链接。这样，我们就可以在中断爬虫后恢复爬虫而不需要继续下载。最后还有一个变化是传递一个新的参数 <code>nesting</code>，用来限制递归深度。结果代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, nesting, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = utilities.urlToFilename(url);</span><br><span class="line">  fs.readFile(filename, <span class="string">'utf8'</span>, (err, body) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err.code! == <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> download(url, filename, (err, body) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> callback(err);</span><br><span class="line">        &#125;</span><br><span class="line">        spiderLinks(url, body, nesting, callback);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    spiderLinks(url, body, nesting, callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Sequential-crawling-of-links-顺序爬取连接"><a href="#Sequential-crawling-of-links-顺序爬取连接" class="headerlink" title="Sequential crawling of links(顺序爬取连接)"></a>Sequential crawling of links(顺序爬取连接)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, body, nesting, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> links = utilities.getPageLinks(currentUrl, body) <span class="comment">//[1]</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//[2]</span></span><br><span class="line">    <span class="keyword">if</span> (index === links.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spider(links[index], nesting - <span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//[3]</span></span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(err)</span><br><span class="line">      &#125;</span><br><span class="line">      iterate(index + <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  iterate(<span class="number">0</span>) <span class="comment">//[4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们使用 <code>utilities.getPageLinks()</code> 函数获取页面中包含的所有链接的列表。此函数仅返回指向相同主机名的链接。</li><li>我们使用 <code>iterate()</code> 本地函数来遍历链接，该函数需要下一个链接的索引进行分析。在这个函数中，我们首先要检查索引是否等于链接数组的长度，如果等于则是迭代完成，在这种情况下我们立即调用 <code>callback()</code> 函数，因为这意味着我们处理了所有的项目。</li><li>这时，已准备好处理链接。我们减少嵌套层级(<code>nesting - 1</code>)后调用 <code>spider()</code>，然后当操作完成后继续下一个迭代(<code>index + 1</code>)。</li><li>调用 <code>iterate(0)</code> 来开始迭代。</li></ol><p>现在这个 <code>spider</code> 已经可以递归的爬取网页的链接了。中断(<code>ctrl + c</code>)后再次启动也可以继续上次的任务。</p><h5 id="The-pattern-迭代模式"><a href="#The-pattern-迭代模式" class="headerlink" title="The pattern(迭代模式)"></a>The pattern(迭代模式)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index === tasks.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> finish()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> task = tasks[index]</span><br><span class="line">  task(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    iterate(index + <span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finish</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代完成的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iterate(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面表示了异步任务需要按顺序执行时的一个通用模式，可以在集合的元素或通常的任务列表上按顺序异步迭代。</p><blockquote><p>注意，当 <code>task</code> 是同步任务的时候，那就是一个同步递归操作了，这可能会造成栈溢出。</p></blockquote><h3 id="Parallel-execution-并行执行"><a href="#Parallel-execution-并行执行" class="headerlink" title="Parallel execution(并行执行)"></a>Parallel execution(并行执行)</h3><p>在 <code>Node.js</code> 中，我们只能并行执行异步操作，因为它们的并发性由非阻塞 <code>API</code> 在内部处理。在 <code>Node.js</code> 中，同步阻塞操作不能并行运行，除非它们被插入异步操作中或使用 <code>setTimeout</code> 之类的做延迟。</p><h4 id="Web-spider-version-3-Web-爬虫第-3-版"><a href="#Web-spider-version-3-Web-爬虫第-3-版" class="headerlink" title="Web spider version 3(Web 爬虫第 3 版)"></a>Web spider version 3(Web 爬虫第 3 版)</h4><p>现在需要并行地下载网页的内容，只需要略做修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, body, nesting, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = utilities.getPageLinks(currentUrl, body)</span><br><span class="line">  <span class="keyword">if</span> (links.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> completed = <span class="number">0</span>,</span><br><span class="line">    hasErrors = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      hasErrors = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> callback(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (++completed === links.length &amp;&amp; !hasErrors) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  links.forEach(<span class="function"><span class="params">link</span> =&gt;</span> &#123;</span><br><span class="line">    spider(link, nesting - <span class="number">1</span>, done)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forEach</code> 同时爬取链接列表中的链接，而不用等待前一个爬取完了才开始爬取下一个，增加一个 <code>completed</code> 变量记录已经爬取完的链接数，当 <code>completed</code> 等于链接个数时就说明所有的链接都已爬取完了，就可以调用最后的回调函数了。或者说当中间出错了也会立即执行回调函数返回。</p><h4 id="The-pattern-并行模式"><a href="#The-pattern-并行模式" class="headerlink" title="The pattern(并行模式)"></a>The pattern(并行模式)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> completed = <span class="number">0</span></span><br><span class="line">tasks.forEach(<span class="function"><span class="params">task</span> =&gt;</span> &#123;</span><br><span class="line">  task(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (++completed === tasks.length) &#123;</span><br><span class="line">      finish()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finish</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有任务执行完成后调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时启动一系列任务，通过记录任务回调函数完成的个数来判断所有任务是否都完成了。</p><h4 id="Fixing-race-conditions-with-concurrent-tasks-修复并发任务中竞争条件"><a href="#Fixing-race-conditions-with-concurrent-tasks-修复并发任务中竞争条件" class="headerlink" title="Fixing race conditions with concurrent tasks(修复并发任务中竞争条件)"></a>Fixing race conditions with concurrent tasks(修复并发任务中竞争条件)</h4><p>在传统的多线程中处理竞争条件通常是锁、互斥条件、信号量和监视器，这些是多线程语言并行化的最复杂的方面之一，对性能也有很大的影响。但是 <code>Node.js</code> 就不同了，它本身就是运行在一个单线程上，这就变得简单多了。但是这不意味着就没有竞争条件了，相反还很普遍。就拿上面的爬虫例子来说，如果有两个爬虫同时运行，都在操作同一个 <code>URL</code> 时，<code>fs.readFile</code> 都读取不到文件，那么两个爬虫就同时去下载这个链接，这就导致了会同时写入内容到同一个文件中。修复办法很简单，在两个 <code>spider</code> 外面定义一个共享的变量记录爬取的链接，如果爬取过则另外一个 <code>spider</code> 就不再爬取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spidering = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, nesting, callback</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(spidering.has(url)) &#123;</span><br><span class="line">       <span class="keyword">return</span> process.nextTick(callback);</span><br><span class="line">     &#125;</span><br><span class="line">     spidering.set(url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="Limited-parallel-execution-有限制的并行执行"><a href="#Limited-parallel-execution-有限制的并行执行" class="headerlink" title="Limited parallel execution(有限制的并行执行)"></a>Limited parallel execution(有限制的并行执行)</h3><p>不对并行任务做控制的话很容易导致昂贵的开销，例如同时读取很多文件会导致系统资源不足，在 web 应用中还可能导致 <code>DoS</code> 攻击，所以限制同一时间任务的执行数是非常重要的。</p><h4 id="Limiting-the-concurrency-限制并行数"><a href="#Limiting-the-concurrency-限制并行数" class="headerlink" title="Limiting the concurrency(限制并行数)"></a>Limiting the concurrency(限制并行数)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = ...</span><br><span class="line"><span class="keyword">let</span> concurrency = <span class="number">2</span>, running = <span class="number">0</span>, completed = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(running &lt; concurrency &amp;&amp; index &lt; tasks.length) &#123;</span><br><span class="line">    task = tasks[index++];</span><br><span class="line">    task(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(completed === tasks.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> finish();</span><br><span class="line">      &#125;</span><br><span class="line">      completed++, running--;</span><br><span class="line">      next();</span><br><span class="line">&#125;);</span><br><span class="line">running++; &#125;</span><br><span class="line">&#125; next();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finish</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//all tasks finished</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面所展示的模式就可以限制同时最大任务数为 2，启动时同时开始最大任务数的任务，之后每当有一个任务结束时，就会从剩下的任务中挑出一个任务开始执行，保持在限制范围内的最多任务同时进行。</p><h4 id="Globally-limiting-the-concurrency-全局地限制并发数"><a href="#Globally-limiting-the-concurrency-全局地限制并发数" class="headerlink" title="Globally limiting the concurrency(全局地限制并发数)"></a>Globally limiting the concurrency(全局地限制并发数)</h4><blockquote><p><code>Node.js</code> 0.11 版本以前是默认限制同一个主机名下最大 <code>HTTP</code> 连接数为 5 的，这个可以满足我们的需要。但是在之后的版本就取消了这个默认限制了。</p></blockquote><h5 id="Queues-to-rescue-队列来拯救"><a href="#Queues-to-rescue-队列来拯救" class="headerlink" title="Queues to rescue(队列来拯救)"></a>Queues to rescue(队列来拯救)</h5><p>我们需要的是限制同时下载的任务数，可以使用队列来解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(concurrency) &#123;</span><br><span class="line">    <span class="keyword">this</span>.concurrency = concurrency</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line">  pushTask(task) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(task)</span><br><span class="line">    <span class="keyword">this</span>.next()</span><br><span class="line">  &#125;</span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.running &lt; <span class="keyword">this</span>.concurrency &amp;&amp; <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> task = <span class="keyword">this</span>.queue.shift()</span><br><span class="line">      task(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.running--</span><br><span class="line">        <span class="keyword">this</span>.next()</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.running++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>pushTask</code> 添加任务，然后启动 <code>next</code> 来开始执行任务，<code>next</code> 会自动识别是否任务数达到上限。</p><h5 id="Web-spider-version-Web-爬虫第-4-版"><a href="#Web-spider-version-Web-爬虫第-4-版" class="headerlink" title="Web spider version(Web 爬虫第 4 版)"></a>Web spider version(Web 爬虫第 4 版)</h5><p>使用上面的队列来更改我们的爬虫程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TaskQueue = <span class="built_in">require</span>(<span class="string">'./taskQueue'</span>)</span><br><span class="line"><span class="keyword">const</span> downloadQueue = <span class="keyword">new</span> TaskQueue(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, body, nesting, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = utilities.getPageLinks(currentUrl, body)</span><br><span class="line">  <span class="keyword">if</span> (links.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> completed = <span class="number">0</span>,</span><br><span class="line">    hasErrors = <span class="literal">false</span></span><br><span class="line">  links.forEach(<span class="function"><span class="params">link</span> =&gt;</span> &#123;</span><br><span class="line">    downloadQueue.pushTask(<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">      spider(link, nesting - <span class="number">1</span>, err =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          hasErrors = <span class="literal">true</span></span><br><span class="line">          <span class="keyword">return</span> callback(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++completed === links.length &amp;&amp; !hasErrors) &#123;</span><br><span class="line">          callback()</span><br><span class="line">        &#125;</span><br><span class="line">        done()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-async-library-async-库"><a href="#The-async-library-async-库" class="headerlink" title="The async library(async 库)"></a>The async library(async 库)</h2><h3 id="Sequential-execution-顺序执行-1"><a href="#Sequential-execution-顺序执行-1" class="headerlink" title="Sequential execution(顺序执行)"></a>Sequential execution(顺序执行)</h3><p><code>async</code> 库可以在实现复杂的异步控制流程时很大程度上帮助我们，但是选择正确的方法来处理具体问题是一个问题。顺序执行就有大约有 20 种方法，<code>eachSeries()</code>, <code>mapSeries()</code>, <code>filterSeries()</code>等等。</p><h4 id="Sequential-execution-of-a-known-set-of-tasks-已知任务的顺序执行"><a href="#Sequential-execution-of-a-known-set-of-tasks-已知任务的顺序执行" class="headerlink" title="Sequential execution of a known set of tasks(已知任务的顺序执行)"></a>Sequential execution of a known set of tasks(已知任务的顺序执行)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.series(tasks, [callback])</span><br></pre></td></tr></table></figure><p><code>series</code> 顺序执行一组任务，在所有任务调用回调函数 <code>callback</code>。而每一个 <code>task</code> 只是个接受回调函数的函数 <code>function task(callback) {}</code>，当某一个任务回调时发送了错误，那么 <code>async</code> 会停止后面的任务，直接到最后的回调函数。</p><h4 id="Sequential-iteration-顺序迭代-1"><a href="#Sequential-iteration-顺序迭代-1" class="headerlink" title="Sequential iteration(顺序迭代)"></a>Sequential iteration(顺序迭代)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.eachSeries(iterable, fn(item, callback), [callback])</span><br></pre></td></tr></table></figure><p>遍历一个可遍历的对象，顺序执行每一个元素对应的函数，所有元素对应的函数执行完后调用最后的回调函数。</p><h3 id="Parallel-execution-并行执行-1"><a href="#Parallel-execution-并行执行-1" class="headerlink" title="Parallel execution(并行执行)"></a>Parallel execution(并行执行)</h3><p><code>each()</code>，<code>map()</code>，<code>filter()</code>，<code>reject()</code>，<code>detect()</code>，<code>some()</code>，<code>every()</code>，<code>concat()</code>，<code>parallel()</code>，<code>applyEach()</code> 和 <code>times()</code> 都是并行执行的 <code>async</code> 的方法。</p><h3 id="Limited-parallel-execution-限制并行执行"><a href="#Limited-parallel-execution-限制并行执行" class="headerlink" title="Limited parallel execution(限制并行执行)"></a>Limited parallel execution(限制并行执行)</h3><p>类似于 <code>async.queue(worker, concurrency)</code> 来限制同时执行的任务数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Asynchorous-Control-Flow-Patterns-with-Callbacks-使用回调的异步控制流模式&quot;&gt;&lt;a href=&quot;#Asynchorous-Control-Flow-Patterns-with-Callbacks-使用回调的异步控制流模式&quot; class=&quot;headerlink&quot; title=&quot;Asynchorous Control Flow Patterns with Callbacks(使用回调的异步控制流模式)&quot;&gt;&lt;/a&gt;Asynchorous Control Flow Patterns with Callbacks(使用回调的异步控制流模式)&lt;/h1&gt;&lt;p&gt;异步的代码使得难以预测语句的执行顺序，所以在一些场景(比如遍历一些文件，执行一系列任务等等)下，这就要求开发者去使用一些方法或技术来防止编写出低效和难以阅读的代码。&lt;/p&gt;
&lt;h2 id=&quot;The-difficulties-of-asynchonous-programming-异步编程的困难&quot;&gt;&lt;a href=&quot;#The-difficulties-of-asynchonous-programming-异步编程的困难&quot; class=&quot;headerlink&quot; title=&quot;The difficulties of asynchonous programming(异步编程的困难)&quot;&gt;&lt;/a&gt;The difficulties of asynchonous programming(异步编程的困难)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;KISS&lt;/code&gt; 原则：Keep It Simple, Stupid，注重简约。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://1016990109.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关系型数据库存储树形结构</title>
    <link href="http://1016990109.github.io/2018/06/05/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/"/>
    <id>http://1016990109.github.io/2018/06/05/关系型数据库存储树形结构/</id>
    <published>2018-06-05T08:05:34.000Z</published>
    <updated>2018-06-06T11:40:05.005Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中不免遇到需要在关系型数据库中存储树形结构数据的情况，这里介绍 3 种存储方法。</p><p>三种方法都以下面这个嵌套评论场景为背景。</p><a id="more"></a><p><img src="/assets/img/comment-hierarchy.png" alt="comment-hierarchy"></p><h2 id="Adjacency-model-邻接模型"><a href="#Adjacency-model-邻接模型" class="headerlink" title="Adjacency model(邻接模型)"></a>Adjacency model(邻接模型)</h2><p>这是最常见最简单的存储树形结构的方法了。每个元素都持有对父节点的引用作为外键(图中<code>PK</code>为主键，<code>FK</code>为外键)，是一个一对多的关系:</p><p><img src="/assets/img/adjacency-model.jpg" alt="Adjacency model"></p><h3 id="添加-修改"><a href="#添加-修改" class="headerlink" title="添加/修改"></a>添加/修改</h3><p>添加和删除只要操作 <code>parent_id</code> 就可以了，添加到某节点就把 <code>parent_id</code> 设为该节点 <code>id</code>，从某节点下移动到另一个节点只要把 <code>parent_id</code> 更换为其他节点的 <code>id</code> 就可以了。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用 <code>parent-child</code> 方法需要删除节点就是比较复杂的了，因为不能简单地删除一个节点，这样属于该节点的子节点会找不到父节点，故而会出现一些问题，所以为了保持正确性得同时删除该节点的子节点。一种常见的做法是不直接删除该节点，而是标记该节点为删除状态，然后递归向下直到所有的后代都已经标记为删除了。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询直接的父节点或者子节点是非常容易的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- query a node's children</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> comments c1</span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> comments c2</span><br><span class="line">    <span class="keyword">on</span> (c2.parent_id = c1.id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- query a node's parent</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> comments c1</span><br><span class="line">  <span class="keyword">join</span> comments c2</span><br><span class="line">    <span class="keyword">on</span> (c1.parent_id = c2.id)</span><br></pre></td></tr></table></figure><p>但是查询一颗子树的时候就比较麻烦了，这就需要递归查询，在性能上是很大的挑战。实现的方式有两种：</p><ul><li>自顶向下查询，<code>connect by</code> 语法，这种方式较为简洁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- query a node's subtree</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> comments</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="keyword">id</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> parent_id = <span class="keyword">prior</span> <span class="keyword">id</span></span><br><span class="line"><span class="comment">-- query a node's parent is the same</span></span><br></pre></td></tr></table></figure><ul><li><p>递归实现</p><p>1.第一步定义起始的点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="number">0</span> <span class="keyword">as</span> <span class="keyword">depth</span>,</span><br><span class="line">  <span class="keyword">id</span>,</span><br><span class="line">  <span class="keyword">comment</span>,</span><br><span class="line">  parent_id</span><br><span class="line"><span class="keyword">from</span> comments</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>2.第二步定义每个子行与父节点之间关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  parent.depth + <span class="number">1</span>,</span><br><span class="line">  child.id,</span><br><span class="line">  child.comment,</span><br><span class="line">  child.parent_id</span><br><span class="line"><span class="keyword">from</span> recursive_query <span class="keyword">parent</span>, comments <span class="keyword">child</span></span><br><span class="line"><span class="keyword">where</span> parent.id = child.parent_id</span><br></pre></td></tr></table></figure><p>3.结合 1 2 步</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">with recursive_query(depth, id, <span class="keyword">comment</span>, parent_id)</span><br><span class="line"><span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="number">0</span> <span class="keyword">as</span> <span class="keyword">depth</span>,</span><br><span class="line">  <span class="keyword">id</span>,</span><br><span class="line">  <span class="keyword">comment</span>,</span><br><span class="line">  parent_id</span><br><span class="line"><span class="keyword">from</span> comments</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">union</span> all</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  parent.depth + <span class="number">1</span>,</span><br><span class="line">  child.id,</span><br><span class="line">  child.comment,</span><br><span class="line">  child.parent_id</span><br><span class="line"><span class="keyword">from</span> recursive_query <span class="keyword">parent</span>, comments <span class="keyword">child</span></span><br><span class="line"><span class="keyword">where</span> parent.id = child.parent_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> recursive_query</span><br></pre></td></tr></table></figure></li></ul><h3 id="元素数量和嵌套的层级"><a href="#元素数量和嵌套的层级" class="headerlink" title="元素数量和嵌套的层级"></a>元素数量和嵌套的层级</h3><p>理论上元素数量和层级没有限制，可以有无数层。</p><h2 id="Materialized-Path-物化路径"><a href="#Materialized-Path-物化路径" class="headerlink" title="Materialized Path(物化路径)"></a>Materialized Path(物化路径)</h2><p>使用每个节点都存储祖先链的方式实现树的存储，这种方式很容易实现面包屑导航。</p><p><img src="/assets/img/materialized-path.png" alt="materialized path"></p><h3 id="添加-修改-1"><a href="#添加-修改-1" class="headerlink" title="添加/修改"></a>添加/修改</h3><p>添加一个节点，需要先获得父节点的 <code>path</code>，再在此基础上加上新节点的 <code>id</code> 组成新的 <code>path</code>来完成添加操作。</p><p>修改的话会更麻烦一点，需要更新该节点的 <code>path</code> 以及它的所有后代的 <code>path</code>。</p><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>简单删除一个节点并不破坏整棵树的完整性，该节点的子节点虽然没有父级节点，但是有爷爷辈节点。</p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>查询一个节点下面的子树是非常容易的，直接 <code>path like &#39;{node&#39;s path}%&#39;</code> 就能选出来了，而不需要递归。</p><h3 id="元素数量和嵌套的层级-1"><a href="#元素数量和嵌套的层级-1" class="headerlink" title="元素数量和嵌套的层级"></a>元素数量和嵌套的层级</h3><p>元素的数量和嵌套的层级大小是取决于开发者的，事实上很少是需要无限的层级的：如果网站嵌套层级超过 20 层，那需要考虑重新设计了而不是盲目地增加层级了。</p><p>该模式的实现方式可以有很多种，比如点分割(<code>1.1.2.5</code>)或者斜杠分割(<code>boss/chapter1/section2</code>)，有时候规定一层的字符数量，空出来的空间用特殊字符填充(比如说<code>0</code>)，就像 <code>000100020005</code> 就表示 <code>1/2/5</code> 中间用 <code>0</code> 填充，这样每一层元素数量最多就 <code>10^4</code> 个了(规定只能是数字)，而如果整个 <code>path</code> 的长度再有限制(比如说 20)，那么自然嵌套的层级也有限制了(这里是 5 层)。</p><p>所以说这些都是取决于是如何设计的。</p><h2 id="Nested-Sets-嵌套集合"><a href="#Nested-Sets-嵌套集合" class="headerlink" title="Nested Sets(嵌套集合)"></a>Nested Sets(嵌套集合)</h2><p>先上一张图来理解这个模型：</p><p><img src="/assets/img/nested-sets.png" alt="Nested Sets"></p><p>可以看到每个节点都有一个 <code>left</code> 和一个 <code>right</code>，这是代表这个节点所能容纳的范围的，一个节点的 <code>left</code> 比它所有后代的 <code>left</code> 要小，一个节点的 <code>right</code> 比它所有后代的 <code>right</code> 要大。</p><h3 id="添加-修改-2"><a href="#添加-修改-2" class="headerlink" title="添加/修改"></a>添加/修改</h3><p>添加和修改是十分复杂的，都需要重新计算节点的 <code>left</code> 与 <code>right</code>。</p><p>拿添加来说，比如给上图中第 5 个节点(它的<code>left</code>为<code>left-5</code>，<code>right</code>为<code>right-5</code>)添加子节点，那么需要做的就是把 <code>right</code> 大或等于 <code>right-5</code> 的节点都取出来，如果 <code>left</code> 大于或等于 <code>right-5</code> 那么就加 2，否则不变；<code>right</code> 全部都加 2；然后把新的节点 <code>left</code> 设为 <code>right-5</code>，<code>right</code> 设为 <code>right-5 + 1</code>，如下图：</p><p><img src="/assets/img/nested-sets-add.png" alt="Nested Sets add new node"></p><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p>同样的删除也是非常复杂的，这也需要重新计算 <code>left</code> 和 <code>right</code>。</p><h3 id="查询-2"><a href="#查询-2" class="headerlink" title="查询"></a>查询</h3><p>查询一颗子树是非常方便的，只需要找出所有的 <code>left</code> 比该节点大，<code>right</code> 比该节点小的所有节点就可以了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> comments</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">left</span> &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">right</span> &lt; <span class="number">14</span></span><br></pre></td></tr></table></figure><h3 id="元素数量和嵌套的层级-2"><a href="#元素数量和嵌套的层级-2" class="headerlink" title="元素数量和嵌套的层级"></a>元素数量和嵌套的层级</h3><p>和邻接链表一样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>模型</th><th>查询子节点</th><th>查询子树</th><th>删除节点</th><th>插入节点</th><th>移动子树</th></tr></thead><tbody><tr><td>Adjacency List</td><td>易</td><td>难(递归还好，相对耗时)</td><td>易</td><td>易</td><td>易</td></tr><tr><td>Materialized Path</td><td>难</td><td>易</td><td>易</td><td>易</td><td>易(但耗时)</td></tr><tr><td>Nested Sets</td><td>难</td><td>易</td><td>难</td><td>难</td><td>难</td></tr></tbody></table><p>邻接链表是较为简单的一种实现，但是想要查询一颗树的时候会有很多阻力，如 <code>Mysql 8.0</code> 以下原生是不支持递归查询的(可以自定义函数来完成这个递归操作，详情看<a href="https://explainextended.com/2009/03/17/hierarchical-queries-in-mysql" target="_blank" rel="noopener">这里</a>)，但是 <code>Oracle</code>、<code>PostgreSQL</code>、<code>SQL Server</code> 是支持的，除此之外，查询子树时存在查询效率问题(因为需要递归)。所以当你使用的场景插入或更新或删除较多的话是最好选择邻接链表模型的。如果查询树特别多，则可以使用嵌套集合模型或者物化路径模型(物化路径模型当层次较深的时候额外存储空间较大需谨慎)较为合适，当然如果使用的数据库原生支持递归语法，那么使用邻接链表模型也未尝不可，只是性能上会差一点。</p><p>总之还是根据具体情况具体分析，选择合适的才是最好的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中不免遇到需要在关系型数据库中存储树形结构数据的情况，这里介绍 3 种存储方法。&lt;/p&gt;
&lt;p&gt;三种方法都以下面这个嵌套评论场景为背景。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://1016990109.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数据库" scheme="http://1016990109.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>git-flow 学习</title>
    <link href="http://1016990109.github.io/2018/06/05/Git-Flow-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://1016990109.github.io/2018/06/05/Git-Flow-学习/</id>
    <published>2018-06-05T01:35:26.000Z</published>
    <updated>2018-06-05T07:26:25.776Z</updated>
    
    <content type="html"><![CDATA[<p>这里只是针对 <code>Git</code> 中的 <code>git-flow</code> 做一次学习记录，更加详细系统地学习 <code>Git</code> 请移步<a href="https://www.git-tower.com/learn/git/ebook" target="_blank" rel="noopener">这里</a>。</p><p>首先，<code>git-flow</code> 并不会为 <code>Git</code> 扩展任何新的功能，它仅仅使用了脚本来捆绑了一系列 <code>Git</code> 命令来完成一些特定的工作流程。</p><p>其次，定义一个固定的工作流程会使得团队协作更加简单容易。无论是一个 “版本控制的新手” 还是 “Git 专家”，每一个人都知道如何来正确地完成某个任务。</p><a id="more"></a><p>本文使用的工具是比较常用的 <a href="https://github.com/petervanderdoes/gitflow/" target="_blank" rel="noopener">gitflow-avh</a>。</p><h2 id="分支的模式"><a href="#分支的模式" class="headerlink" title="分支的模式"></a>分支的模式</h2><p><code>git-flow</code> 模式会预设两个主分支在仓库中：</p><ul><li><code>master</code>:正式发布的产品代码</li><li><code>develop</code>:开发用分支</li></ul><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>看下图：</p><p><img src="/assets/img/git-flow.png" alt="git-flow"></p><ol><li>先开发功能，可能是一个也可能是多个，功能分支为 <code>feature</code>，功能开发完并合并后会删除。</li><li>功能开发完后都合并到 <code>develop</code> 分支进行汇总。</li><li>所有功能开发完后，需要发布一个版本。开出一个 <code>release</code> 分支，进行分支的最后修改，如代码中某些版本号等等。然后将 <code>release</code> 分支同时合并到 <code>master</code> 和 <code>develop</code> 分支，并打上相应的 <code>tag</code>，删除该 <code>release</code> 分支，完成一次迭代。</li><li>代码运行在 <code>master</code> 上一段时间后可能会有 <code>bug</code>，这时候开出 <code>hotfix</code> 分支对 <code>bug</code> 进行修复，修复完成后将代码合并到 <code>master</code> 和 <code>develop</code> 分支，打上修复的 <code>tag</code>，删除 <code>hotfix</code> 分支，一次在已发布版本上的修复就完成了。</li></ol><blockquote><p>注意：操作完后记得 <code>push</code> 哦！(<code>tag</code> 通过 <code>push</code> 是不会推送到远端仓库的，需要 <code>git push orign --tags</code> 推送所有 <code>tag</code>。)</p></blockquote><h2 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h2><p>让我们开始开发一个新功能 “rss-feed”：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git flow feature start rss-feed</span><br><span class="line">Switched to a new branch <span class="string">'feature/rss-feed'</span></span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- A new branch <span class="string">'feature/rss-feed'</span> was created, based on <span class="string">'develop'</span></span><br><span class="line">- You are now on branch <span class="string">'feature/rss-feed'</span></span><br></pre></td></tr></table></figure><p>经过一段时间艰苦地工作和一系列的聪明提交，我们的新功能终于完成了：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git flow feature finish rss-feed</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line">Updating 6bcf266..41748ad</span><br><span class="line">Fast-forward</span><br><span class="line">    feed.xml | 0</span><br><span class="line">    1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">    create mode 100644 feed.xml</span><br><span class="line">Deleted branch feature/rss-feed (was 41748ad).</span><br></pre></td></tr></table></figure><h2 id="管理-Releases"><a href="#管理-Releases" class="headerlink" title="管理 Releases"></a>管理 Releases</h2><p>当你认为现在在 “develop” 分支的代码已经是一个成熟的 <code>release</code> 版本时，这意味着：第一，它包括所有新的功能和必要的修复；第二，它已经被彻底的测试过了。如果上述两点都满足，那就是时候开始生成一个新的 <code>release</code> 了：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git flow release start 1.1.5</span><br><span class="line">Switched to a new branch <span class="string">'release/1.1.5'</span></span><br></pre></td></tr></table></figure><p>进行最后的编辑，然后完成：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish 1.1.5</span><br></pre></td></tr></table></figure><h2 id="hotfix"><a href="#hotfix" class="headerlink" title="hotfix"></a>hotfix</h2><p>很多时候，仅仅在几个小时或几天之后，当对 <code>release</code> 版本作做全面测试时，可能就会发现一些小错误。<br>在这种情况下，<code>git-flow</code> 提供一个特定的 “hotfix” 工作流程（因为在这里不管使用 “功能” 分支流程，还是 “release” 分支流程都是不恰当的）。</p><p>创建 <code>hotfix</code>：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git flow hotfix start missing-link</span><br></pre></td></tr></table></figure><p>修复完 <code>bug</code> 后就该完成了：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git flow hotfix finish missing-link</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>git-flow</code> 只是捆绑了一些命令来帮助用户来走这么一套通用的流程，当你能正确地理解工作流程的基本组成部分和目标的之后也可以不再使用这些工具了，可以根据自己的需要自定义流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里只是针对 &lt;code&gt;Git&lt;/code&gt; 中的 &lt;code&gt;git-flow&lt;/code&gt; 做一次学习记录，更加详细系统地学习 &lt;code&gt;Git&lt;/code&gt; 请移步&lt;a href=&quot;https://www.git-tower.com/learn/git/ebook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;首先，&lt;code&gt;git-flow&lt;/code&gt; 并不会为 &lt;code&gt;Git&lt;/code&gt; 扩展任何新的功能，它仅仅使用了脚本来捆绑了一系列 &lt;code&gt;Git&lt;/code&gt; 命令来完成一些特定的工作流程。&lt;/p&gt;
&lt;p&gt;其次，定义一个固定的工作流程会使得团队协作更加简单容易。无论是一个 “版本控制的新手” 还是 “Git 专家”，每一个人都知道如何来正确地完成某个任务。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://1016990109.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git" scheme="http://1016990109.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>5月28日学习笔记</title>
    <link href="http://1016990109.github.io/2018/05/28/5%E6%9C%8828%E6%97%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://1016990109.github.io/2018/05/28/5月28日学习笔记/</id>
    <published>2018-05-28T14:17:10.000Z</published>
    <updated>2018-05-28T14:51:41.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="该记录何种日志？"><a href="#该记录何种日志？" class="headerlink" title="该记录何种日志？"></a>该记录何种日志？</h3><ol><li>操作时间日志可能有些操作耗时会比较长，可以对方法的处理时间做个记录，例如数据库连接可能耗时很长（但是具体的数据库操作时间记录一般交由数据库本身来做，调用者也不可能知道一条语句耗费了多少时间）则需要记录，某些 <code>api</code> 也可能出现耗时长的问题，记录操作时长可有效发现问题。</li><li>异常日志程序在运行中抛出的异常，可以记录，方便定位错误。</li><li>调试日志有时候本地不方便调试可输出调试信息到日志，方便调试。</li></ol><a id="more"></a><h3 id="日志类型："><a href="#日志类型：" class="headerlink" title="日志类型："></a>日志类型：</h3><ol><li>时间日志这种日志一般按照时间成文件，记录每段时间的日志（错误日志只记录索引，错误信息等，不记录错误栈，是为了日志分析以及格式化）。</li><li>滚动日志滚动日志一般比较随意了，有调试的信息、错误栈、其他一些日志。</li></ol><h3 id="日志工具："><a href="#日志工具：" class="headerlink" title="日志工具："></a>日志工具：</h3><p><code>awk</code> 了解一下</p><h3 id="日志作用"><a href="#日志作用" class="headerlink" title="日志作用"></a>日志作用</h3><ul><li>记录重要信息，如错误、异常、警告等等</li><li>用户行为分析<br>例如将对某一数据连贯的一系列操作共同组成一组事务，一组事务中有多个行为，如用户id、数据id、session_id共同组成对一个数据的一组有关联的操作，可以用来分析用户操作数据的行为，有时候也可以通过行为记录来查找 <code>bug</code> 的原因。</li><li>统计<br>例如某某接口调用次数特别多，某某接口调用非常少等等统计工作。</li><li>调试<br>学会使用日志调试</li></ul><h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><p>何时使用参数校验？</p><ul><li>接口需要<br>如某个接口一定需要id字段才可以查询，则对id做一个校验。</li><li>性能需要<br>例如分页的时候，每页数据量过大的时候可能会影响接口的性能，这时候需要对参数做限制。<br>参数不合法就可以不进行处理，避免不必要的操作，提升性能。</li><li>数据库需要<br>数据最多支持32位长度的字符串，这时候提前做校验可以避免错误产生，也可以避免不必要操作提升性能。</li><li>业务需要<br>例如邮箱有固定的格式，可以对参数做验证。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>简洁不一定是对的，有时候更需要易懂。</p><p>一切的 <code>I/O</code> 操作都需要处理异常。</p><p>封装需要权衡易读性与一致性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h2&gt;&lt;h3 id=&quot;该记录何种日志？&quot;&gt;&lt;a href=&quot;#该记录何种日志？&quot; class=&quot;headerlink&quot; title=&quot;该记录何种日志？&quot;&gt;&lt;/a&gt;该记录何种日志？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;操作时间日志可能有些操作耗时会比较长，可以对方法的处理时间做个记录，例如数据库连接可能耗时很长（但是具体的数据库操作时间记录一般交由数据库本身来做，调用者也不可能知道一条语句耗费了多少时间）则需要记录，某些 &lt;code&gt;api&lt;/code&gt; 也可能出现耗时长的问题，记录操作时长可有效发现问题。&lt;/li&gt;
&lt;li&gt;异常日志程序在运行中抛出的异常，可以记录，方便定位错误。&lt;/li&gt;
&lt;li&gt;调试日志有时候本地不方便调试可输出调试信息到日志，方便调试。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习" scheme="http://1016990109.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="随笔" scheme="http://1016990109.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 探索</title>
    <link href="http://1016990109.github.io/2018/05/22/dubbo%E6%8E%A2%E7%B4%A2/"/>
    <id>http://1016990109.github.io/2018/05/22/dubbo探索/</id>
    <published>2018-05-22T03:09:44.000Z</published>
    <updated>2018-06-06T14:18:50.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo-框架的介绍以及源码阅读"><a href="#Dubbo-框架的介绍以及源码阅读" class="headerlink" title="Dubbo 框架的介绍以及源码阅读"></a>Dubbo 框架的介绍以及源码阅读</h1><h2 id="Dubbo-简介"><a href="#Dubbo-简介" class="headerlink" title="Dubbo 简介"></a>Dubbo 简介</h2><p><code>Apache Dubbo|ˈdʌbəʊ|</code> 是阿里开源的一个 RPC 框架。</p><p>和大多数 <code>RPC</code> 系统一样， <code>dubbo</code> 基于一个理念：定义一个服务，确定远程调用的方法，并且包含他们的参数和返回类型。在服务端，服务器实现接口并且运行一个 <code>dubbo</code> 的服务来处理来自客户端的请求；在客户端，客户端持有提供与服务端方法一模一样的桩。</p><a id="more"></a><p><img src="/assets/img/dubbo_architecture.png" alt="dubbo 架构"></p><p><code>Apache Dubbo(incubating)</code>提供三个关键的功能:</p><ul><li>基于接口的远程调用</li><li>错误容忍和负载均衡</li><li>自动化服务注册和发现</li></ul><p>详细的架构描述请查看<a href="http://dubbo.apache.org/books/dubbo-user-book/preface/architecture.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="Dubbo-实现"><a href="#Dubbo-实现" class="headerlink" title="Dubbo 实现"></a>Dubbo 实现</h2><h3 id="Dubbo-接入-spring"><a href="#Dubbo-接入-spring" class="headerlink" title="Dubbo 接入 spring"></a>Dubbo 接入 spring</h3><p><code>spring</code> 可以在 <code>xml</code> 中做一些配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.demo.dubbo.server.serviceimpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对于上述的 xml 配置，分成三个部分:</p><ul><li>命名空间 <code>namespace</code>，如 <code>context</code></li><li>元素 <code>element</code>，如 <code>component-scan</code></li><li>属性 <code>attribute</code>，如 <code>base-package</code></li></ul><p><code>spring</code> 定义了两个接口，来分别解析上述内容：</p><ul><li><code>NamespaceHandler</code>：注册了一堆 <code>BeanDefinitionParser</code>，利用他们来进行解析</li><li><code>BeanDefinitionParser</code>: 用于解析每个 <code>element</code> 的内容</li></ul><p><code>spring</code> 会从 <code>jar</code> 包下的 <code>META-INF/spring.handlers</code> 文件下寻找 <code>NamespaceHandler</code>，所以如果需要自定义配置，只需要在 <code>jar</code> 包下加入 <code>META-INF/spring.handlers</code> 文件，其中记录 <code>NamespaceHandler</code> 的实现类，<code>dubbo</code> 的 <code>spring.handlers</code> 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http\://dubbo.apache.org/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br><span class="line">http\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure><p>然后不同的配置分别转换成 <code>spring</code> 容器中的一个 <code>bean</code> 对象：</p><ul><li><code>application</code> 对应 <code>ApplicationConfig</code></li><li><code>registry</code> 对应 <code>RegistryConfig</code></li><li><code>monitor</code> 对应 <code>MonitorConfig</code></li><li><code>provider</code> 对应 <code>ProviderConfig</code></li><li><code>consumer</code> 对应 <code>ConsumerConfig</code></li><li><code>protocol</code> 对应 <code>ProtocolConfig</code></li><li><code>service</code> 对应 <code>ServiceBean</code>(继承 <code>ServiceConfig</code>)</li><li><code>reference</code> 对应 <code>ReferenceBean</code>(继承 <code>ReferenceConfig</code>)</li></ul><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p><code>Invoker</code> 是实体域，它是 <code>Dubbo</code> 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 <code>invoke</code> 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>Invocation</code> 则包含了需要执行的方法、参数等信息，接口定义简略如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] getParameterTypes();</span><br><span class="line"></span><br><span class="line">Object[] getArguments();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布服务"><a href="#发布服务" class="headerlink" title="发布服务"></a>发布服务</h3><p><img src="/assets/img/dubbo_rpc_export.jpg" alt="dubbo rpc export"></p><p><code>ServiceConfig</code> 通过配置文件拿到对外提供服务的实现类 <code>ref</code>(如：<code>DemoServiceImpl</code>),然后通过 <code>ProxyFactory</code> 的 <code>getInvoker</code> 方法根据 <code>ref</code> 生成一个 <code>AbstractProxyInvoker</code> 实例，然后在通过 <code>Protocol</code> 的 <code>export</code> 方法将 <code>Invoker</code>  转换为 <code>Exporter</code>。</p><p>这里举一个将 <code>Invoker</code> 转为 <code>Exporter</code> 的例子，<code>DubboProtocol</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProxyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// export service.</span></span><br><span class="line">        String key = serviceKey(url);</span><br><span class="line">        DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费服务"><a href="#消费服务" class="headerlink" title="消费服务"></a>消费服务</h3><p><img src="/assets/img/dubbo_rpc_refer.jpg" alt="dubbo rpc refer"></p><p><code>ReferenceConfig</code> 类的 <code>init</code> 方法调用 <code>Protocol</code> 的 <code>refer</code> 方法生成 <code>Invoker</code> 实例(如上图中的红色部分)，这是服务消费的关键。接下来把 <code>Invoker</code> 转换为客户端需要的接口(如<code>DemoService</code>)。而客户端需要调用的时候只需要调用这个接口(如<code>DemoService</code>)，就能够间接使用 <code>Invoker</code> 来调用远程的方法。</p><h3 id="Invoke-的过程"><a href="#Invoke-的过程" class="headerlink" title="Invoke 的过程"></a>Invoke 的过程</h3><p><img src="/assets/img/dubbo_rpc_invoke.jpg" alt="dubbo rpc invoke"></p><!-- #### 远程过程调用总结总的来看，可以将 `dubbo` 中的远程过程调用总结为：服务端根据读取的配置将接口一个个封装起来并暴露(`Exporter`)，启动服务并遵守定义的协议；客户端通过配置文件的配置，接着根据定义的协议生成对应的调用者(`Invoker`)，调用者中隐藏了真正的远程调用细节，之后便可以通过调用者调用远程的方法了。例如，通过 `dubbo://11.240.240.118:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=11.240.240.118&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=34270&qos.port=22222&side=provider&timestamp=1527037622366` 可以发现，服务器提供一个 `DemoService` 的接口，和一个 `sayHello` 的方法；通过 `dubbo://11.240.240.118:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=34452&qos.port=33333&register.ip=11.240.240.118&remote.timestamp=1527037622366&side=consumer&timestamp=1527038134040` 客户端拿到对应的可调用的接口 `DemoService`，然后调用 `DemoService` 中的方法(`sayHello`)，接着调用到客户端的 `Invoker`(这里为`DubboInvoker`)，`Invoker` 再根据协议将包装的信息传递到服务器，服务器解析信息找到对应的 `Exporter`，再找到 `AbstractProxyInvoker` 的实例，然后成功调用接口的实现类 `DemoServiceImpl`，完成调用，这就是整个过程。 --><h3 id="扩展点加载"><a href="#扩展点加载" class="headerlink" title=" 扩展点加载"></a> 扩展点加载</h3><p><code>Dubbo</code> 的扩展点加载从 <code>JDK</code> 标准的 <code>SPI</code> (Service Provider Interface) 扩展点发现机制加强而来。</p><p>传统的 <code>SPI</code> 发现机制是根据在 <code>jar</code> 包中的 <code>META-INF/services/</code> 配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk 提供服务实现查找的一个工具类： <code>java.util.ServiceLoader</code>。</p><h4 id="Dubbo-的-ExtensionLoader-解析扩展过程"><a href="#Dubbo-的-ExtensionLoader-解析扩展过程" class="headerlink" title="Dubbo 的 ExtensionLoader 解析扩展过程"></a>Dubbo 的 ExtensionLoader 解析扩展过程</h4><p><code>jdk</code> 使用 <code>ServiceLoader</code>， <code>Dubbo</code> 使用<code>com.alibaba.dubbo.common.extension.ExtensionLoader</code> 来提供服务实现查找，<code>ExtensionLoader</code> 注入的依赖扩展点是一个 <code>Adaptive</code> 实例，直到扩展点方法执行时才决定调用是一个扩展点实现。</p><p>以下面例子为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; protocolLoader=ExtensionLoader.getExtensionLoader(Protocol.class);</span><br><span class="line">Protocol  protocol=protocolLoader.getAdaptiveExtension();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Extension</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">&lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据要加载的接口创建出一个 ExtensionLoader 实例，然后再获取自适应的 <code>Protocol</code> 实现类(<code>DubboProtocol$Adaptive</code>)。</p><p><code>getAdaptiveExtension</code> 会根据 <code>@Adaptive</code> 注解去动态生成 <code>DubboProtocol$Adaptive</code> 实例， <code>DubboProtocol$Adaptive</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(com.alibaba.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"com.alibaba.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在使用过程中，如 <code>export()</code> 方法在调用过程中或通过 <code>ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName)</code> 来获取到真正的实例再进行调用，这就保证了在真正调用之前，实例是不会被真正创建的(只创建了对应的<code>Adaptive</code>实例)，如果有扩展实现初始化很耗时，没用上也不会加载，从而减少资源浪费。</p><h4 id="ExtensionLoader-实例是如何来加载-Protocol-的实现类的："><a href="#ExtensionLoader-实例是如何来加载-Protocol-的实现类的：" class="headerlink" title="ExtensionLoader 实例是如何来加载 Protocol 的实现类的："></a>ExtensionLoader 实例是如何来加载 Protocol 的实现类的：</h4><p>1.先解析 Protocol 上的 Extension 注解的 name,存至 String cachedDefaultName 属性中，作为默认的实现</p><p>2.到类路径下的加载所有的 META-INF/dubbo.interval.com.alibaba.dubbo.rpc.Protocol 文件，例如 <code>dubbo-rpc-dubbo</code> 模块下的 Protocol 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br></pre></td></tr></table></figure><p>然后读取内容加载对应的 <code>class</code>(<code>DubboProtocol</code>)，并和对应的 <code>name</code>(上面<code>=</code>前面的字符<code>dubbo</code>) 做关联，为以后根据 <code>name</code> 找具体实现类做铺垫。</p><h4 id="ExtensionLoader-获取扩展过程"><a href="#ExtensionLoader-获取扩展过程" class="headerlink" title="ExtensionLoader 获取扩展过程"></a>ExtensionLoader 获取扩展过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance(name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                type + <span class="string">")  could not be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致分成 4 步：</p><p>1.根据 name 获取对应的 class</p><p>2.根据获取到的 class 创建一个实例</p><p>3.对获取到的实例，进行依赖注入</p><p>4.对于上述经过依赖注入的实例，再次进行包装，实现 <code>AOP</code>。以 <code>Protocol</code> 为例，<code>ProtocolFilterWrapper</code>、<code>ProtocolListenerWrapper</code> 会对 <code>DubboProtocol</code> 进行包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxProtocolWrapper</span> <span class="title">implemenets</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    Protocol impl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XxxProtocol</span><span class="params">(Protocol protocol)</span> </span>&#123; impl = protocol; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口方法做一个操作后，再调用extension的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... 一些操作</span></span><br><span class="line">        impl.refer();</span><br><span class="line">        <span class="comment">// ... 一些操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个扩展点可以直接-setter-注入其它扩展点"><a href="#一个扩展点可以直接-setter-注入其它扩展点" class="headerlink" title="一个扩展点可以直接 setter 注入其它扩展点"></a>一个扩展点可以直接 <code>setter</code> 注入其它扩展点</h4><p>对应的处理在 <code>ExtensionLoader</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"fail to inject via method "</span> + method.getName()</span><br><span class="line">                                + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dubbo-通信"><a href="#Dubbo-通信" class="headerlink" title="Dubbo 通信"></a>Dubbo 通信</h3><p><code>Dubbo</code> 已经集成的有 <code>Netty</code>、<code>Mina</code>，默认是 <code>Netty</code>，这里主要介绍 <code>Netty</code>。</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p><code>Netty</code> 使用 <code>Reactor</code> 主从模型结构(三种 <code>Reactor</code> 模型详情请看<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">这里</a>)的变种:</p><p><img src="/assets/img/reactor3.png" alt="reactor3"></p><p>去掉上面的线程池就为 <code>Netty</code> 的默认模式了。</p><p><code>Netty</code> 里对应 <code>mainReactor</code> 的角色叫做 <code>Boss</code>，而对应 <code>subReactor</code> 的角色叫做 <code>Worker</code>。<code>Boss</code> 负责分配请求，创建 Selector，用于不断监听 Socket 连接、客户端的读写操作等；<code>Worker</code> 负责执行，负责处理 Selector 派发的读写操作。</p><p><code>Netty</code> 中 <code>Reactor</code> 模式的参与者主要有下面一些组件：</p><p><img src="/assets/img/reactor.jpg" alt="reactor"></p><ul><li><code>Selector</code>(对应多路复用器 <code>Demultiplexer</code>)</li><li><code>EventLoopGroup/EventLoop</code>(对应 <code>Reactor</code> 模式中的分发者 <code>Dispatcher</code>)</li><li><code>ChannelPipeline</code>(对应请求处理器 <code>Handler</code>，真正干活的)</li></ul><p>不管是 <code>Boos</code> 线程还是 <code>Worker</code> 线程，所做的事情均分为以下三个步骤: </p><ol><li>轮询注册在 <code>selector</code> 上的 <code>I/O</code> 事件 </li><li>处理 <code>I/O</code> 事件 </li><li>执行异步 <code>task</code></li></ol><p>对于 <code>Boos</code> 线程来说，第一步轮询出来的基本都是 <code>accept</code> 事件，表示有新的连接，而 <code>Worker</code> 线程轮询出来的基本都是 <code>read/write</code> 事件，表示网络的读写事件。</p><p>新连接的建立 </p><ol><li><code>Boss</code> 的 <code>Selector</code> 检测到有新的连接 </li><li>将新的连接注册到 <code>Worker</code> 线程组 </li><li>注册新连接的读事件到 <code>Worker</code> 的 <code>Selector</code> 中</li></ol><p>新连接的读取和请求处理</p><ol><li>数据准备好了</li><li><code>Worker</code> 知道了，同步调用 <code>unsafe.read</code> 获得客户端传输的数据，交给 <code>ChannelPipeline</code> 处理</li><li><code>ChannelPipeline</code> 处理，<code>decode</code> -&gt; 处理数据 -&gt; <code>encode</code> 结果，这些过程都是异步的</li><li>用户调用 <code>channel.writeAndFlush</code>，写就绪</li><li><code>Worker</code> 知道了，<code>unsafe.forceflush</code> 写回结果给客户端</li></ol><p><code>ChannelPipeline</code> 处理过程类似下面这样，一般会有 <code>decode</code>，用户自定义的 <code>handler</code>，和 <code>encode</code>：</p><p><img src="/assets/img/netty_pipeline.png" alt="netty pipeline"></p><p><code>ChannelInBoundHandler</code> 对从客户端发往服务器的报文进行处理，一般用来执行拆包/粘包，解码，读取数据，业务处理等；<code>ChannelOutBoundHandler</code> 对从服务器发往客户端的报文进行处理，一般用来进行编码，发送报文到客户端。</p><h4 id="编码与解码-序列化与反序列化"><a href="#编码与解码-序列化与反序列化" class="headerlink" title="编码与解码(序列化与反序列化)"></a>编码与解码(序列化与反序列化)</h4><p>想要远程传输对象就得将对象变为二进制码，这就需要序列化工具来完成这些操作。</p><p>在 <code>Dubbo</code>中，同时支持多种序列化方式，例如：</p><ol><li><code>dubbo</code> 序列化：阿里尚未开发成熟的高效 <code>java</code> 序列化实现，阿里不建议在生产环境使用它</li><li><code>hessian2</code> 序列化：<code>hessian</code> 是一种跨语言的高效二进制序列化方式。</li><li><code>json</code> 序列化：目前有两种实现，一种是采用的阿里的 <code>fastjson</code> 库，另一种是采用 <code>Dubbo</code> 中自己实现的简单 <code>json</code> 库，但其实现都不是特别成熟，而且 <code>json</code> 这种文本序列化性能一般不如上面两种二进制序列化。</li><li><code>java</code> 序列化：主要是采用 <code>JDK</code> 自带的 <code>Java</code> 序列化实现，性能很不理想。</li></ol><p><code>Dubbo</code> 默认是使用 <code>Hessian</code> 作为序列化与反序列化的工具的，<code>Hessian</code> 的序列化语法看<a href="http://hessian.caucho.com/doc/hessian-serialization.html" target="_blank" rel="noopener">这里</a>。</p><p><strong>与跨平台的 <code>protobuf</code> 对比：</strong></p><ol><li><code>protobuf</code> 相比于 <code>hessian</code> 而言是要定义消息类型的，客户端与服务器都需要定义相同的消息类型(<code>.proto</code>文件)，配置方面较复杂，但是相应的消息的压缩率也就更高了，<code>protobuf</code> 存储类型只需要一个字节(8位)，即前5位代表顺序，后3位代表 <code>type</code>，更具体的 <code>protobuf</code> 的编码规则请看<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">官方文档</a>；而 <code>hessian</code> 则会把类型的全量名称都加上，因而效率会稍微低一点，具体的 <code>hessian</code> 编码规则请看<a href="http://hessian.caucho.com/doc/hessian-serialization.html" target="_blank" rel="noopener">官方文档</a>。所以如果对性能要求不是特别高(如即时消息系统，如QQ等)，而且是使用 <code>java</code> 编写的系统而言，用 <code>hessian</code> 就足够了，这就是 <code>Dubbo</code> 默认使用 <code>hessian</code> 的原因吧。</li><li><code>hessian</code> 一般是用于 <code>java</code> 平台的，<code>protobuf</code> 是跨平台的。</li><li><code>protobuf</code> 比 <code>hessian</code> 压缩率、速率更高。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dubbo-框架的介绍以及源码阅读&quot;&gt;&lt;a href=&quot;#Dubbo-框架的介绍以及源码阅读&quot; class=&quot;headerlink&quot; title=&quot;Dubbo 框架的介绍以及源码阅读&quot;&gt;&lt;/a&gt;Dubbo 框架的介绍以及源码阅读&lt;/h1&gt;&lt;h2 id=&quot;Dubbo-简介&quot;&gt;&lt;a href=&quot;#Dubbo-简介&quot; class=&quot;headerlink&quot; title=&quot;Dubbo 简介&quot;&gt;&lt;/a&gt;Dubbo 简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Apache Dubbo|ˈdʌbəʊ|&lt;/code&gt; 是阿里开源的一个 RPC 框架。&lt;/p&gt;
&lt;p&gt;和大多数 &lt;code&gt;RPC&lt;/code&gt; 系统一样， &lt;code&gt;dubbo&lt;/code&gt; 基于一个理念：定义一个服务，确定远程调用的方法，并且包含他们的参数和返回类型。在服务端，服务器实现接口并且运行一个 &lt;code&gt;dubbo&lt;/code&gt; 的服务来处理来自客户端的请求；在客户端，客户端持有提供与服务端方法一模一样的桩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://1016990109.github.io/tags/java/"/>
    
      <category term="RPC" scheme="http://1016990109.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第二章</title>
    <link href="http://1016990109.github.io/2018/05/18/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/05/18/Node-js-设计模式读书笔记-第二章/</id>
    <published>2018-05-18T08:51:57.000Z</published>
    <updated>2018-06-05T01:32:15.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js-Essential-Patterns-Node-js-基本模式"><a href="#Node-js-Essential-Patterns-Node-js-基本模式" class="headerlink" title="Node.js Essential Patterns(Node.js 基本模式)"></a>Node.js Essential Patterns(Node.js 基本模式)</h1><h2 id="The-callback-pattern-回调模式"><a href="#The-callback-pattern-回调模式" class="headerlink" title="The callback pattern(回调模式)"></a>The callback pattern(回调模式)</h2><p>回调是<code>reactor</code>模式中<code>handler</code>的实例。</p><h3 id="The-continuation-passing-pattern-连续传递模式"><a href="#The-continuation-passing-pattern-连续传递模式" class="headerlink" title="The continuation-passing pattern(连续传递模式)"></a>The continuation-passing pattern(连续传递模式)</h3><p>在 JavaScript 中回调就是传入作为参数传入另外一个函数中的函数，并且在操作完成后调用。在函数式编程中，这种传递结果的方式被称为<code>continuation-passing style(CPS)</code>。这是个一般概念，并不是针对异步操作。实际上，它只是通过将结果作为参数传递给另一个函数（回调函数）来传递结果，然后在主体逻辑中调用回调函数拿到操作结果，而不是直接将其返回给调用者。</p><a id="more"></a><h4 id="Synchronous-continuation-passing-style-同步连续传递风格"><a href="#Synchronous-continuation-passing-style-同步连续传递风格" class="headerlink" title="Synchronous continuation-passing style(同步连续传递风格)"></a>Synchronous continuation-passing style(同步连续传递风格)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  callback(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>add()</code>函数就是一个同步的 CPS 函数，意味着只有回调函数执行完成它才会返回值。</p><h4 id="Asynchronous-continuation-passing-style-异步连续传递风格"><a href="#Asynchronous-continuation-passing-style-异步连续传递风格" class="headerlink" title="Asynchronous continuation-passing style(异步连续传递风格)"></a>Asynchronous continuation-passing style(异步连续传递风格)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">additionAsync</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> callback(a + b), <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setTimeout()</code>触发了一个异步操作，不需要等待回调函数执行完就会返回到<code>additionAsync()</code>的控制权，然后再回到<code>additionAsync</code>的调用者。这个属性对于<code>Node.js</code>是至关重要的，当一个异步的请求发出后会立即回到事件循环中， 因而允许队列中  新的事件被处理。下图描述了事件循环是怎么运作的：</p><p><img src="assets/img/event_loop2.png" alt="事件循环"></p><h4 id="Non-continuation-passing-style-callbacks-非连续传递风格的回调"><a href="#Non-continuation-passing-style-callbacks-非连续传递风格的回调" class="headerlink" title="Non-continuation-passing style callbacks(非连续传递风格的回调)"></a>Non-continuation-passing style callbacks(非连续传递风格的回调)</h4><p>某些情况下，比如一个回调函数作为参数传入，我们可能会以为这是一个异步操作或者是使用 CPS，但是有例外：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>].map(<span class="function"><span class="params">element</span> =&gt;</span> element - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [0, 4, 6]</span></span><br></pre></td></tr></table></figure><p>这就是一个同步的调用。</p><h3 id="Synchronous-or-asynchronous-同步还是异步"><a href="#Synchronous-or-asynchronous-同步还是异步" class="headerlink" title="Synchronous or asynchronous?(同步还是异步?)"></a>Synchronous or asynchronous?(同步还是异步?)</h3><p>代码的执行顺序会因同步或异步的执行方式产生根本性的改变。这对整个应用程序的流程，正确性和效率都产生了重大影响。以下是对这两种模式的范例和缺陷的分析：</p><h4 id="An-unpredictable-function-一个不可预测的函数"><a href="#An-unpredictable-function-一个不可预测的函数" class="headerlink" title="An unpredictable function(一个不可预测的函数)"></a>An unpredictable function(一个不可预测的函数)</h4><p>最危险的情况之一就是使一个 API 在某种特定情况下是同步执行的但是在另一种情况却是异步执行的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inconsistentRead</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[filename]) &#123;</span><br><span class="line">    <span class="comment">// 同步执行回调</span></span><br><span class="line">    callback(cache[filename])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache[filename] = data</span><br><span class="line">      callback(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数使用 cache 缓存文件读取结果，这个函数是危险的，因为当缓存命中时表现为同步的，当缓存未命中表现为异步的。</p><h4 id="Unleashing-Zalgo-解放-Zalgo"><a href="#Unleashing-Zalgo-解放-Zalgo" class="headerlink" title="Unleashing Zalgo(解放 Zalgo)"></a>Unleashing Zalgo(解放 Zalgo)</h4><p>围绕着同步或异步行为的不确定性，几乎总是导致非常难追踪的 Bug，这被称为<code>Zalgo</code>。</p><blockquote><p>注意：更多关于 Zalgo 的信息，参见 Oren Golan 的<a href="https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md" target="_blank" rel="noopener">Don’t Release Zalgo!(不要释放 Zalgo!)</a>和 Isaac Z. Schlueter 的<a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony" target="_blank" rel="noopener">Designing APIs for Asynchrony(异步 API 设计)</a>。</p></blockquote><p>看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFileReader</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeners = []</span><br><span class="line">  inconsistentRead(filename, value =&gt; &#123;</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(value))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onDataReady: <span class="function"><span class="params">listener</span> =&gt;</span> listeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数被调用的时候创建了一个作为通知器的对象，允许为一个  读文件操作设置多个监听。当文件读取完后或者数据可用后所有的监听都会被调用，现在使用上面的<code>inconsistentRead</code>函数来完成这个功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reader1 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">reader1.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'First call data: '</span> + data)</span><br><span class="line">  <span class="comment">// 之后再次通过fs读取同一个文件</span></span><br><span class="line">  <span class="keyword">const</span> reader2 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">  reader2.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Second call data: '</span> + data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>输出是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">First call data: some data</span><br></pre></td></tr></table></figure><p>会发现，第二个操作的回调未被调用，这是因为第一次调用时没有缓存，<code>inconsistentRead</code>是异步调用的，这个时候第一个回调函数已经加入到监听列表中了，然而第二次调用时，缓存中已经存在了，所以<code>inconsistentRead</code>是同步调用的，这个时候监听列表中还没有第二个回调函数，故而之后也没有再调用了。</p><h4 id="Using-asynchronous-API-使用同步-API"><a href="#Using-asynchronous-API-使用同步-API" class="headerlink" title="Using asynchronous API(使用同步 API)"></a>Using asynchronous API(使用同步 API)</h4><p>从上面<code>unleashing Zalgo</code>中我们知道，清楚地定义<code>API</code>性质是非常重要的：同步还是异步？</p><p>可以使整个函数同步来解决上面的问题，<code>readFileSync</code>代替<code>readFile</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consistentReadSync</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[filename]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[filename]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cache[filename] = fs.readFileSync(filename, <span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">return</span> cache[filename]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有理由为一个同步函数使用<code>CPS</code>风格。</p><blockquote><p>注意：最好为纯同步函数使用<code>direct style</code>。</p></blockquote><p>使用同步 API 替代异步 API 需要注意：</p><ul><li>同步 API 并不适用所有场景。</li><li>同步 API 会阻塞事件循环，降低了应用性能，破坏了<code>JavaScript</code>并发模型。</li></ul><p>如果只是读取有限的文件，那么<code>consistentReadSync</code>并不会对事件循环的性能造成多大影响，但是当文件很多时就不同了。</p><p>很多时候<code>Node.js</code>是不鼓励使用同步函数的，但是有时候同步函数也是最简单、最有效的解决方案。所以要根据情况来选择使用同步的方法还是异步的。</p><p>当对程序处理并发请求影响不大的时候使用同步(例如读取程序配置文件)。</p><h3 id="Deffered-execution-延时处理"><a href="#Deffered-execution-延时处理" class="headerlink" title="Deffered execution(延时处理)"></a>Deffered execution(延时处理)</h3><p>另外一种处理<code>consistentRead</code>的方法就是使整个函数都是异步的，使用<code>process.nextTick()</code>使得回调函数在下一个事件循环周期调用而不是立即调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consistentReadAsync</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[filename]) &#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> callback(cache[filename]))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异步函数</span></span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache[filename] = data</span><br><span class="line">      callback(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个延迟执行的 API 是<code>setImmediate()</code>，尽管他们看起来相似，但是在语义上完全不同，<code>process.nextTick()</code>在任何 I/O 事件触发前执行，而<code>setImmediate()</code>在队列中所有的 I/O 事件执行之后执行。</p><h3 id="Node-js-callback-conventions-Node-js-回调风格"><a href="#Node-js-callback-conventions-Node-js-回调风格" class="headerlink" title="Node.js callback conventions(Node.js 回调风格)"></a>Node.js callback conventions(Node.js 回调风格)</h3><p>对于<code>Node.js</code>而言，<code>CPS</code>风格的 API 和回调函数遵循一组特殊的约定。这些约定不只是适用于<code>Node.js</code>核心 API，对于它们之后也是绝大多数用户级模块和应用程序也很有意义。因此，我们了解这些风格，并确保我们在需要设计异步 API 时遵守规定显得至关重要。</p><h4 id="Callbacks-come-last-回调函数在最后"><a href="#Callbacks-come-last-回调函数在最后" class="headerlink" title="Callbacks come last(回调函数在最后)"></a>Callbacks come last(回调函数在最后)</h4><p>在所有核心 Node.js 方法中，标准约定是当函数在输入中接受回调时，必须作为最后一个参数传递。我们以下面的 Node.js 核心 API 为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(filename, [options], callback)</span><br></pre></td></tr></table></figure><p>从前面的例子可以看出，即使是在可选参数存在的情况下，回调也始终置于最后的位置。其原因是在回调定义的情况下，函数调用更可读。</p><h4 id="Error-comes-first-错误处理在最前"><a href="#Error-comes-first-错误处理在最前" class="headerlink" title="Error comes first(错误处理在最前)"></a>Error comes first(错误处理在最前)</h4><p>在<code>Node.js</code>中，在<code>CPS</code>中产生的错误总是作为第一个参数，这样便于调试，没有错误则第一个参数为 null 或者 undefined，在正式处理结果之前先判断 error 这样有利于 debug，错误类型为<code>Error</code>型，普通的字符串或者数字是不应该作为错误被传递的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'foo.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) handleError(err)</span><br><span class="line">  <span class="keyword">else</span> processData(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Propagating-errors-传递错误"><a href="#Propagating-errors-传递错误" class="headerlink" title="Propagating errors(传递错误)"></a>Propagating errors(传递错误)</h4><p>在同步函数或者直接风格中，使用<code>throw</code>是最直接的，使得错误从调用栈中弹出直到被捕获。</p><p>但是在异步调用中，比较好的错误处理方式是将错误传递到回调链中的下一个回调函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readJSON</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> parsed</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="comment">//传递错误并退出当前函数</span></span><br><span class="line">      <span class="keyword">return</span> callback(err)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//解析文件内容</span></span><br><span class="line">      parsed = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">//捕获解析中的错误</span></span><br><span class="line">      <span class="keyword">return</span> callback(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有错误，只传递数据</span></span><br><span class="line">    callback(<span class="literal">null</span>, parsed)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有错误直接<code>return</code>避免继续执行。</p><h4 id="Uncaught-exceptions"><a href="#Uncaught-exceptions" class="headerlink" title="Uncaught exceptions"></a>Uncaught exceptions</h4><p>在异步回调过程中，错误是难以被捕获的，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readJSONThrows</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err)</span><br><span class="line">    &#125;</span><br><span class="line">    callback(<span class="literal">null</span>, <span class="built_in">JSON</span>.parse(data))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的函数中，如果<code>JSON.parse(data)</code>异常的话是没有办法捕获的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  readJSONThrows(<span class="string">'nonJSON.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'This will not catch the JSON parsing exception'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>catch</code>语句将捕获不到错误，因为错误是在回调函数中产生的。然而，我们仍然有机会在应用程序终止之前执行一些清理或日志记录。事实上，当这种情况发生时，Node.js 会在退出进程之前发出一个名为<code>uncaughtException</code>的特殊事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(</span><br><span class="line">    <span class="string">'This will catch at last the '</span> + <span class="string">'JSON parsing exception: '</span> + err.message</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// Terminates the application with 1 (error) as exit code:</span></span><br><span class="line">  <span class="comment">// without the following line, the application would continue</span></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>uncaughtException</code>会使得应用处于一个不能保证一致的状态 ，而这可能导致不可预见的错误。比如还有未完成的 I/O 请求正在运行或关闭，这可能导致不一致。所以建议，尤其是在生产环境，在收到任何<code>uncaught exception</code>之后停止应用的运行。</p><h3 id="The-module-system-and-its-patterns-模块系统和其中的模式"><a href="#The-module-system-and-its-patterns-模块系统和其中的模式" class="headerlink" title="The module system and its patterns(模块系统和其中的模式)"></a>The module system and its patterns(模块系统和其中的模式)</h3><p>模块可以隐藏不想暴露的函数、变量，是构成大型应用的基础。</p><h4 id="The-revealing-module-pattern-模块模式"><a href="#The-revealing-module-pattern-模块模式" class="headerlink" title="The revealing module pattern(模块模式)"></a>The revealing module pattern(模块模式)</h4><p><code>JavaScript</code> 是没有命名空间的，在全局范围内运行的程序会污染全局命名空间，造成相关变量、数据、方法名的冲突。解决该问题的一个比较流行的做法是使用 <code>模块模式</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> privateFoo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> privateBar = []</span><br><span class="line">  <span class="keyword">const</span> exported = &#123;</span><br><span class="line">    publicFoo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    publicBar: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> exported</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>)</span><br></pre></td></tr></table></figure><p>该模式利用自执行函数创建私有空间，只导出需要暴露的部分，前面的代码中， <code>module</code> 变量只包含了暴露的 <code>API</code>，而内部的其他部分是外面访问不到的。这个模式背后的思想就是用来构建 <code>Node.js</code> 模块系统的基础。</p><h4 id="Node-js-modules-explained-Node-js-模块解释"><a href="#Node-js-modules-explained-Node-js-模块解释" class="headerlink" title="Node.js modules explained(Node.js 模块解释)"></a>Node.js modules explained(Node.js 模块解释)</h4><p><code>CommonJS</code> 是一个旨在规范 <code>JavaScript</code> 生态系统的组织，他们提出了 <code>CommonJS模块规范</code>。<code>Node.js</code> 在此规范之上构建了其模块系统，并添加了一些自定义的扩展。每个模块都在自己的私有空间下运行，所以在模块内定义的本地变量不会污染全局变量。</p><h5 id="A-homemade-module-loader-自定义模块加载器"><a href="#A-homemade-module-loader-自定义模块加载器" class="headerlink" title="A homemade module loader(自定义模块加载器)"></a>A homemade module loader(自定义模块加载器)</h5><p>为了解释加载器是如何工作的，先简单勾勒一个类似的系统，下面的代码模仿了内部函数 <code>require()</code> 的一部分功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadModule</span>(<span class="params">filename, module, require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedSrc = <span class="string">`(function(module, exports, require) &#123;</span></span><br><span class="line"><span class="string">         <span class="subst">$&#123;fs.readFileSync(filename, <span class="string">'utf8'</span>)&#125;</span></span></span><br><span class="line"><span class="string">       &#125;)(module, module.exports, require);`</span></span><br><span class="line">  <span class="built_in">eval</span>(wrappedSrc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块的源码被包装入一个函数，并且是使用模块模式的。区别在于传递了一些参数到模块中，实际上就是 <code>module</code>, <code>exports</code>, <code>require</code>。<code>exports</code> 参数被初始化为 <code>module.exports</code>。</p><blockquote><p>注意： 上面只是个示例，其实很少使用 <code>eval</code> 来执行源码，这可能导致注入攻击，使用 <code>eval</code> 要十分谨慎。</p></blockquote><p>现在通过实现 <code>require()</code> 函数来看看这都些变量中的包含了什么内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="function"><span class="params">moduleName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Require invoked for module: <span class="subst">$&#123;moduleName&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">require</span>.resolve(moduleName)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">require</span>.cache[id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>.cache[id].exports</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模块元数据</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    exports: &#123;&#125;,</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新缓存</span></span><br><span class="line">  <span class="built_in">require</span>.cache[id] = <span class="built_in">module</span></span><br><span class="line">  <span class="comment">//加载模块</span></span><br><span class="line">  loadModule(id, <span class="built_in">module</span>, <span class="built_in">require</span>)</span><br><span class="line">  <span class="comment">//返回导出的变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">require</span>.cache = &#123;&#125;</span><br><span class="line"><span class="built_in">require</span>.resolve = <span class="function"><span class="params">moduleName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 通过模块名作为参数resolve一个完整的模块 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数模拟了原生 <code>require()</code> 函数，并不能准确完美地反应真实的行为，但是却能帮助我们理解一个模块是怎么被定义和加载的：</p><ol><li>一个模块的名字作为输入被接收，我们需要做的第一件事就是找到这个模块的路径(我们称之为<code>id</code>)，这个依靠 <code>require.resolve()</code>来完成。</li><li>如果模块过去被加载过，那它应该存在于缓存。这种情况下我们直接返回就行。</li><li>如果模块尚未加载，我们将初始化首次加载模块环境。具体来说就是，创建一个模块(<code>module</code>)对象，其中包含一个 <code>exports</code> (被初始化为空的对象字面量<code>{}</code>)属性。该属性将被模块的代码用于导出模块的公共 <code>API</code>。</li><li>模块被缓存。</li><li>像前面所看到的一样，源代码从文件中被加载，接着被执行。我们给模块提供一个刚才创建的 <code>module</code> 对象和一个 <code>require()</code> 函数的引用。模块通过修改或替换 <code>module.exports</code> 来提供公共 <code>API</code>。</li><li>最后，包含公共 <code>API</code> 的 <code>module.exports</code>  返回给调用者。</li></ol><h5 id="Defining-a-module-定义一个模块"><a href="#Defining-a-module-定义一个模块" class="headerlink" title="Defining a module(定义一个模块)"></a>Defining a module(定义一个模块)</h5><p>让我们看看怎么定义一个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载另一个依赖</span></span><br><span class="line"><span class="keyword">const</span> dependency = <span class="built_in">require</span>(<span class="string">'./anotherModule'</span>)</span><br><span class="line"><span class="comment">//一个私有函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Well done <span class="subst">$&#123;dependency.username&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//API 被导出给外部用</span></span><br><span class="line"><span class="built_in">module</span>.exports.run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  log()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>module.exports</code> 的内容其他都是私有的，当模块被加载的时候这个变量的内容被返回且被缓存。</p><h5 id="Defining-globals-定义全局内容"><a href="#Defining-globals-定义全局内容" class="headerlink" title="Defining globals(定义全局内容)"></a>Defining globals(定义全局内容)</h5><p>即使在模块中声明的所有变量和函数都在其本地范围内定义，仍然可以定义全局变量。事实上，模块系统公开了一个名为 <code>global</code> 的特殊变量。分配给此变量的所有内容将会被定义到全局环境下。</p><blockquote><p>注意：污染全局变量是不好的，模块化的优势就不在了，所以只有当你真的需要用的时候再用吧！</p></blockquote><h5 id="module-exports-vs-exports"><a href="#module-exports-vs-exports" class="headerlink" title="module.exports vs exports"></a>module.exports vs exports</h5><p><code>exports</code> 只是 <code>module.exports</code> 的一个引用，所以在 <code>exports</code> 中添加新属性是有效的，能更新 <code>module.exports</code> 的内容，而对 <code>exports</code> 重新赋值则不会更新 <code>module.exports</code>，只是让 <code>exports</code> 指向了另一个对象；但是对 <code>module.exports</code> 重新赋值就是实实在在地更改了 <code>module</code> 了，是能起作用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有效</span></span><br><span class="line">exports.foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无效</span></span><br><span class="line">exports = &#123;</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有效</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="The-require-function-is-synchronous-require-函数是同步的"><a href="#The-require-function-is-synchronous-require-函数是同步的" class="headerlink" title="The require function is synchronous(require 函数是同步的)"></a>The require function is synchronous(require 函数是同步的)</h5><p>原生的 <code>require()</code> 函数也是同步的，所以对 <code>module.exports</code> 的赋值操作也是要同步的。下面这种代码就是错误的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>这就限制了我们绝大多数情况下都是使用同步的代码定义模块，这就是 <code>Node.js</code> 核心库为一些异步函数提供可选的同步的 <code>API</code> 的原因。</p><p>如果需要在模块初始化过程中使用异步方法，那么可以返回一个未初始化的模块，让使用者之后去初始化这个模块，这就导致了 <code>require</code> 不能保证模块被立即使用。</p><p>出于好奇，你可能想知道为什么 <code>Node.js</code> 早期是有异步的 <code>require()</code> 函数后来又被移除了，这是因为在初始化的过程中处理异步的 I/O 带来的复杂性比优势大太多了。</p><h5 id="The-resolve-algorithm-resolve-算法"><a href="#The-resolve-algorithm-resolve-算法" class="headerlink" title="The resolve algorithm(resolve 算法)"></a>The resolve algorithm(resolve 算法)</h5><p>为了解决<a href="https://zh.wikipedia.org/wiki/相依性地狱" target="_blank" rel="noopener">依赖地狱</a>问题，<code>Node.js</code> 根据模块的被加载的位置来加载不同版本的模块，这些理念也被运用到 <code>npm</code> 和 <code>require</code> 的 <code>resolve</code> 算法中。</p><p><code>resolve()</code> 接收 <code>moduleName</code> 作为参数，并返回模块的完整路径。</p><p><code>resolve</code> 算法的三个主要分支：</p><ol><li><strong>File modules</strong>(文件模块)：模块名是 <code>/</code> 开头认为是绝对路径，以 <code>./</code> 开头则认为是相对当前使用 <code>require</code> 的模块的路径。</li><li><strong>Core modules</strong>(核心模块)：模块名不以 <code>/</code> 或 <code>./</code> 开头则优先从核心库开始查找。</li><li><strong>Package modules</strong>(包模块)：核心库没有查找到时，再从当前目录的 <code>node_modules</code> 中查找相应的模块，没有则继续往上层的 <code>node_modules</code> 中找直到系统的根目录。</li></ol><p>对于文件和包模块，单个文件和目录也可以匹配到 <code>moduleName</code>。特别地，算法将尝试匹配以下内容：</p><ul><li><code>&lt;moduleName&gt;.js</code></li><li><code>&lt;moduleName&gt;/index.js</code></li><li>在<code>&lt;moduleName&gt;/package.json</code> 的 <code>main</code> 值下声明的文件或目录</li></ul><p>更详尽的 <code>resolve</code> 算法请看<a href="https://nodejs.org/api/modules.html#modules_all_together" target="_blank" rel="noopener">这里</a>。</p><p><code>node_modules</code> 目录实际上是 <code>npm</code> 安装每个包并存放相关依赖关系的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myApp</span><br><span class="line">├── foo.js</span><br><span class="line">└── node_modules</span><br><span class="line">    ├── depA</span><br><span class="line">    │   └── index.js</span><br><span class="line">    └── depB</span><br><span class="line">        │</span><br><span class="line">        ├── bar.js</span><br><span class="line">        ├── node_modules</span><br><span class="line">        ├── depA</span><br><span class="line">        │    └── index.js</span><br><span class="line">        └── depC</span><br><span class="line">             ├── foobar.js</span><br><span class="line">             └── node_modules</span><br><span class="line">                 └── depA</span><br><span class="line">                     └── index.js</span><br></pre></td></tr></table></figure><p>可以发现 <code>depA</code>, <code>depB</code>, <code>depC</code> 都有它们自己的依赖， 所以同样使用 <code>require(&#39;depA&#39;)</code>，在不同的地方加载就会加载不同的模块，如：</p><ul><li>在 <code>/myApp/foo.js</code> 中调用的 <code>require(&#39;depA&#39;)</code> 会加载 <code>/myApp/node_modules/depA/index.js</code></li><li>在 <code>/myApp/node_modules/depC/foobar.js</code> 中调用的 <code>require(&#39;depA&#39;)</code> 会加载 <code>/myApp/node_modules/depC/node_modules/depA/index.js</code></li></ul><p><code>resolve</code> 算法是 <code>Node.js</code> 依赖关系管理的核心部分，它的存在使得即便应用程序拥有成百上千包的情况下也不会出现冲突和版本不兼容的问题。</p><p>当我们调用 <code>require()</code> 时，解析算法对我们是透明的。然而，仍然可以在任何模块中通过调用 <code>require.resolve()</code> 使用该算法。</p><h5 id="The-module-cache-模块缓存"><a href="#The-module-cache-模块缓存" class="headerlink" title="The module cache(模块缓存)"></a>The module cache(模块缓存)</h5><p>模块只有在第一次被 <code>require</code> 的时候才会去加载，之后都是直接从缓存中获取的，除了提升性能外还有 2 个好处：</p><ul><li>模块依赖重复利用</li><li>从给定的包中获取相同的模块总是返回一个实例，避免了冲突</li></ul><p>需要的时候，模块的缓存可以通过 <code>require.cache</code> 访问，想要使缓存的模块失效可以删除 <code>require.cache</code> 中对应的 key 就行了，一般来说只在测试中做，在正常环境下是非常危险的。</p><h5 id="Circular-dependencies-循环依赖"><a href="#Circular-dependencies-循环依赖" class="headerlink" title="Circular dependencies(循环依赖)"></a>Circular dependencies(循环依赖)</h5><p>假设有两个模块：</p><ul><li>模块 <code>a.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.loaded = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  bWasLoaded: b.loaded,</span><br><span class="line">  loaded: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模块 <code>b.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.loaded = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  aWasLoaded: a.loaded,</span><br><span class="line">  loaded: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试着加载模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;bWasLoaded: true,loaded: true&#125;</span><br><span class="line">&#123;aWasLoaded: false,loaded: true&#125;</span><br></pre></td></tr></table></figure><p>先引入 <code>a</code> 模块，这时候 <code>a</code> 引入 <code>b</code> 模块，而 <code>b</code> 又去引入 <code>a</code> 模块，<code>b</code> 引入 <code>a</code> 的时候会直接返回缓存中的 <code>a</code>，也就是只有 <code>{load: false}</code>，然后 <code>b</code> 将 <code>{aWasLoaded: false, loaded: true}</code> 返回给 <code>a</code>，所以 <code>a</code> 中先拿到的 <code>b</code> 是完整的，而 <code>b</code> 拿到的 <code>a</code> 是不完整的。详情可查看<a href="https://nodejs.org/api/modules.html#modules_cycles" target="_blank" rel="noopener">这里</a>。</p><p>在项目中千万要注意不要出现循环依赖的情况，不然可能会出现严重的问题。</p><h4 id="Module-definition-patterns-模块定义模式"><a href="#Module-definition-patterns-模块定义模式" class="headerlink" title="Module definition patterns(模块定义模式)"></a>Module definition patterns(模块定义模式)</h4><h5 id="Named-exports-命名导出"><a href="#Named-exports-命名导出" class="headerlink" title="Named exports(命名导出)"></a>Named exports(命名导出)</h5><p>暴露公共 <code>API</code> 最常用的方法就是命名导出，将想要公开的值分配给 <code>exports</code>（或者 <code>module.exports</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file logger.js</span></span><br><span class="line">exports.info = <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'info: '</span> + message)</span><br><span class="line">&#125;</span><br><span class="line">exports.verbose = <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'verbose: '</span> + message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出的函数就可以当做已加载模块的属性使用了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file main.js</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'./logger'</span>)</span><br><span class="line">logger.info(<span class="string">'This is an informational message'</span>)</span><br><span class="line">logger.verbose(<span class="string">'This is a verbose message'</span>)</span><br></pre></td></tr></table></figure><p><code>CommonJS</code> 规范只允许使用 <code>exports</code> 来导出公共的成员，所以命名导出也是唯一的与 <code>CommonJS</code> 规范兼容的模式。而 <code>module.exports</code> 是为了支持更广泛定义模式的一个扩展。</p><h5 id="Exporting-a-function-导出一个函数"><a href="#Exporting-a-function-导出一个函数" class="headerlink" title="Exporting a function(导出一个函数)"></a>Exporting a function(导出一个函数)</h5><p>它只暴露了一个函数，为模块提供了一个明确的入口点，使其更易于理解和使用，也很好地体现了单一职责原则，也被称为 <code>substack</code> 模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file logger.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`info: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该模式的一种可能扩展是使用导出的函数作为其他公共 <code>API</code> 的命名空间，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.verbose = <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`verbose: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file main.js</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'./logger'</span>)</span><br><span class="line">logger(<span class="string">'This is an informational message'</span>)</span><br><span class="line">logger.verbose(<span class="string">'This is a verbose message'</span>)</span><br></pre></td></tr></table></figure><p><code>Node.js</code> 鼓励 <code>Single Responsibility Principle(SRP)</code>(单一职责原则)：每个模块负责单一功能，该职责也完全由该模块封装。</p><blockquote><p><code>substatck</code> 模式：导出一个函数来暴露主要功能(如上面的<code>logger(***)</code>)，使用导出的函数作为命名空间来导出次要的功能(如上面的<code>logger.verbose(***)</code>)，注意主要功能定义要在前，不然次要功能会被覆盖，因为 <code>module.exports</code> 被重新赋值了！</p></blockquote><h5 id="Exporting-a-constructor-导出一个构造器"><a href="#Exporting-a-constructor-导出一个构造器" class="headerlink" title="Exporting a constructor(导出一个构造器)"></a>Exporting a constructor(导出一个构造器)</h5><p>导出构造器是导出一个函数的特例，区别在于使用者可以用构造器创建实例也可以扩展原型并创建新类:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file logger.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Logger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Logger.prototype.log = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>] <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Logger.prototype.info = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.log(<span class="string">`info: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Logger.prototype.verbose = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.log(<span class="string">`verbose: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Logger</span><br></pre></td></tr></table></figure><p>下面是如何使用的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file main.js</span></span><br><span class="line"><span class="keyword">const</span> Logger = <span class="built_in">require</span>(<span class="string">'./logger'</span>)</span><br><span class="line"><span class="keyword">const</span> dbLogger = <span class="keyword">new</span> Logger(<span class="string">'DB'</span>)</span><br><span class="line">dbLogger.info(<span class="string">'This is an informational message'</span>)</span><br><span class="line"><span class="keyword">const</span> accessLogger = <span class="keyword">new</span> Logger(<span class="string">'ACCESS'</span>)</span><br><span class="line">accessLogger.verbose(<span class="string">'This is a verbose message'</span>)</span><br></pre></td></tr></table></figure><p>上面的 <code>logger</code> 也可以使用 <code>ES2015</code> 的 <code>class</code> 改写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  log(message) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>] <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  info(message) &#123;</span><br><span class="line">    <span class="keyword">this</span>.log(<span class="string">`info: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  verbose(message) &#123;</span><br><span class="line">    <span class="keyword">this</span>.log(<span class="string">`verbose: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Logger</span><br></pre></td></tr></table></figure><p>这种模式的变种包括对不使用 <code>new</code> 调用的防御(不使用 <code>new</code> 只会当做普通函数调用，而不会返回实例，而且可能会污染调用者(<code>this.name = name</code>这就污染了<code>Logger()</code>所属的对象了，这里是<code>global</code>))，这可以让我们把模块当做工厂使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Logger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Logger)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Logger(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这很简单：我们检查 <code>this</code> 是否存在，并且是 <code>Logger</code> 的一个实例。如果这些条件中的任何一个都为 <code>false</code>，则意味着 <code>Logger()</code> 函数在不使用 <code>new</code> 的情况下被调用，然后继续正确创建新实例并将其返回给调用者。这种技术允许我们将模块也用作工厂(<strong>这里原书存在问题所以做了些改动</strong>)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原书</span></span><br><span class="line"><span class="comment">// file logger.js</span></span><br><span class="line"><span class="keyword">const</span> Logger = <span class="built_in">require</span>(<span class="string">'./logger'</span>)</span><br><span class="line"><span class="keyword">const</span> dbLogger = Logger(<span class="string">'DB'</span>)</span><br><span class="line">accessLogger.verbose(<span class="string">'This is a verbose message'</span>)</span><br><span class="line"><span class="comment">// 改后</span></span><br><span class="line"><span class="comment">// file main.js</span></span><br><span class="line"><span class="keyword">const</span> Logger = <span class="built_in">require</span>(<span class="string">'./logger'</span>)</span><br><span class="line"><span class="keyword">const</span> dbLogger = Logger(<span class="string">'DB'</span>)</span><br><span class="line">dbLogger.verbose(<span class="string">'This is a verbose message'</span>)</span><br></pre></td></tr></table></figure><p>另一种更加清晰的方法来实现这个防御的是使用 <code>ES2015</code> 的 <code>new.target</code> 的语法(<code>Node.js</code> 第 6 版开始)，<code>new.target</code> 是用来检测一个函数或者构造器是否是使用 <code>new</code> 调用的，如果是则为 <code>true</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Logger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Logger(name) <span class="comment">//原书为 new LoggerConstructor(name)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果使用 <code>ES2015</code> 的 <code>class</code> 则不需要做 <code>new</code> 的防御，因为不使用 <code>new</code> 关键字来调用构造函数会抛出异常：<code>TypeError: Class constructor Logger cannot be invoked without &#39;new&#39;</code></p></blockquote><h5 id="Exporting-an-instance-导出一个实例"><a href="#Exporting-an-instance-导出一个实例" class="headerlink" title="Exporting an instance(导出一个实例)"></a>Exporting an instance(导出一个实例)</h5><p>我们可以利用 <code>require()</code> 的缓存机制来轻松地定义具有从构造函数或工厂创建的状态的有状态实例，可以在不同模块之间共享:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file logger.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Logger</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Logger.prototype.log = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.count++</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'['</span> + <span class="keyword">this</span>.name + <span class="string">'] '</span> + message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Logger(<span class="string">'DEFAULT'</span>)</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file main.js</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'./logger'</span>)</span><br><span class="line">logger.log(<span class="string">'This is an informational message'</span>)</span><br></pre></td></tr></table></figure><p>因为模块会被缓存，所以通过 <code>require</code> 引入的模块都是同一个实例，共享状态，这就像单例模式一样。但是实际上有可能并不只有一个实例，我们知道在安装依赖的时候，一个模块可能会被安装多次(版本不同)，这就会有多个同时运行于一个 <code>Node.js</code> 的应用程序中实例出现。</p><p>该模式的一个扩展是不仅导出实例，同时也导出用于创建实例的构造器，这让使用者可以创建新的实例或者必要时扩展对象，这有点类似导出命名空间(<a href="#Exporting-a-function-导出一个函数">Exporting a function</a>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other code</span></span><br><span class="line"><span class="built_in">module</span>.exports.Logger = Logger</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file main.js</span></span><br><span class="line"><span class="keyword">const</span> customLogger = <span class="keyword">new</span> logger.Logger(<span class="string">'CUSTOM'</span>)</span><br><span class="line">customLogger.log(<span class="string">'This is an informational message'</span>)</span><br></pre></td></tr></table></figure><h5 id="Modifying-other-modules-or-the-global-scope-修改其他模块或全局作用域"><a href="#Modifying-other-modules-or-the-global-scope-修改其他模块或全局作用域" class="headerlink" title="Modifying other modules or the global scope(修改其他模块或全局作用域)"></a>Modifying other modules or the global scope(修改其他模块或全局作用域)</h5><p>一个模块可以不导出任何东西，一个模块也可以修改全局域或者其他已经缓存的模块。</p><blockquote><p>注意：修改全局域或者其他模块是不好的，但是这在某些情况(如测试)下是有用的。</p></blockquote><p>这是向另一个模块添加函数的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file patcher.js</span></span><br><span class="line"><span class="comment">// ./logger is another module</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./logger'</span>).customMessage = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'This is a new functionality'</span>)</span><br></pre></td></tr></table></figure><p>所以只要在引入了 <code>patcher</code> 模块之后才有 <code>customMessage</code> 函数，这是非常危险的，特别是当多个模块与相同的实体进行交互时。</p><h4 id="The-observer-pattern-观察者模式"><a href="#The-observer-pattern-观察者模式" class="headerlink" title="The observer pattern(观察者模式)"></a>The observer pattern(观察者模式)</h4><p>观察者模式是对 <code>Node.js</code> 响应模型的理想解决方案，也是对回调的完美补充。我们给出以下定义：</p><blockquote><p>模式(观察者)定义一个对象(<code>subject</code>，主题)，它可以在其状态发生变化时通知一组观察者(或监听器)。</p></blockquote><p>和回调的不同在于可以通知多个观察者，传统的 <code>CPS</code> 模式只能传递结果给一个监听器(就是 <code>callback</code>)。</p><h5 id="The-EventEmiiter-class"><a href="#The-EventEmiiter-class" class="headerlink" title="The EventEmiiter class"></a>The EventEmiiter class</h5><p>在传统的面向对象编程中，观察者模式需要接口，具体类和层次结构。在 <code>Node.js</code> 中，都变得简单得多。观察者模式已经内置在核心模块中，可以通过 <code>EventEmitter</code> 类来实现。 <code>EventEmitter</code> 类允许我们注册一个或多个函数作为监听器，当特定的事件类型被触发时，它的回调将被调用，以通知其监听器:</p><p><img src="/assets/img/EventEmitter.png" alt="EventEmitter"></p><p><code>EventEmitter</code> 是从事件核心模块导出的原型，下面是如何获取一个实例的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter</span><br><span class="line"><span class="keyword">const</span> eeInstance = <span class="keyword">new</span> EventEmitter()</span><br></pre></td></tr></table></figure><p><code>EventEmitter</code> 的基本方法如下：</p><ul><li><code>on(event, listener)</code>:注册一个新的监听器(一个函数)到一个事件(string)中。</li><li><code>once(event, listener)</code>:也是为一个事件注册监听器，但是在事件第一次被触发后监听器被移除。</li><li><code>emit(event, [arg1], [...])</code>:生成一个新事件，并附带参数给监听器。</li><li><code>removeListener(event, listener)</code>:删除指定事件的一个监听器。</li></ul><p>上述每个方法都返回 <code>EventEmitter</code> 以便链式调用。监听器是类似于 <code>function([arg1], [...])</code> 的函数，可以接受通过 <code>emit</code> 传入的参数，函数中 <code>this</code> 是指向生产事件的 <code>EventEmitter</code> 实例。</p><blockquote><p>和回调函数不同的是，监听器第一个参数就是来自于 <code>emit</code> 的任何类型的数据，而不是 <code>error</code>。</p></blockquote><h5 id="Creating-and-using-EventEmitter-创建和使用-EventEmitter"><a href="#Creating-and-using-EventEmitter-创建和使用-EventEmitter" class="headerlink" title="Creating and using EventEmitter(创建和使用 EventEmitter)"></a>Creating and using EventEmitter(创建和使用 EventEmitter)</h5><p>以下代码显示了在文件列表中找到匹配特定正则的文件内容时，使用 <code>EventEmitter</code> 实现实时通知订阅者的功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPattern</span>(<span class="params">files, regex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter()</span><br><span class="line">  files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    fs.readFile(file, <span class="string">'utf8'</span>, (err, content) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> emitter.emit(<span class="string">'error'</span>, err)</span><br><span class="line">      emitter.emit(<span class="string">'fileread'</span>, file)</span><br><span class="line">      <span class="keyword">let</span> match</span><br><span class="line">      <span class="keyword">if</span> ((match = content.match(regex)))</span><br><span class="line">        match.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> emitter.emit(<span class="string">'found'</span>, file, elem))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> emitter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findPattern([<span class="string">'fileA.txt'</span>, <span class="string">'fileB.json'</span>], /hello \w+<span class="regexp">/g)</span></span><br><span class="line"><span class="regexp">  .on('fileread', file =&gt; console.log(file + ' was read'))</span></span><br><span class="line"><span class="regexp">  .on('found', (file, match) =&gt;</span></span><br><span class="line"><span class="regexp">    console.log('Matched "' + match + '" in file ' + file)</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  .on('error', err =&gt; console.log('Error emitted: ' + err.message))</span></span><br></pre></td></tr></table></figure><p>从上面我们也看到了是如何链式调用的了。</p><blockquote><p>注意，这里因为 <code>fs.readFile</code> 是异步的，会在下一次事件循环中才执行，所以实际上还是先注册了事件监听(<code>on</code>)再生产了事件(<code>emit</code>)。</p></blockquote><h5 id="Propagating-errors-传递错误-1"><a href="#Propagating-errors-传递错误-1" class="headerlink" title="Propagating errors(传递错误)"></a>Propagating errors(传递错误)</h5><p>对于错误事件，最佳做法是注册错误的侦听器(如在<code>findPattern</code>中的<code>error</code>事件一样)，因为 Node.js 会以特殊的方式处理它，并且如果没有找到相关联的侦听器，将自动抛出异常并退出程序。</p><h5 id="Making-any-object-observable-使任意对象可观察"><a href="#Making-any-object-observable-使任意对象可观察" class="headerlink" title="Making any object observable(使任意对象可观察)"></a>Making any object observable(使任意对象可观察)</h5><p>直接上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindPattern</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(regex) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.regex = regex</span><br><span class="line">    <span class="keyword">this</span>.files = []</span><br><span class="line">  &#125;</span><br><span class="line">  addFile(file) &#123;</span><br><span class="line">    <span class="keyword">this</span>.files.push(file)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">this</span>.files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">      fs.readFile(file, <span class="string">'utf8'</span>, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'fileread'</span>, file)</span><br><span class="line">        <span class="keyword">let</span> match = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span> ((match = content.match(<span class="keyword">this</span>.regex))) &#123;</span><br><span class="line">          match.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> <span class="keyword">this</span>.emit(<span class="string">'found'</span>, file, elem))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> findPatternObject = <span class="keyword">new</span> FindPattern(<span class="regexp">/hello \w+/</span>)</span><br><span class="line">findPatternObject</span><br><span class="line">  .addFile(<span class="string">'fileA.txt'</span>)</span><br><span class="line">  .addFile(<span class="string">'fileB.json'</span>)</span><br><span class="line">  .find()</span><br><span class="line">  .on(<span class="string">'found'</span>, (file, match) =&gt;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Matched "<span class="subst">$&#123;match&#125;</span>"</span></span><br><span class="line"><span class="string">       in file <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">  )</span><br><span class="line">  .on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.log(<span class="string">`Error emitted <span class="subst">$&#123;err.message&#125;</span>`</span>))</span><br></pre></td></tr></table></figure><p>这里直接使用 <code>ES6</code> 的继承语法(不推荐使用<a href="https://nodejs.org/docs/latest/api/util.html#util_util_inherits_constructor_superconstructor" target="_blank" rel="noopener">util.inherits</a>方式了，这里书中还没有更新过来)来实现对 <code>EventEmitter</code> 的继承， 这在 <code>Node.js</code> 生态系统中是一个很常见的模式，例如，核心 <code>HTTP</code> 模块的 <code>Server</code> 对象定义了 <code>listen()</code>，<code>close()</code>，<code>setTimeout()</code> 等方法，并且在内部它也继承自 <code>EventEmitter</code> 函数，从而允许它在收到新的请求时生产 <code>request</code> 事件、在建立新的连接时生产 <code>connection</code> 事件、或者在服务器关闭时生产 <code>closed</code> 事件。</p><h5 id="Synchronous-and-asynchronous-events-同步和异步事件"><a href="#Synchronous-and-asynchronous-events-同步和异步事件" class="headerlink" title="Synchronous and asynchronous events(同步和异步事件)"></a>Synchronous and asynchronous events(同步和异步事件)</h5><p>同一个 <code>EventEmitter</code> 中不要同时使用同步和异步触发事件(这样来阻止<code>Zalgo</code>)，同步事件是要在所有监听器都注册完了才能触发的，而异步事件要保证在下一个事件循环周期前不被触发，异步事件触发前都能添加监听器(上面的<code>findPattern</code>就是这种)。</p><p>像下面这种就是不会正常运行的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncEmit</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'ready'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> syncEmit = <span class="keyword">new</span> SyncEmit()</span><br><span class="line">syncEmit.on(<span class="string">'ready'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Object is ready to be  used'</span>))</span><br></pre></td></tr></table></figure><h5 id="EventEmitter-versus-callbacks-EventEmitter-vs-回调函数"><a href="#EventEmitter-versus-callbacks-EventEmitter-vs-回调函数" class="headerlink" title="EventEmitter versus callbacks(EventEmitter vs 回调函数)"></a>EventEmitter versus callbacks(EventEmitter vs 回调函数)</h5><p>定义异步 <code>API</code> 时是使用 <code>callbacks</code> 还是 <code>EventEmitter</code> 的一般规则：当结果必须通过异步方式返回时使用 <code>callbacks</code>，当有什么东西需要被传达时使用 <code>EventEmitter</code>。</p><p>来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter()</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> eventEmitter.emit(<span class="string">'hello'</span>, <span class="string">'hello world'</span>), <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">return</span> eventEmitter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloCallback</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> callback(<span class="string">'hello world'</span>), <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个函数在功能上是等价的，第一个函数通过事件传递延迟函数的结束，第二个函数使用回调函数通知调用函数。实际上，真正的区别在于可读性、代码量、语法上，这里给出一些提示帮助决定是使用 <code>callbacks</code> 还是 <code>EventEmitter</code>：</p><ul><li><code>callbacks</code> 在支持事件的不同类型上有限制，虽然可以把事件类型作为参数传递给回调函数，或者接受多个回调来区分多种类型事件，但是这样是不够优雅的，这种情况 <code>EventEmitter</code> 可以提供更简单的接口和更简洁的代码。</li><li>同一事件多次被触发或者从未触发，这种情况使用 <code>EventEmitter</code> 更好。</li><li>使用 <code>callbacks</code> 的 <code>API</code> 仅通知一个特定的回调函数，而使用 <code>EventEmitter</code> 可以让多个监听器接收同一个通知。</li></ul><h5 id="Combining-callbacks-and-EventEmitter-结合回调和-EventEmitter"><a href="#Combining-callbacks-and-EventEmitter-结合回调和-EventEmitter" class="headerlink" title="Combining callbacks and EventEmitter(结合回调和 EventEmitter)"></a>Combining callbacks and EventEmitter(结合回调和 EventEmitter)</h5><p>某些场景下我们需要结合 <code>callbacks</code> 和 <code>EventEmitter</code> 来使用，这种模式在某种场景下是非常有用的：通过导出一个传统的异步函数作为主功能来实现最小接口原则，但同时通过返回 <code>EventEmitter</code> 提供更丰富的功能和控制。使用该模式的一个例子是 <a href="https://www.npmjs.com/package/glob" target="_blank" rel="noopener">node-glob</a> 模块，模块的主入口是它导出的一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob(pattern, [options], callback)</span><br></pre></td></tr></table></figure><p>对于匹配到指定文件名匹配模式的文件列表，相关回调函数会被调用。同时，该函数返回 <code>EventEmitter</code>，它展现了当前进程的状态。例如，当成功匹配文件名时触发 <code>match</code> 事件，当文件列表全部匹配完毕时触发 <code>end</code> 事件，或者该进程被手动中止时触发 <code>abort</code> 事件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line">glob(<span class="string">'data/*.txt'</span>, (error, files) =&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`All files found: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(files)&#125;</span>`</span>)</span><br><span class="line">).on(<span class="string">'match'</span>, match =&gt; <span class="built_in">console</span>.log(<span class="string">`Match found: <span class="subst">$&#123;match&#125;</span>`</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node-js-Essential-Patterns-Node-js-基本模式&quot;&gt;&lt;a href=&quot;#Node-js-Essential-Patterns-Node-js-基本模式&quot; class=&quot;headerlink&quot; title=&quot;Node.js Essential Patterns(Node.js 基本模式)&quot;&gt;&lt;/a&gt;Node.js Essential Patterns(Node.js 基本模式)&lt;/h1&gt;&lt;h2 id=&quot;The-callback-pattern-回调模式&quot;&gt;&lt;a href=&quot;#The-callback-pattern-回调模式&quot; class=&quot;headerlink&quot; title=&quot;The callback pattern(回调模式)&quot;&gt;&lt;/a&gt;The callback pattern(回调模式)&lt;/h2&gt;&lt;p&gt;回调是&lt;code&gt;reactor&lt;/code&gt;模式中&lt;code&gt;handler&lt;/code&gt;的实例。&lt;/p&gt;
&lt;h3 id=&quot;The-continuation-passing-pattern-连续传递模式&quot;&gt;&lt;a href=&quot;#The-continuation-passing-pattern-连续传递模式&quot; class=&quot;headerlink&quot; title=&quot;The continuation-passing pattern(连续传递模式)&quot;&gt;&lt;/a&gt;The continuation-passing pattern(连续传递模式)&lt;/h3&gt;&lt;p&gt;在 JavaScript 中回调就是传入作为参数传入另外一个函数中的函数，并且在操作完成后调用。在函数式编程中，这种传递结果的方式被称为&lt;code&gt;continuation-passing style(CPS)&lt;/code&gt;。这是个一般概念，并不是针对异步操作。实际上，它只是通过将结果作为参数传递给另一个函数（回调函数）来传递结果，然后在主体逻辑中调用回调函数拿到操作结果，而不是直接将其返回给调用者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第一章</title>
    <link href="http://1016990109.github.io/2018/05/11/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/05/11/Node-js-设计模式读书笔记-第一章/</id>
    <published>2018-05-11T12:00:45.000Z</published>
    <updated>2018-05-22T03:12:52.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Welcome-to-the-Node-js-Platform"><a href="#Welcome-to-the-Node-js-Platform" class="headerlink" title="Welcome to the Node.js Platform"></a>Welcome to the Node.js Platform</h1><h2 id="Small-modules-小模块"><a href="#Small-modules-小模块" class="headerlink" title="Small modules(小模块)"></a>Small modules(小模块)</h2><p><code>Node.js</code>使用<code>module</code>(模块)的概念组织代码的结构。<br><code>package</code>可提供复用的模块，有一个 module 作为入口。<br><code>Node.js</code>中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：</p><a id="more"></a><blockquote><ul><li>“Small is beautiful.”(小而精)</li><li>“Make each program do one thing well.” (每个程序只有单一的职责)</li></ul></blockquote><p><code>Node.js</code> 通过官方包管理工具<code>npm</code>解决包之间的依赖问题，每个<code>package</code>都有它自己的依赖，故而一个程序中多个<code>package</code>能够无冲突地安装。应用程序都是由一个个很小的、单职责的依赖构成的。</p><p><strong>小模块</strong>应该有的特性：</p><blockquote><ul><li>Easier to understand and use(易理解、易用)</li><li>Simpler to test and maintain(易于测试和维护)</li><li>Perfect to share with the browser(完美支持浏览器)</li></ul></blockquote><p><strong>DRY(Dont’t Repeat Yourself)原则</strong></p><h2 id="Small-surface-area-暴露需要的接口"><a href="#Small-surface-area-暴露需要的接口" class="headerlink" title="Small surface area(暴露需要的接口)"></a>Small surface area(暴露需要的接口)</h2><p>一般使用者只会用到很有限的功能，而很少去  扩展一个模块，所以<code>Node.js</code>的很多模块只会暴露一个函数或者一个构造器，然后把更细节的东西都放在函数或者构造器里，这样能帮助  使用者认清什么是主要的什么是次要的.</p><p>模块是不允许被扩展的，看起来扩展性低，但实际上有很多优势：减少了应用场景(这样考虑的情况就少了，容易实现)，简化了实现，便于维护，提高了可用性。</p><h2 id="Simplicity-and-progmatism-简单而实用"><a href="#Simplicity-and-progmatism-简单而实用" class="headerlink" title="Simplicity and progmatism(简单而实用)"></a>Simplicity and progmatism(简单而实用)</h2><blockquote><p>简单就是复杂到极致。—— 达尔文</p></blockquote><blockquote><p>设计必须简单， 不管是实现还是接口。实现的简洁比接口的简洁更重要。设计中最重要的就是简洁。—— Richard P.Gabriel(一位杰出的计算机科学家)</p></blockquote><p>设计简单的而不是完美或功能完备的软件是一个好的实践：</p><ul><li> 更容易实现</li><li>更少的资源，传输更快</li><li>更容易适应</li><li>容易维护和理解</li></ul><p>设计简单这个原则同样也适用于<code>JavaScript</code>，简单函数、闭包、<code>object</code>替代了复杂的类继承。</p><h2 id="Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6"><a href="#Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6" class="headerlink" title="Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)"></a>Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)</h2><h3 id="The-let-and-const-keywords-let-和-const-关键字"><a href="#The-let-and-const-keywords-let-和-const-关键字" class="headerlink" title="The let and const keywords(let 和 const 关键字)"></a>The let and const keywords(let 和 const 关键字)</h3><p>在之前(ES2015 之前)，<code>js</code>只支持函数作用域和全局作用域，例如在 if 中声明一个变量却能在 if 块之外访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>但是使用<code>let</code>关键字后，if 块外就访问不到其中声明的变量了，这在一定程度上能减少因为误操作其中的变量而导致的 bug：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p><code>const</code>关键字用于声明不可变变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">'This will never change'</span></span><br><span class="line">x = <span class="string">'...'</span></span><br><span class="line"><span class="comment">//TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>const</code>  是意味着变量的绑定不变而不是内容不变，示例入下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cosnt x = &#123;&#125;</span><br><span class="line">x.name = <span class="string">'John'</span><span class="comment">//work</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">null</span><span class="comment">//don't work</span></span><br></pre></td></tr></table></figure><p>通常来说引入模块使用 <code>const</code>防止模块发生变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> path = <span class="string">'./some/path'</span> <span class="comment">//fail</span></span><br></pre></td></tr></table></figure><p>如果你想要创建一个不可更改的对象，<code>const</code>是不够的，你可以使用 ES5 的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">Object.freeze()</a>或者 <a href="https://www.npmjs.com/package/deep-freeze" target="_blank" rel="noopener">deep-freeze</a>模块，或者我使用<code>react</code>框架时候经常用的<a href="https://www.npmjs.com/package/immutable" target="_blank" rel="noopener">immutable</a>模块也可以。</p><blockquote><p>扩展——这里提一下<strong>ES5</strong>中<code>freeze</code>和<code>seal</code>的区别，<code>seal</code>只限制无法增加和删除对象属性 ，而<code>freeze</code>在<code>seal</code>的基础上还限制了不可更改对象的属性。</p></blockquote><h3 id="The-arrow-function-箭头函数"><a href="#The-arrow-function-箭头函数" class="headerlink" title="The arrow function(箭头函数)"></a>The arrow function(箭头函数)</h3><p>箭头函数是<strong>ES6</strong>的一大亮点，能很大程度上简化代码。一个参数可以不需要圆括号，函数体只有一行且结果为返回值可不需要花括号，具体示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> event = numbers.filter(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event2 = numbers.filter(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>箭头函数中 this 的指向跟随父函数，示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DelayedGreeter</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DelayedGreeter.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> DelayedGreeter(<span class="string">'World'</span>).greet() <span class="comment">//Hello undefined</span></span><br><span class="line"></span><br><span class="line">DelayedGreeter.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> DelayedGreeter(<span class="string">'World'</span>).greet() <span class="comment">//Hello World</span></span><br></pre></td></tr></table></figure><h3 id="Class-syntax-Class-语法"><a href="#Class-syntax-Class-语法" class="headerlink" title="Class syntax(Class 语法)"></a>Class syntax(Class 语法)</h3><p><code>class</code>只是个语法糖，使用 class 实现对象继承并不是通过<code>class</code>继承的，还是通过内部的 prototypes，properties 实现继承，但是<code>class</code>使得程序可读性变强了。</p><p>让我们来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂，晦涩难懂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, surname, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.surname = surname</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.surname</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.older = <span class="function"><span class="keyword">function</span>(<span class="params">person1, person2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易懂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, surname, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.surname = surname</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.surname</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> older(person1, person2) &#123;</span><br><span class="line">    <span class="keyword">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonWithMiddlename</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, middlename, surname, age) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, surname, age)</span><br><span class="line">    <span class="keyword">this</span>.middlename = middlename</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.middlename + <span class="string">' '</span> + <span class="keyword">this</span>.surname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Enhanced-object-literals-对象字面量语法增强"><a href="#Enhanced-object-literals-对象字面量语法增强" class="headerlink" title="Enhanced object literals(对象字面量语法增强)"></a>Enhanced object literals(对象字面量语法增强)</h3><ul><li>缺省键值，属性名和变量名相同时可省略属性名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">22</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">17</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;</span><br></pre></td></tr></table></figure><ul><li>计算属性，属性可以是由变量计算而来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> namespace = <span class="string">'-webkit-'</span></span><br><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">  [namespace + <span class="string">'box-sizing'</span>]: <span class="string">'border-box'</span>,</span><br><span class="line">  [namespace + <span class="string">'box-shadow'</span>]: <span class="string">'10px 10px 5px #888888'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getter 和 setter</li></ul><p>先看例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'George'</span>,</span><br><span class="line">  surname: <span class="string">'Boole'</span>,</span><br><span class="line">  get fullname() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">''</span> + <span class="keyword">this</span>.surname</span><br><span class="line">  &#125;,</span><br><span class="line">  set fullname(fullname) &#123;</span><br><span class="line">    <span class="keyword">let</span> parts = fullname.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">this</span>.name = parts[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">this</span>.surname = parts[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.fullname) <span class="comment">// "George Boole"</span></span><br><span class="line"><span class="built_in">console</span>.log((person.fullname = <span class="string">'Alan Turing'</span>)) <span class="comment">// "Alan Turing"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "Alan"</span></span><br></pre></td></tr></table></figure><p>可以看到第二个 console.log 输出的是“Alan Turing”，这是因为调用 set 后默认返回 get 获得的值。</p><h3 id="Map-and-Set-collections-Map-和-Set-集合"><a href="#Map-and-Set-collections-Map-和-Set-集合" class="headerlink" title="Map and Set collections(Map 和 Set 集合)"></a>Map and Set collections(Map 和 Set 集合)</h3><p>原来我们建立 hash map 的时候都是用<code>object</code>来完成的，而现在可以直接使用<code>Map</code>原型，提供了 set、get、has、delete 方法和 size 属性，比使用<code>object</code>更加直接、简单，遍历可使用<code>for...of</code>语法，这种遍历方式是和 Map 中属性的插入顺序是一样的(这在普通<code>object</code>中是无法保证的)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tests = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">   tests.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>+<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">   tests.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>*<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">   tests.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>/<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> tests) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log((entry[<span class="number">0</span>]() === entry[<span class="number">1</span>])   <span class="string">'PASS'</span> : <span class="string">'FAIL'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code>只允许存在不同的值，和数学上的集合是一个概念，里面内容可以是<code>number</code>也可以是<code>object</code>或<code>function</code>，除了 set 换成 add 外其他的都与 map 相同，遍历时每一个 entry 内容是 value。</p><h3 id="WeakMap-and-WeakSet-collections"><a href="#WeakMap-and-WeakSet-collections" class="headerlink" title="WeakMap and WeakSet collections"></a>WeakMap and WeakSet collections</h3><p>顾名思义，<code>WeakMap</code>和<code>WeakSet</code>是<code>Map</code>和<code>Set</code>弱化后的原型，但是这其中并无优劣之分，只是适用于不同的场合。</p><p><code>WeakMap</code>的<strong>key</strong>只能是非空对象，对<strong>key</strong>仅保持弱引用，最大的好处是可以避免内存泄漏，一旦<strong>key</strong>的引用为空或者 undefined，垃圾回收器就可以回收这个对象，但是<code>WeakMap</code>不能迭代遍历。</p><p><code>WeakSet</code>与<code>WeakMap</code>同。</p><h3 id="Template-literals-模板字符串"><a href="#Template-literals-模板字符串" class="headerlink" title="Template literals(模板字符串)"></a>Template literals(模板字符串)</h3><p>使用`代替双引号和单引号，在字符串中可以使用表达式${expression}，可以换行。</p><h3 id="ES6-其他语法"><a href="#ES6-其他语法" class="headerlink" title="ES6 其他语法"></a>ES6 其他语法</h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a>(稍后会详细讲到)</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" target="_blank" rel="noopener">函数默认参数</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Rest_parameters" target="_blank" rel="noopener">剩余参数语法</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="noopener">拓展运算符</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="noopener">new.target</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">代理</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener">反射</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol" target="_blank" rel="noopener">Symbol</a></li></ul><h2 id="The-reactor-pattern"><a href="#The-reactor-pattern" class="headerlink" title="The reactor pattern"></a>The reactor pattern</h2><p><code>reactor</code>模式是 <code>Node.js</code> 异步的核心。</p><h3 id="I-O-is-slow-I-O-操作是慢的"><a href="#I-O-is-slow-I-O-操作是慢的" class="headerlink" title="I/O is slow(I/O 操作是慢的)"></a>I/O is slow(I/O 操作是慢的)</h3><p>I/O 操作可以说是计算机操作中最慢的一环，I/O 的速度可能和网络速度、磁盘速率有关，也可能和其他因素有关，比如用户点击事件等等。</p><h3 id="Blocking-I-O-阻塞-I-O"><a href="#Blocking-I-O-阻塞-I-O" class="headerlink" title="Blocking I/O(阻塞 I/O)"></a>Blocking I/O(阻塞 I/O)</h3><p>传统的阻塞 I/O 模型中，I/O 请求会阻塞之后代码块的运行，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直到请求完成，数据可用，线程都是阻塞的</span></span><br><span class="line">data = socket.read()</span><br><span class="line"><span class="comment">// 请求完成，数据可用</span></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><p>而为了达到并发的  目的，传统的 web 服务器是  选择新开一个线程或进程，这样因为线程(或进程)之间的相互独立性，一个线程(或进程)阻塞并不会影响另一个。</p><p>但是创建一个线程是昂贵的，一个线程需要内存，而且切换线程需要保留线程的上下文等等，所以这种方式并不是最佳实践。</p><h3 id="Non-blocking-I-O-非阻塞-I-O"><a href="#Non-blocking-I-O-非阻塞-I-O" class="headerlink" title="Non-blocking I/O(非阻塞 I/O)"></a>Non-blocking I/O(非阻塞 I/O)</h3><p>与阻塞 I/O 相反，遇到 I/O 请求不会阻塞后续代码的执行，如果访问的资源不可用则会返回一个预定义的常量值。</p><p>非阻塞 I/O 最基本的模式是轮询直到有数据已经返回了，也叫做 <code>忙等待</code>模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resources = [socketA, socketB, pipeA]</span><br><span class="line"><span class="keyword">while</span> (!resources.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resources.length; i++) &#123;</span><br><span class="line">    resource = resources[i]</span><br><span class="line">    <span class="comment">// 进行读操作</span></span><br><span class="line">    <span class="keyword">let</span> data = resource.read()</span><br><span class="line">    <span class="keyword">if</span> (data === NO_DATA_AVAILABLE) &#123;</span><br><span class="line">      <span class="comment">// 此时还没有数据</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// 资源被释放，从队列中移除该链接</span></span><br><span class="line">      resources.remove(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      consumeData(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子已经能有单线程处理多个请求了， 但是不够高效，资源不可用时循环占了太多了 CPU 时间，轮询算法浪费 CPU 时间。</p><h3 id="Event-demultiplexing-事件多路复用"><a href="#Event-demultiplexing-事件多路复用" class="headerlink" title="Event demultiplexing(事件多路复用)"></a>Event demultiplexing(事件多路复用)</h3><p>对于获取非阻塞的资源而言，忙等待模型不是一个理想的技术，大多数现代的操作系统都提供了一种机制来处理并发和非阻塞资源，这个机制被称为<code>同步多路复用</code>。</p><p>这个组件从一系列被监听的资源中收集 I/O 事件并放入队列中，而且会一直处于阻塞状态直到有新的事件可以被处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">socketA, pipeB;</span><br><span class="line">wachedList.add(socketA, FOR_READ);</span><br><span class="line">wachedList.add(pipeB, FOR_READ);</span><br><span class="line"><span class="keyword">while</span>(events = demultiplexer.watch(wachedList)) &#123;</span><br><span class="line">  <span class="comment">// 事件循环</span></span><br><span class="line">  foreach(event <span class="keyword">in</span> events) &#123;</span><br><span class="line">    <span class="comment">// 永远不会阻塞，并且总会有返回值</span></span><br><span class="line">    data = event.resource.read();</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// 资源已经被释放，从观察者队列移除</span></span><br><span class="line">      demultiplexer.unwatch(event.resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 获得数据进行处理</span></span><br><span class="line">      consumeData(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的三个重要步骤：</p><ol><li>资源被添加到一个数据结构中，为每个资源关联一个特定的操作，在这个例子中是 read。</li><li>事件通知器由一组被观察的资源组成，事件通知器是同步和阻塞的直到有资源可以被<code>read</code>，事件触发后会从调用中返回，之后这些事件可以被处理。</li><li>多路复用器返回的每个事件被处理，此时，和事件相关的资源都可用且不会在操作中阻塞。当所有的事件都被处理完后，继续进入循环等待下一个可以被处理的事件。这个被称作为<code>事件循环(event loop)</code>。</li></ol><p><img src="/assets/img/node_demultiplexer.png" alt="多路复用"></p><p>上图帮助我们理解如何在一个单线程中使用多路复用器和非阻塞 I/O 来处理并发。我们能够看到，只使用一个线程并不会影响我们处理多个 I/O 任务的性能。同时，我们看到任务是在单个线程中随着时间的推移而展开的，而不是分散在多个线程中。我们看到，在单线程中传播的任务相对于多线程中传播的任务反而节约了线程的总体空闲时间，并且更利于程序员编写代码。</p><h3 id="Introducing-to-reactor-pattern-reactor-模式的介绍"><a href="#Introducing-to-reactor-pattern-reactor-模式的介绍" class="headerlink" title="Introducing to reactor pattern(reactor 模式的介绍)"></a>Introducing to reactor pattern(reactor 模式的介绍)</h3><p>主要思想就是每一个 I/O 操作都有一个<code>handler</code>或者成为回调函数(<code>callback</code>)，当事件发生并且被<code>事件循环</code>处理后，这个回调函数就会被调用：</p><p><img src="/assets/img/event_loop.png" alt="event loop"></p><p>一个应用使用<code>reactor</code>模式后：</p><ol><li>应用提交一个请求给事件多路复用器 ，生成 I/O 操作，同时提供事件触发时的<code>handler</code>， 发送请求给事件多路复用器是一个非阻塞的操作，发送后立即返回到应用。</li><li>当一组 I/O 操作完成，事件多路复用器会将新来的事件添加到事件队列中。</li><li>此时，事件循环会迭代事件队列中的每个事件。</li><li>对于每个事件，对应的<code>handler</code>被处理。</li><li><code>handler</code>，是应用程序代码的一部分，<code>handler</code>执行结束后执行权会交回事件循环。但是，在<code>handler</code>执行时可能请求新的异步操作，从而新的操作被添加到事件多路复用器。</li><li>当事件队列的全部事件被处理完后，事件多路复用器再次阻塞直到有一个新的事件触发。</li></ol><p>现在来定义 Node.js 的核心模式：<br><code>模式(reactor)</code>这样处理 I/O，阻塞直到有新的事件从被观察的资源中触发，然后将事件派发给相应的<code>handler</code>。</p><h3 id="Node-js-非阻塞-I-O-引擎——libuv"><a href="#Node-js-非阻塞-I-O-引擎——libuv" class="headerlink" title="Node.js 非阻塞 I/O 引擎——libuv"></a>Node.js 非阻塞 I/O 引擎——libuv</h3><p>每个操作系统都有不同的接口来实现事件多路复用器，Linux 是 epoll，Mac OSX 是 kqueue，Windows 的 IOCP API，即使是在相同的操作系统中对于不同资源的 I/O 操作也不同，所以 Node.js 使用<code>libuv</code>来统一处理 I/O 操作，来达到兼容不同操作系统的目的。</p><h3 id="Node-js-架构"><a href="#Node-js-架构" class="headerlink" title="Node.js 架构"></a>Node.js 架构</h3><p><img src="/assets/img/node_architecture.png" alt="Node.js 架构"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Welcome-to-the-Node-js-Platform&quot;&gt;&lt;a href=&quot;#Welcome-to-the-Node-js-Platform&quot; class=&quot;headerlink&quot; title=&quot;Welcome to the Node.js Platform&quot;&gt;&lt;/a&gt;Welcome to the Node.js Platform&lt;/h1&gt;&lt;h2 id=&quot;Small-modules-小模块&quot;&gt;&lt;a href=&quot;#Small-modules-小模块&quot; class=&quot;headerlink&quot; title=&quot;Small modules(小模块)&quot;&gt;&lt;/a&gt;Small modules(小模块)&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt;使用&lt;code&gt;module&lt;/code&gt;(模块)的概念组织代码的结构。&lt;br&gt;&lt;code&gt;package&lt;/code&gt;可提供复用的模块，有一个 module 作为入口。&lt;br&gt;&lt;code&gt;Node.js&lt;/code&gt;中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python 处理excel文件</title>
    <link href="http://1016990109.github.io/2018/05/09/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/"/>
    <id>http://1016990109.github.io/2018/05/09/Python-处理excel文件/</id>
    <published>2018-05-09T14:42:58.000Z</published>
    <updated>2018-05-10T09:01:45.774Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要用到Python去处理excel，目标是根据用户输入的信息，先显示每列的列名以及这一列示例行（取前两行信息），然后根据输入的列号删除对应的列。</p><p>网上搜索了下主要有几种方案：</p><h3 id="1-使用xlrd、xlwt、xlutils组合"><a href="#1-使用xlrd、xlwt、xlutils组合" class="headerlink" title="1. 使用xlrd、xlwt、xlutils组合"></a>1. 使用xlrd、xlwt、xlutils组合</h3><p>这种方案比较常见，而且读取和写入速度较快，但是只能操作2003版本之前的xls文件，处理不了xlsx，所以想要处理2003版本之后的请绕道。</p><blockquote><p>注意！<br>xlutils复制的excel格式上会存在一些问题，我在使用的时候就因为这个原因而弃用了，灰底的表格会变成深蓝色底的，难以接受。 </p></blockquote><a id="more"></a><p>xlrd用来读取excel内容，xlwt写入excel内容，xlutils封装了一些常用的操作excel的函数供用户使用，一些使用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">'myexcel.xls'</span>)</span><br><span class="line"><span class="comment">#获取表单</span></span><br><span class="line">worksheet = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line">data = worksheet.cell_value(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">##另一种获取数据，但这种是包含数据类型的，需要内容可通过value获取</span></span><br><span class="line">data2 = worksheet.cell(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">#----xlwt库</span></span><br><span class="line"><span class="comment">#新建excel</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"><span class="comment">#添加工作薄</span></span><br><span class="line">sh = wb.add_sheet(<span class="string">'Sheet1'</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">sh.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">'data'</span>)</span><br><span class="line"><span class="comment">#保存文件</span></span><br><span class="line">wb.save(<span class="string">'myexcel.xls'</span>)</span><br><span class="line"><span class="comment">#----xlutils库</span></span><br><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">book = xlrd.open_workbook(<span class="string">'myexcel.xls'</span>)</span><br><span class="line"><span class="comment">#复制一份</span></span><br><span class="line">new_book = xlutils.copy(book)</span><br><span class="line"><span class="comment">#拿到工作薄</span></span><br><span class="line">worksheet = new_book.getsheet(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">worksheet.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">'new data'</span>)</span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">new_book.save()</span><br></pre></td></tr></table></figure><h3 id="2-使用openpyxl"><a href="#2-使用openpyxl" class="headerlink" title="2. 使用openpyxl"></a>2. 使用openpyxl</h3><p>与xlrd、xlwt、xlutils组合不同，openpyxl只支持excel 2003之后的也就是xlsx文件，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">workbook = openpyxl.Workbook() </span><br><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">sheet = workbook.activesheet[<span class="string">'A1'</span>]=<span class="string">'data'</span></span><br><span class="line"><span class="comment"># 保存文件 </span></span><br><span class="line">workbook.save(<span class="string">'test.xlsx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="comment">#打开文件</span></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'test.xlsx'</span>)</span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line">ws = wb.active</span><br><span class="line">cols = ws.columns</span><br><span class="line">cols[<span class="number">0</span>][<span class="number">1</span>].value = <span class="string">'data'</span></span><br></pre></td></tr></table></figure><h3 id="3-使用win32com操作系统的Excel程序"><a href="#3-使用win32com操作系统的Excel程序" class="headerlink" title="3. 使用win32com操作系统的Excel程序"></a>3. 使用win32com操作系统的Excel程序</h3><p>这种方式约束较多，要求Windows + Microsoft Excel，是使用win32com库来操作Excel程序来完成对excel文件的操作，官方的API特别的复杂，要找到自己需要的API还是要费一番功夫的，但是相应的能做的事也就多了，你能在Excel程序中做的事，几乎使用win32com都能做，具体可用的可查看官方的<a href="https://documentation.devexpress.com/OfficeFileAPI/12078/Spreadsheet-Document-API/Examples/Worksheets" target="_blank" rel="noopener">文档</a>，几乎和vb程序差不多，不用看c++的。<br>举一些我在项目中用到的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开应用</span></span><br><span class="line">xlApp = win32com.client.Dispatch(<span class="string">'Excel.Application'</span>)</span><br><span class="line"><span class="comment">#打开表格</span></span><br><span class="line">xlBook = xlApp.Workbook.Open(<span class="string">'test.xls'</span>)</span><br><span class="line"><span class="comment">#保存文件</span></span><br><span class="line">xlBook.Save()</span><br><span class="line"><span class="comment">#另存为</span></span><br><span class="line">xlBook.SaveAs(<span class="string">'new.xls'</span>)</span><br><span class="line"><span class="comment">#关闭文件</span></span><br><span class="line">xlBook.Close(SaveChanges=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#获得sheet，传入sheet名字</span></span><br><span class="line">sht = xlBook.Worksheets(<span class="string">'Sheet1'</span>)</span><br><span class="line"><span class="comment">#获得sheet2，传入index</span></span><br><span class="line">sht = xlBook.worksheets[index]</span><br><span class="line"><span class="comment">#获得单元格内容</span></span><br><span class="line">data =  sht.Cells(row, col).Value</span><br><span class="line"><span class="comment">#设置单元格内容</span></span><br><span class="line">sht.Cells(row, col).Value = <span class="string">'New Value'</span></span><br><span class="line"><span class="comment">#获得一块</span></span><br><span class="line">myRange = sht.Range(sht.Cells(row1, col1), sht.Cells(row2, col2)).Value</span><br><span class="line"><span class="comment">#选择sheet</span></span><br><span class="line">sht.Activate</span><br><span class="line"><span class="comment">#获得一列</span></span><br><span class="line">sht.Columns(index)</span><br><span class="line"><span class="comment">#删除一列</span></span><br><span class="line">sht.Columns(<span class="number">1</span>).Delete()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是3种常用操作excel的python库，读者可根据自己的情况选择合适的库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要用到Python去处理excel，目标是根据用户输入的信息，先显示每列的列名以及这一列示例行（取前两行信息），然后根据输入的列号删除对应的列。&lt;/p&gt;
&lt;p&gt;网上搜索了下主要有几种方案：&lt;/p&gt;
&lt;h3 id=&quot;1-使用xlrd、xlwt、xlutils组合&quot;&gt;&lt;a href=&quot;#1-使用xlrd、xlwt、xlutils组合&quot; class=&quot;headerlink&quot; title=&quot;1. 使用xlrd、xlwt、xlutils组合&quot;&gt;&lt;/a&gt;1. 使用xlrd、xlwt、xlutils组合&lt;/h3&gt;&lt;p&gt;这种方案比较常见，而且读取和写入速度较快，但是只能操作2003版本之前的xls文件，处理不了xlsx，所以想要处理2003版本之后的请绕道。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意！&lt;br&gt;xlutils复制的excel格式上会存在一些问题，我在使用的时候就因为这个原因而弃用了，灰底的表格会变成深蓝色底的，难以接受。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://1016990109.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Vue 过渡&amp;动画</title>
    <link href="http://1016990109.github.io/2018/05/06/Vue-%E8%BF%87%E6%B8%A1-%E5%8A%A8%E7%94%BB/"/>
    <id>http://1016990109.github.io/2018/05/06/Vue-过渡-动画/</id>
    <published>2018-05-06T12:56:26.000Z</published>
    <updated>2018-05-15T12:37:51.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>使用 transition 封装组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="过渡类名"><a href="#过渡类名" class="headerlink" title="过渡类名"></a>过渡类名</h3><p>使用 transition 之后当触发过渡动画时，会添加相应的 class，没有 name 属性时使用 v-，否则使用定义的{$name}-，共有 6 个 class 切换：</p><ol><li>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li><li>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li><li>v-enter-to: 2.1.8 版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</li><li>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li><li>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li>v-leave-to: 2.1.8 版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li></ol><p>具体过程如下：</p><p><img src="/assets/img/vue_transition.png" alt="vue_transition"></p><h3 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h3><p>可以在属性中声明钩子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-enter</span>=<span class="string">"afterEnter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter-cancelled</span>=<span class="string">"enterCancelled"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-leave</span>=<span class="string">"beforeLeave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-leave</span>=<span class="string">"afterLeave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave-cancelled</span>=<span class="string">"leaveCancelled"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成。</p></blockquote><blockquote><p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p></blockquote><h2 id="多个元素的过渡"><a href="#多个元素的过渡" class="headerlink" title="多个元素的过渡"></a>多个元素的过渡</h2><h3 id="过渡-模式"><a href="#过渡-模式" class="headerlink" title="过渡  模式"></a>过渡  模式</h3><ul><li>in-out：新元素先进行过渡，完成之后当前元素过渡离开。</li><li>out-in：当前元素先进行过渡，完成之后新元素过渡进入。</li></ul><h2 id="平滑过渡-列表过渡"><a href="#平滑过渡-列表过渡" class="headerlink" title="平滑过渡(列表过渡)"></a>平滑过渡(列表过渡)</h2><p>使用 <code>&lt;transition-group&gt;</code>组件，可以使列表过渡起来比较平滑，只需要使用<code>v-move</code>即可，具体例子如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"flip-list"</span> <span class="attr">tag</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flip-list-move</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>读者有兴趣可以研究一下洗牌算法，可以保证每个数出现的唯一性，shuffle 算法。</p></blockquote><p>这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。</p><p>需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中。</p><hr><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单元素-组件的过渡&quot;&gt;&lt;a href=&quot;#单元素-组件的过渡&quot; class=&quot;headerlink&quot; title=&quot;单元素/组件的过渡&quot;&gt;&lt;/a&gt;单元素/组件的过渡&lt;/h2&gt;&lt;p&gt;使用 transition 封装组件：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;transition&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;fade&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;v-if&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;show&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;hello&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;transition&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>VSCode配置</title>
    <link href="http://1016990109.github.io/2018/05/05/VSCode%E9%85%8D%E7%BD%AE/"/>
    <id>http://1016990109.github.io/2018/05/05/VSCode配置/</id>
    <published>2018-05-05T11:30:34.000Z</published>
    <updated>2018-05-06T12:50:42.796Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用IDE从WebStorm更换到VSCode，故在此记录下VSCode的一些配置，供以后查看。</p><h2 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h2><p>VSCode更倾向于定制化，所以需要自行寻找需要的插件，来提高打码的效率~</p><p>我这里使用了一些暂时需要用到的插件：</p><a id="more"></a><h3 id="1-Beautify"><a href="#1-Beautify" class="headerlink" title="1. Beautify"></a>1. Beautify</h3><p>一个很常用的代码格式化工具，一键格式化，非常方便。</p><h3 id="2-Git-History"><a href="#2-Git-History" class="headerlink" title="2. Git History"></a>2. Git History</h3><p>查看log，文件历史记录等等，在自带git功能上多加了许多功能。</p><h3 id="3-Vetur"><a href="#3-Vetur" class="headerlink" title="3. Vetur"></a>3. Vetur</h3><p>Vue的火热使得前端很多时候都使用它来开发，该插件高亮vue代码以及vue的代码格式化。</p><h3 id="4-Auto-Rename-Tag"><a href="#4-Auto-Rename-Tag" class="headerlink" title="4. Auto Rename Tag"></a>4. Auto Rename Tag</h3><p>自动重命名tag名称，类似于webstorm中的功能。</p><h3 id="5-Auto-Close-Tag"><a href="#5-Auto-Close-Tag" class="headerlink" title="5. Auto Close Tag"></a>5. Auto Close Tag</h3><p>自动关闭tag，类似webstorm。</p><h3 id="6-CSS-Peek"><a href="#6-CSS-Peek" class="headerlink" title="6. CSS Peek"></a>6. CSS Peek</h3><p>自动识别css文件中的类名，在模板中插入class时自动提示。</p><h2 id="配置篇"><a href="#配置篇" class="headerlink" title="配置篇"></a>配置篇</h2><p>记录自己用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"git.enableSmartCommit"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"git.autofetch"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"terminal.integrated.shell.osx"</span>: <span class="string">"zsh"</span>,</span><br><span class="line">    <span class="string">"window.zoomLevel"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"beautify.language"</span>: &#123;</span><br><span class="line">        <span class="string">"js"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: [</span><br><span class="line">                <span class="string">"javascript"</span>,</span><br><span class="line">                <span class="string">"json"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"filename"</span>: [</span><br><span class="line">                <span class="string">".jshintrc"</span>,</span><br><span class="line">                <span class="string">".jsbeautifyrc"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"css"</span>: [</span><br><span class="line">            <span class="string">"css"</span>,</span><br><span class="line">            <span class="string">"scss"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"html"</span>: [</span><br><span class="line">            <span class="string">"htm"</span>,</span><br><span class="line">            <span class="string">"html"</span>,</span><br><span class="line">            <span class="string">"vue"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"html.format.endWithNewline"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"prettier.singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"prettier.semi"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"vetur.format.defaultFormatter.html"</span>: <span class="string">"js-beautify-html"</span>,</span><br><span class="line">    <span class="string">"vetur.format.defaultFormatterOptions"</span>: &#123;</span><br><span class="line">      <span class="string">"wrap_attributes"</span>: <span class="string">"force-aligned"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用IDE从WebStorm更换到VSCode，故在此记录下VSCode的一些配置，供以后查看。&lt;/p&gt;
&lt;h2 id=&quot;插件篇&quot;&gt;&lt;a href=&quot;#插件篇&quot; class=&quot;headerlink&quot; title=&quot;插件篇&quot;&gt;&lt;/a&gt;插件篇&lt;/h2&gt;&lt;p&gt;VSCode更倾向于定制化，所以需要自行寻找需要的插件，来提高打码的效率~&lt;/p&gt;
&lt;p&gt;我这里使用了一些暂时需要用到的插件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
