<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七秒悲伤的博客</title>
  
  <subtitle>一个深藏功与名的软件开发爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1016990109.github.io/"/>
  <updated>2018-05-28T14:51:41.419Z</updated>
  <id>http://1016990109.github.io/</id>
  
  <author>
    <name>七秒悲伤</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>5月28日学习笔记</title>
    <link href="http://1016990109.github.io/2018/05/28/5%E6%9C%8828%E6%97%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://1016990109.github.io/2018/05/28/5月28日学习笔记/</id>
    <published>2018-05-28T14:17:10.000Z</published>
    <updated>2018-05-28T14:51:41.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="该记录何种日志？"><a href="#该记录何种日志？" class="headerlink" title="该记录何种日志？"></a>该记录何种日志？</h3><ol><li>操作时间日志可能有些操作耗时会比较长，可以对方法的处理时间做个记录，例如数据库连接可能耗时很长（但是具体的数据库操作时间记录一般交由数据库本身来做，调用者也不可能知道一条语句耗费了多少时间）则需要记录，某些 <code>api</code> 也可能出现耗时长的问题，记录操作时长可有效发现问题。</li><li>异常日志程序在运行中抛出的异常，可以记录，方便定位错误。</li><li>调试日志有时候本地不方便调试可输出调试信息到日志，方便调试。</li></ol><a id="more"></a><h3 id="日志类型："><a href="#日志类型：" class="headerlink" title="日志类型："></a>日志类型：</h3><ol><li>时间日志这种日志一般按照时间成文件，记录每段时间的日志（错误日志只记录索引，错误信息等，不记录错误栈，是为了日志分析以及格式化）。</li><li>滚动日志滚动日志一般比较随意了，有调试的信息、错误栈、其他一些日志。</li></ol><h3 id="日志工具："><a href="#日志工具：" class="headerlink" title="日志工具："></a>日志工具：</h3><p><code>awk</code> 了解一下</p><h3 id="日志作用"><a href="#日志作用" class="headerlink" title="日志作用"></a>日志作用</h3><ul><li>记录重要信息，如错误、异常、警告等等</li><li>用户行为分析<br>例如将对某一数据连贯的一系列操作共同组成一组事务，一组事务中有多个行为，如用户id、数据id、session_id共同组成对一个数据的一组有关联的操作，可以用来分析用户操作数据的行为，有时候也可以通过行为记录来查找 <code>bug</code> 的原因。</li><li>统计<br>例如某某接口调用次数特别多，某某接口调用非常少等等统计工作。</li><li>调试<br>学会使用日志调试</li></ul><h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><p>何时使用参数校验？</p><ul><li>接口需要<br>如某个接口一定需要id字段才可以查询，则对id做一个校验。</li><li>性能需要<br>例如分页的时候，每页数据量过大的时候可能会影响接口的性能，这时候需要对参数做限制。<br>参数不合法就可以不进行处理，避免不必要的操作，提升性能。</li><li>数据库需要<br>数据最多支持32位长度的字符串，这时候提前做校验可以避免错误产生，也可以避免不必要操作提升性能。</li><li>业务需要<br>例如邮箱有固定的格式，可以对参数做验证。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>简洁不一定是对的，有时候更需要易懂。</p><p>一切的 <code>I/O</code> 操作都需要处理异常。</p><p>封装需要权衡易读性与一致性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h2&gt;&lt;h3 id=&quot;该记录何种日志？&quot;&gt;&lt;a href=&quot;#该记录何种日志？&quot; class=&quot;headerlink&quot; title=&quot;该记录何种日志？&quot;&gt;&lt;/a&gt;该记录何种日志？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;操作时间日志可能有些操作耗时会比较长，可以对方法的处理时间做个记录，例如数据库连接可能耗时很长（但是具体的数据库操作时间记录一般交由数据库本身来做，调用者也不可能知道一条语句耗费了多少时间）则需要记录，某些 &lt;code&gt;api&lt;/code&gt; 也可能出现耗时长的问题，记录操作时长可有效发现问题。&lt;/li&gt;
&lt;li&gt;异常日志程序在运行中抛出的异常，可以记录，方便定位错误。&lt;/li&gt;
&lt;li&gt;调试日志有时候本地不方便调试可输出调试信息到日志，方便调试。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习" scheme="http://1016990109.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="随笔" scheme="http://1016990109.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 探索</title>
    <link href="http://1016990109.github.io/2018/05/22/dubbo%E6%8E%A2%E7%B4%A2/"/>
    <id>http://1016990109.github.io/2018/05/22/dubbo探索/</id>
    <published>2018-05-22T03:09:44.000Z</published>
    <updated>2018-06-01T06:15:38.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo-框架的介绍以及源码阅读"><a href="#Dubbo-框架的介绍以及源码阅读" class="headerlink" title="Dubbo 框架的介绍以及源码阅读"></a>Dubbo 框架的介绍以及源码阅读</h1><h2 id="Dubbo-简介"><a href="#Dubbo-简介" class="headerlink" title="Dubbo 简介"></a>Dubbo 简介</h2><p><code>Apache Dubbo|ˈdʌbəʊ|</code> 是阿里开源的一个 RPC 框架。</p><p>和大多数 <code>RPC</code> 系统一样， <code>dubbo</code> 基于一个理念：定义一个服务，确定远程调用的方法，并且包含他们的参数和返回类型。在服务端，服务器实现接口并且运行一个 <code>dubbo</code> 的服务来处理来自客户端的请求；在客户端，客户端持有提供与服务端方法一模一样的桩。</p><a id="more"></a><p><img src="/assets/img/dubbo_architecture.png" alt="dubbo 架构"></p><p><code>Apache Dubbo(incubating)</code>提供三个关键的功能:</p><ul><li>基于接口的远程调用</li><li>错误容忍和负载均衡</li><li>自动化服务注册和发现</li></ul><p>详细的架构描述请查看<a href="http://dubbo.apache.org/books/dubbo-user-book/preface/architecture.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="Dubbo-实现"><a href="#Dubbo-实现" class="headerlink" title="Dubbo 实现"></a>Dubbo 实现</h2><h3 id="Dubbo-接入-spring"><a href="#Dubbo-接入-spring" class="headerlink" title="Dubbo 接入 spring"></a>Dubbo 接入 spring</h3><p><code>spring</code> 可以在 <code>xml</code> 中做一些配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.demo.dubbo.server.serviceimpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对于上述的 xml 配置，分成三个部分:</p><ul><li>命名空间 <code>namespace</code>，如 <code>context</code></li><li>元素 <code>element</code>，如 <code>component-scan</code></li><li>属性 <code>attribute</code>，如 <code>base-package</code></li></ul><p><code>spring</code> 定义了两个接口，来分别解析上述内容：</p><ul><li><code>NamespaceHandler</code>：注册了一堆 <code>BeanDefinitionParser</code>，利用他们来进行解析</li><li><code>BeanDefinitionParser</code>: 用于解析每个 <code>element</code> 的内容</li></ul><p><code>spring</code> 会从 <code>jar</code> 包下的 <code>META-INF/spring.handlers</code> 文件下寻找 <code>NamespaceHandler</code>，所以如果需要自定义配置，只需要在 <code>jar</code> 包下加入 <code>META-INF/spring.handlers</code> 文件，其中记录 <code>NamespaceHandler</code> 的实现类，<code>dubbo</code> 的 <code>spring.handlers</code> 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http\://dubbo.apache.org/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br><span class="line">http\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure><p>然后不同的配置分别转换成 <code>spring</code> 容器中的一个 <code>bean</code> 对象：</p><ul><li><code>application</code> 对应 <code>ApplicationConfig</code></li><li><code>registry</code> 对应 <code>RegistryConfig</code></li><li><code>monitor</code> 对应 <code>MonitorConfig</code></li><li><code>provider</code> 对应 <code>ProviderConfig</code></li><li><code>consumer</code> 对应 <code>ConsumerConfig</code></li><li><code>protocol</code> 对应 <code>ProtocolConfig</code></li><li><code>service</code> 对应 <code>ServiceBean</code>(继承 <code>ServiceConfig</code>)</li><li><code>reference</code> 对应 <code>ReferenceBean</code>(继承 <code>ReferenceConfig</code>)</li></ul><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p><code>Invoker</code> 是实体域，它是 <code>Dubbo</code> 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 <code>invoke</code> 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>Invocation</code> 则包含了需要执行的方法、参数等信息，接口定义简略如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] getParameterTypes();</span><br><span class="line"></span><br><span class="line">Object[] getArguments();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布服务"><a href="#发布服务" class="headerlink" title="发布服务"></a>发布服务</h3><p><img src="/assets/img/dubbo_rpc_export.jpg" alt="dubbo rpc export"></p><p><code>ServiceConfig</code> 通过配置文件拿到对外提供服务的实现类 <code>ref</code>(如：<code>DemoServiceImpl</code>),然后通过 <code>ProxyFactory</code> 的 <code>getInvoker</code> 方法根据 <code>ref</code> 生成一个 <code>AbstractProxyInvoker</code> 实例，然后在通过 <code>Protocol</code> 的 <code>export</code> 方法将 <code>Invoker</code>  转换为 <code>Exporter</code>。</p><p>这里举一个将 <code>Invoker</code> 转为 <code>Exporter</code> 的例子，<code>DubboProtocol</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProxyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// export service.</span></span><br><span class="line">        String key = serviceKey(url);</span><br><span class="line">        DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费服务"><a href="#消费服务" class="headerlink" title="消费服务"></a>消费服务</h3><p><img src="/assets/img/dubbo_rpc_refer.jpg" alt="dubbo rpc refer"></p><p><code>ReferenceConfig</code> 类的 <code>init</code> 方法调用 <code>Protocol</code> 的 <code>refer</code> 方法生成 <code>Invoker</code> 实例(如上图中的红色部分)，这是服务消费的关键。接下来把 <code>Invoker</code> 转换为客户端需要的接口(如<code>DemoService</code>)。而客户端需要调用的时候只需要调用这个接口(如<code>DemoService</code>)，就能够间接使用 <code>Invoker</code> 来调用远程的方法。</p><h3 id="Invoke-的过程"><a href="#Invoke-的过程" class="headerlink" title="Invoke 的过程"></a>Invoke 的过程</h3><p><img src="/assets/img/dubbo_rpc_invoke.jpg" alt="dubbo rpc invoke"></p><!-- #### 远程过程调用总结总的来看，可以将 `dubbo` 中的远程过程调用总结为：服务端根据读取的配置将接口一个个封装起来并暴露(`Exporter`)，启动服务并遵守定义的协议；客户端通过配置文件的配置，接着根据定义的协议生成对应的调用者(`Invoker`)，调用者中隐藏了真正的远程调用细节，之后便可以通过调用者调用远程的方法了。例如，通过 `dubbo://11.240.240.118:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=11.240.240.118&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=34270&qos.port=22222&side=provider&timestamp=1527037622366` 可以发现，服务器提供一个 `DemoService` 的接口，和一个 `sayHello` 的方法；通过 `dubbo://11.240.240.118:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=34452&qos.port=33333&register.ip=11.240.240.118&remote.timestamp=1527037622366&side=consumer&timestamp=1527038134040` 客户端拿到对应的可调用的接口 `DemoService`，然后调用 `DemoService` 中的方法(`sayHello`)，接着调用到客户端的 `Invoker`(这里为`DubboInvoker`)，`Invoker` 再根据协议将包装的信息传递到服务器，服务器解析信息找到对应的 `Exporter`，再找到 `AbstractProxyInvoker` 的实例，然后成功调用接口的实现类 `DemoServiceImpl`，完成调用，这就是整个过程。 --><h3 id="扩展点加载"><a href="#扩展点加载" class="headerlink" title=" 扩展点加载"></a> 扩展点加载</h3><p><code>Dubbo</code> 的扩展点加载从 <code>JDK</code> 标准的 <code>SPI</code> (Service Provider Interface) 扩展点发现机制加强而来。</p><p>传统的 <code>SPI</code> 发现机制是根据在 <code>jar</code> 包中的 <code>META-INF/services/</code> 配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk 提供服务实现查找的一个工具类： <code>java.util.ServiceLoader</code>。</p><h4 id="Dubbo-的-ExtensionLoader-解析扩展过程"><a href="#Dubbo-的-ExtensionLoader-解析扩展过程" class="headerlink" title="Dubbo 的 ExtensionLoader 解析扩展过程"></a>Dubbo 的 ExtensionLoader 解析扩展过程</h4><p><code>jdk</code> 使用 <code>ServiceLoader</code>， <code>Dubbo</code> 使用<code>com.alibaba.dubbo.common.extension.ExtensionLoader</code> 来提供服务实现查找，<code>ExtensionLoader</code> 注入的依赖扩展点是一个 <code>Adaptive</code> 实例，直到扩展点方法执行时才决定调用是一个扩展点实现。</p><p>以下面例子为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; protocolLoader=ExtensionLoader.getExtensionLoader(Protocol.class);</span><br><span class="line">Protocol  protocol=protocolLoader.getAdaptiveExtension();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Extension</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">&lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据要加载的接口创建出一个 ExtensionLoader 实例，然后再获取自适应的 <code>Protocol</code> 实现类(<code>DubboProtocol$Adaptive</code>)。</p><p><code>getAdaptiveExtension</code> 会根据 <code>@Adaptive</code> 注解去动态生成 <code>DubboProtocol$Adaptive</code> 实例， <code>DubboProtocol$Adaptive</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(com.alibaba.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"com.alibaba.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在使用过程中，如 <code>export()</code> 方法在调用过程中或通过 <code>ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName)</code> 来获取到真正的实例再进行调用，这就保证了在真正调用之前，实例是不会被真正创建的(只创建了对应的<code>Adaptive</code>实例)，如果有扩展实现初始化很耗时，没用上也不会加载，从而减少资源浪费。</p><h4 id="ExtensionLoader-实例是如何来加载-Protocol-的实现类的："><a href="#ExtensionLoader-实例是如何来加载-Protocol-的实现类的：" class="headerlink" title="ExtensionLoader 实例是如何来加载 Protocol 的实现类的："></a>ExtensionLoader 实例是如何来加载 Protocol 的实现类的：</h4><p>1.先解析 Protocol 上的 Extension 注解的 name,存至 String cachedDefaultName 属性中，作为默认的实现</p><p>2.到类路径下的加载所有的 META-INF/dubbo.interval.com.alibaba.dubbo.rpc.Protocol 文件，例如 <code>dubbo-rpc-dubbo</code> 模块下的 Protocol 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br></pre></td></tr></table></figure><p>然后读取内容加载对应的 <code>class</code>(<code>DubboProtocol</code>)，并和对应的 <code>name</code>(上面<code>=</code>前面的字符<code>dubbo</code>) 做关联，为以后根据 <code>name</code> 找具体实现类做铺垫。</p><h4 id="ExtensionLoader-获取扩展过程"><a href="#ExtensionLoader-获取扩展过程" class="headerlink" title="ExtensionLoader 获取扩展过程"></a>ExtensionLoader 获取扩展过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance(name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                type + <span class="string">")  could not be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致分成 4 步：</p><p>1.根据 name 获取对应的 class</p><p>2.根据获取到的 class 创建一个实例</p><p>3.对获取到的实例，进行依赖注入</p><p>4.对于上述经过依赖注入的实例，再次进行包装，实现 <code>AOP</code>。以 <code>Protocol</code> 为例，<code>ProtocolFilterWrapper</code>、<code>ProtocolListenerWrapper</code> 会对 <code>DubboProtocol</code> 进行包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxProtocolWrapper</span> <span class="title">implemenets</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    Protocol impl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XxxProtocol</span><span class="params">(Protocol protocol)</span> </span>&#123; impl = protocol; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口方法做一个操作后，再调用extension的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... 一些操作</span></span><br><span class="line">        impl.refer();</span><br><span class="line">        <span class="comment">// ... 一些操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个扩展点可以直接-setter-注入其它扩展点"><a href="#一个扩展点可以直接-setter-注入其它扩展点" class="headerlink" title="一个扩展点可以直接 setter 注入其它扩展点"></a>一个扩展点可以直接 <code>setter</code> 注入其它扩展点</h4><p>对应的处理在 <code>ExtensionLoader</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"fail to inject via method "</span> + method.getName()</span><br><span class="line">                                + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dubbo-通信"><a href="#Dubbo-通信" class="headerlink" title="Dubbo 通信"></a>Dubbo 通信</h3><p><code>Dubbo</code> 已经集成的有 <code>Netty</code>、<code>Mina</code>，默认是 <code>Netty</code>，这里主要介绍 <code>Netty</code>。</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p><code>Netty</code> 使用 <code>Reactor</code> 主从模型结构(三种 <code>Reactor</code> 模型详情请看<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">这里</a>)的变种:</p><p><img src="/assets/img/reactor3.png" alt="reactor3"></p><p>去掉上面的线程池就为 <code>Netty</code> 的默认模式了。</p><p><code>Netty</code> 里对应 <code>mainReactor</code> 的角色叫做 <code>Boss</code>，而对应 <code>subReactor</code> 的角色叫做 <code>Worker</code>。<code>Boss</code> 负责分配请求，创建 Selector，用于不断监听 Socket 连接、客户端的读写操作等；<code>Worker</code> 负责执行，负责处理 Selector 派发的读写操作。</p><p><code>Netty</code> 中 <code>Reactor</code> 模式的参与者主要有下面一些组件：</p><p><img src="/assets/img/reactor.jpg" alt="reactor"></p><ul><li><code>Selector</code>(对应多路复用器 <code>Demultiplexer</code>)</li><li><code>EventLoopGroup/EventLoop</code>(对应 <code>Reactor</code> 模式中的分发者 <code>Dispatcher</code>)</li><li><code>ChannelPipeline</code>(对应请求处理器 <code>Handler</code>，真正干活的)</li></ul><p>不管是 <code>Boos</code> 线程还是 <code>Worker</code> 线程，所做的事情均分为以下三个步骤: </p><ol><li>轮询注册在 <code>selector</code> 上的 <code>I/O</code> 事件 </li><li>处理 <code>I/O</code> 事件 </li><li>执行异步 <code>task</code></li></ol><p>对于 <code>Boos</code> 线程来说，第一步轮询出来的基本都是 <code>accept</code> 事件，表示有新的连接，而 <code>Worker</code> 线程轮询出来的基本都是 <code>read/write</code> 事件，表示网络的读写事件。</p><p>新连接的建立 </p><ol><li><code>Boss</code> 的 <code>Selector</code> 检测到有新的连接 </li><li>将新的连接注册到 <code>Worker</code> 线程组 </li><li>注册新连接的读事件到 <code>Worker</code> 的 <code>Selector</code> 中</li></ol><p>新连接的读取和请求处理</p><ol><li>数据准备好了</li><li><code>Worker</code> 知道了，同步调用 <code>unsafe.read</code> 获得客户端传输的数据，交给 <code>ChannelPipeline</code> 处理</li><li><code>ChannelPipeline</code> 处理，<code>decode</code> -&gt; 处理数据 -&gt; <code>encode</code> 结果，这些过程都是异步的</li><li>用户调用 <code>channel.writeAndFlush</code>，写就绪</li><li><code>Worker</code> 知道了，<code>unsafe.forceflush</code> 写回结果给客户端</li></ol><p><code>ChannelPipeline</code> 处理过程类似下面这样，一般会有 <code>decode</code>，用户自定义的 <code>handler</code>，和 <code>encode</code>：</p><p><img src="/assets/img/netty_pipeline.png" alt="netty pipelin"></p><p><code>ChannelInBoundHandler</code> 对从客户端发往服务器的报文进行处理，一般用来执行拆包/粘包，解码，读取数据，业务处理等；<code>ChannelOutBoundHandler</code> 对从服务器发往客户端的报文进行处理，一般用来进行编码，发送报文到客户端。</p><h4 id="编码与解码-序列化与反序列化"><a href="#编码与解码-序列化与反序列化" class="headerlink" title="编码与解码(序列化与反序列化)"></a>编码与解码(序列化与反序列化)</h4><p>想要远程传输对象就得将对象变为二进制码，这就需要序列化工具来完成这些操作。</p><p>在 <code>Dubbo</code>中，同时支持多种序列化方式，例如：</p><ol><li><code>dubbo</code> 序列化：阿里尚未开发成熟的高效 <code>java</code> 序列化实现，阿里不建议在生产环境使用它</li><li><code>hessian2</code> 序列化：<code>hessian</code> 是一种跨语言的高效二进制序列化方式。</li><li><code>json</code> 序列化：目前有两种实现，一种是采用的阿里的 <code>fastjson</code> 库，另一种是采用 <code>Dubbo</code> 中自己实现的简单 <code>json</code> 库，但其实现都不是特别成熟，而且 <code>json</code> 这种文本序列化性能一般不如上面两种二进制序列化。</li><li><code>java</code> 序列化：主要是采用 <code>JDK</code> 自带的 <code>Java</code> 序列化实现，性能很不理想。</li></ol><p><code>Dubbo</code> 默认是使用 <code>Hessian</code> 作为序列化与反序列化的工具的，<code>Hessian</code> 的序列化语法看<a href="http://hessian.caucho.com/doc/hessian-serialization.html" target="_blank" rel="noopener">这里</a>。</p><p><strong>与跨平台的 <code>protobuf</code> 对比：</strong></p><ol><li><code>protobuf</code> 相比于 <code>hessian</code> 而言是要定义消息类型的，客户端与服务器都需要定义相同的消息类型(<code>.proto</code>文件)，配置方面较复杂，但是相应的消息的压缩率也就更高了，<code>protobuf</code> 存储类型只需要一个字节(8位)，即前5位代表顺序，后3位代表 <code>type</code>，更具体的 <code>protobuf</code> 的编码规则请看<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">官方文档</a>；而 <code>hessian</code> 则会把类型的全量名称都加上，因而效率会稍微低一点，具体的 <code>hessian</code> 编码规则请看<a href="http://hessian.caucho.com/doc/hessian-serialization.html" target="_blank" rel="noopener">官方文档</a>。所以如果对性能要求不是特别高(如即时消息系统，如QQ等)，而且是使用 <code>java</code> 编写的系统而言，用 <code>hessian</code> 就足够了，这就是 <code>Dubbo</code> 默认使用 <code>hessian</code> 的原因吧。</li><li><code>hessian</code> 一般是用于 <code>java</code> 平台的，<code>protobuf</code> 是跨平台的。</li><li><code>protobuf</code> 比 <code>hessian</code> 压缩率、速率更高。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dubbo-框架的介绍以及源码阅读&quot;&gt;&lt;a href=&quot;#Dubbo-框架的介绍以及源码阅读&quot; class=&quot;headerlink&quot; title=&quot;Dubbo 框架的介绍以及源码阅读&quot;&gt;&lt;/a&gt;Dubbo 框架的介绍以及源码阅读&lt;/h1&gt;&lt;h2 id=&quot;Dubbo-简介&quot;&gt;&lt;a href=&quot;#Dubbo-简介&quot; class=&quot;headerlink&quot; title=&quot;Dubbo 简介&quot;&gt;&lt;/a&gt;Dubbo 简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Apache Dubbo|ˈdʌbəʊ|&lt;/code&gt; 是阿里开源的一个 RPC 框架。&lt;/p&gt;
&lt;p&gt;和大多数 &lt;code&gt;RPC&lt;/code&gt; 系统一样， &lt;code&gt;dubbo&lt;/code&gt; 基于一个理念：定义一个服务，确定远程调用的方法，并且包含他们的参数和返回类型。在服务端，服务器实现接口并且运行一个 &lt;code&gt;dubbo&lt;/code&gt; 的服务来处理来自客户端的请求；在客户端，客户端持有提供与服务端方法一模一样的桩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://1016990109.github.io/tags/java/"/>
    
      <category term="RPC" scheme="http://1016990109.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第二章</title>
    <link href="http://1016990109.github.io/2018/05/18/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/05/18/Node-js-设计模式读书笔记-第二章/</id>
    <published>2018-05-18T08:51:57.000Z</published>
    <updated>2018-05-24T12:53:13.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js-Essential-Patterns-Node-js-基本模式"><a href="#Node-js-Essential-Patterns-Node-js-基本模式" class="headerlink" title="Node.js Essential Patterns(Node.js 基本模式)"></a>Node.js Essential Patterns(Node.js 基本模式)</h1><h2 id="The-callback-pattern-回调模式"><a href="#The-callback-pattern-回调模式" class="headerlink" title="The callback pattern(回调模式)"></a>The callback pattern(回调模式)</h2><p>回调是<code>reactor</code>模式中<code>handler</code>的实例。</p><h3 id="The-continuation-passing-pattern-连续传递模式"><a href="#The-continuation-passing-pattern-连续传递模式" class="headerlink" title="The continuation-passing pattern(连续传递模式)"></a>The continuation-passing pattern(连续传递模式)</h3><p>在 JavaScript 中回调就是传入作为参数传入另外一个函数中的函数，并且在操作完成后调用。在函数式编程中，这种传递结果的方式被称为<code>continuation-passing style(CPS)</code>。这是个一般概念，并不是针对异步操作。实际上，它只是通过将结果作为参数传递给另一个函数（回调函数）来传递结果，然后在主体逻辑中调用回调函数拿到操作结果，而不是直接将其返回给调用者。</p><a id="more"></a><h4 id="Synchronous-continuation-passing-style-同步连续传递风格"><a href="#Synchronous-continuation-passing-style-同步连续传递风格" class="headerlink" title="Synchronous continuation-passing style(同步连续传递风格)"></a>Synchronous continuation-passing style(同步连续传递风格)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  callback(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>add()</code>函数就是一个同步的 CPS 函数，意味着只有回调函数执行完成它才会返回值。</p><h4 id="Asynchronous-continuation-passing-style-异步连续传递风格"><a href="#Asynchronous-continuation-passing-style-异步连续传递风格" class="headerlink" title="Asynchronous continuation-passing style(异步连续传递风格)"></a>Asynchronous continuation-passing style(异步连续传递风格)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">additionAsync</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> callback(a + b), <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setTimeout()</code>触发了一个异步操作，不需要等待回调函数执行完就会返回到<code>additionAsync()</code>的控制权，然后再回到<code>additionAsync</code>的调用者。这个属性对于<code>Node.js</code>是至关重要的，当一个异步的请求发出后会立即回到事件循环中， 因而允许队列中  新的事件被处理。下图描述了事件循环是怎么运作的：</p><p><img src="assets/img/event_loop2.png" alt="事件循环"></p><h4 id="Non-continuation-passing-style-callbacks-非连续传递风格的回调"><a href="#Non-continuation-passing-style-callbacks-非连续传递风格的回调" class="headerlink" title="Non-continuation-passing style callbacks(非连续传递风格的回调)"></a>Non-continuation-passing style callbacks(非连续传递风格的回调)</h4><p>某些情况下，比如一个回调函数作为参数传入，我们可能会以为这是一个异步操作或者是使用 CPS，但是有例外：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>].map(<span class="function"><span class="params">element</span> =&gt;</span> element - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [0, 4, 6]</span></span><br></pre></td></tr></table></figure><p>这就是一个同步的调用。</p><h3 id="Synchronous-or-asynchronous-同步还是异步"><a href="#Synchronous-or-asynchronous-同步还是异步" class="headerlink" title="Synchronous or asynchronous?(同步还是异步?)"></a>Synchronous or asynchronous?(同步还是异步?)</h3><p>代码的执行顺序会因同步或异步的执行方式产生根本性的改变。这对整个应用程序的流程，正确性和效率都产生了重大影响。以下是对这两种模式的范例和缺陷的分析：</p><h4 id="An-unpredictable-function-一个不可预测的函数"><a href="#An-unpredictable-function-一个不可预测的函数" class="headerlink" title="An unpredictable function(一个不可预测的函数)"></a>An unpredictable function(一个不可预测的函数)</h4><p>最危险的情况之一就是使一个 API 在某种特定情况下是同步执行的但是在另一种情况却是异步执行的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inconsistentRead</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[filename]) &#123;</span><br><span class="line">    <span class="comment">// 同步执行回调</span></span><br><span class="line">    callback(cache[filename])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache[filename] = data</span><br><span class="line">      callback(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数使用 cache 缓存文件读取结果，这个函数是危险的，因为当缓存命中时表现为同步的，当缓存未命中表现为异步的。</p><h4 id="Unleashing-Zalgo-解放-Zalgo"><a href="#Unleashing-Zalgo-解放-Zalgo" class="headerlink" title="Unleashing Zalgo(解放 Zalgo)"></a>Unleashing Zalgo(解放 Zalgo)</h4><p>围绕着同步或异步行为的不确定性，几乎总是导致非常难追踪的 Bug，这被称为<code>Zalgo</code>。</p><blockquote><p>注意：更多关于 Zalgo 的信息，参见 Oren Golan 的<a href="https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md" target="_blank" rel="noopener">Don’t Release Zalgo!(不要释放 Zalgo!)</a>和 Isaac Z. Schlueter 的<a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony" target="_blank" rel="noopener">Designing APIs for Asynchrony(异步 API 设计)</a>。</p></blockquote><p>看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFileReader</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeners = []</span><br><span class="line">  inconsistentRead(filename, value =&gt; &#123;</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(value))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onDataReady: <span class="function"><span class="params">listener</span> =&gt;</span> listeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数被调用的时候创建了一个作为通知器的对象，允许为一个  读文件操作设置多个监听。当文件读取完后或者数据可用后所有的监听都会被调用，现在使用上面的<code>inconsistentRead</code>函数来完成这个功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reader1 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">reader1.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'First call data: '</span> + data)</span><br><span class="line">  <span class="comment">// 之后再次通过fs读取同一个文件</span></span><br><span class="line">  <span class="keyword">const</span> reader2 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">  reader2.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Second call data: '</span> + data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>输出是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">First call data: some data</span><br></pre></td></tr></table></figure><p>会发现，第二个操作的回调未被调用，这是因为第一次调用时没有缓存，<code>inconsistentRead</code>是异步调用的，这个时候第一个回调函数已经加入到监听列表中了，然而第二次调用时，缓存中已经存在了，所以<code>inconsistentRead</code>是同步调用的，这个时候监听列表中还没有第二个回调函数，故而之后也没有再调用了。</p><h4 id="Using-asynchronous-API-使用同步-API"><a href="#Using-asynchronous-API-使用同步-API" class="headerlink" title="Using asynchronous API(使用同步 API)"></a>Using asynchronous API(使用同步 API)</h4><p>从上面<code>unleashing Zalgo</code>中我们知道，清楚地定义<code>API</code>性质是非常重要的：同步还是异步？</p><p>可以使整个函数同步来解决上面的问题，<code>readFileSync</code>代替<code>readFile</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consistentReadSync</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[filename]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[filename]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cache[filename] = fs.readFileSync(filename, <span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">return</span> cache[filename]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有理由为一个同步函数使用<code>CPS</code>风格。</p><blockquote><p>注意：最好为纯同步函数使用<code>direct style</code>。</p></blockquote><p>使用同步 API 替代异步 API 需要注意：</p><ul><li>同步 API 并不适用所有场景。</li><li>同步 API 会阻塞事件循环，降低了应用性能，破坏了<code>JavaScript</code>并发模型。</li></ul><p>如果只是读取有限的文件，那么<code>consistentReadSync</code>并不会对事件循环的性能造成多大影响，但是当文件很多时就不同了。</p><p>很多时候<code>Node.js</code>是不鼓励使用同步函数的，但是有时候同步函数也是最简单、最有效的解决方案。所以要根据情况来选择使用同步的方法还是异步的。</p><p>当对程序处理并发请求影响不大的时候使用同步(例如读取程序配置文件)。</p><h3 id="Deffered-execution-延时处理"><a href="#Deffered-execution-延时处理" class="headerlink" title="Deffered execution(延时处理)"></a>Deffered execution(延时处理)</h3><p>另外一种处理<code>consistentRead</code>的方法就是使整个函数都是异步的，使用<code>process.nextTick()</code>使得回调函数在下一个事件循环周期调用而不是立即调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consistentReadAsync</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[filename]) &#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> callback(cache[filename]))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异步函数</span></span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache[filename] = data</span><br><span class="line">      callback(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个延迟执行的 API 是<code>setImmediate()</code>，尽管他们看起来相似，但是在语义上完全不同，<code>process.nextTick()</code>在任何 I/O 事件触发前执行，而<code>setImmediate()</code>在队列中所有的 I/O 事件执行之后执行。</p><h3 id="Node-js-callback-conventions-Node-js-回调风格"><a href="#Node-js-callback-conventions-Node-js-回调风格" class="headerlink" title="Node.js callback conventions(Node.js 回调风格)"></a>Node.js callback conventions(Node.js 回调风格)</h3><p>对于<code>Node.js</code>而言，<code>CPS</code>风格的 API 和回调函数遵循一组特殊的约定。这些约定不只是适用于<code>Node.js</code>核心 API，对于它们之后也是绝大多数用户级模块和应用程序也很有意义。因此，我们了解这些风格，并确保我们在需要设计异步 API 时遵守规定显得至关重要。</p><h4 id="Callbacks-come-last-回调函数在最后"><a href="#Callbacks-come-last-回调函数在最后" class="headerlink" title="Callbacks come last(回调函数在最后)"></a>Callbacks come last(回调函数在最后)</h4><p>在所有核心 Node.js 方法中，标准约定是当函数在输入中接受回调时，必须作为最后一个参数传递。我们以下面的 Node.js 核心 API 为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(filename, [options], callback)</span><br></pre></td></tr></table></figure><p>从前面的例子可以看出，即使是在可选参数存在的情况下，回调也始终置于最后的位置。其原因是在回调定义的情况下，函数调用更可读。</p><h4 id="Error-comes-first-错误处理在最前"><a href="#Error-comes-first-错误处理在最前" class="headerlink" title="Error comes first(错误处理在最前)"></a>Error comes first(错误处理在最前)</h4><p>在<code>Node.js</code>中，在<code>CPS</code>中产生的错误总是作为第一个参数，这样便于调试，没有错误则第一个参数为 null 或者 undefined，在正式处理结果之前先判断 error 这样有利于 debug，错误类型为<code>Error</code>型，普通的字符串或者数字是不应该作为错误被传递的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'foo.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) handleError(err)</span><br><span class="line">  <span class="keyword">else</span> processData(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Propagating-errors-传递错误"><a href="#Propagating-errors-传递错误" class="headerlink" title="Propagating errors(传递错误)"></a>Propagating errors(传递错误)</h4><p>在同步函数或者直接风格中，使用<code>throw</code>是最直接的，使得错误从调用栈中弹出直到被捕获。</p><p>但是在异步调用中，比较好的错误处理方式是将错误传递到回调链中的下一个回调函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readJSON</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> parsed</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="comment">//传递错误并退出当前函数</span></span><br><span class="line">      <span class="keyword">return</span> callback(err)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//解析文件内容</span></span><br><span class="line">      parsed = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">//捕获解析中的错误</span></span><br><span class="line">      <span class="keyword">return</span> callback(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有错误，只传递数据</span></span><br><span class="line">    callback(<span class="literal">null</span>, parsed)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有错误直接<code>return</code>避免继续执行。</p><h4 id="Uncaught-exceptions"><a href="#Uncaught-exceptions" class="headerlink" title="Uncaught exceptions"></a>Uncaught exceptions</h4><p>在异步回调过程中，错误是难以被捕获的，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readJSONThrows</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err)</span><br><span class="line">    &#125;</span><br><span class="line">    callback(<span class="literal">null</span>, <span class="built_in">JSON</span>.parse(data))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的函数中，如果<code>JSON.parse(data)</code>异常的话是没有办法捕获的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  readJSONThrows(<span class="string">'nonJSON.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'This will not catch the JSON parsing exception'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>catch</code>语句将捕获不到错误，因为错误是在回调函数中产生的。然而，我们仍然有机会在应用程序终止之前执行一些清理或日志记录。事实上，当这种情况发生时，Node.js 会在退出进程之前发出一个名为<code>uncaughtException</code>的特殊事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(</span><br><span class="line">    <span class="string">'This will catch at last the '</span> + <span class="string">'JSON parsing exception: '</span> + err.message</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// Terminates the application with 1 (error) as exit code:</span></span><br><span class="line">  <span class="comment">// without the following line, the application would continue</span></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>uncaughtException</code>会使得应用处于一个不能保证一致的状态 ，而这可能导致不可预见的错误。比如还有未完成的 I/O 请求正在运行或关闭，这可能导致不一致。所以建议，尤其是在生产环境，在收到任何<code>uncaught exception</code>之后停止应用的运行。</p><h3 id="The-module-system-and-its-patterns-模块系统和其中的模式"><a href="#The-module-system-and-its-patterns-模块系统和其中的模式" class="headerlink" title="The module system and its patterns(模块系统和其中的模式)"></a>The module system and its patterns(模块系统和其中的模式)</h3><p>模块可以隐藏不想暴露的函数、变量，是构成大型应用的基础。</p><h4 id="The-revealing-module-pattern-模块模式"><a href="#The-revealing-module-pattern-模块模式" class="headerlink" title="The revealing module pattern(模块模式)"></a>The revealing module pattern(模块模式)</h4><p><code>JavaScript</code> 是没有命名空间的，在全局范围内运行的程序会污染全局命名空间，造成相关变量、数据、方法名的冲突。解决该问题的一个比较流行的做法是使用 <code>模块模式</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> privateFoo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> privateBar = [];</span><br><span class="line">  <span class="keyword">const</span> exported = &#123;</span><br><span class="line">    publicFoo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    publicBar: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> exported;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><p>该模式利用自执行函数创建私有空间，只导出需要暴露的部分，前面的代码中， <code>module</code> 变量只包含了暴露的 <code>API</code>，而内部的其他部分是外面访问不到的。这个模式背后的思想就是用来构建 <code>Node.js</code> 模块系统的基础。</p><h4 id="Node-js-modules-explained-Node-js-模块解释"><a href="#Node-js-modules-explained-Node-js-模块解释" class="headerlink" title="Node.js modules explained(Node.js 模块解释)"></a>Node.js modules explained(Node.js 模块解释)</h4><p><code>CommonJS</code> 是一个旨在规范 <code>JavaScript</code> 生态系统的组织，他们提出了 <code>CommonJS模块规范</code>。<code>Node.js</code> 在此规范之上构建了其模块系统，并添加了一些自定义的扩展。每个模块都在自己的私有空间下运行，所以在模块内定义的本地变量不会污染全局变量。</p><h5 id="A-homemade-module-loader-自定义模块加载器"><a href="#A-homemade-module-loader-自定义模块加载器" class="headerlink" title="A homemade module loader(自定义模块加载器)"></a>A homemade module loader(自定义模块加载器)</h5><p>为了解释加载器是如何工作的，先简单勾勒一个类似的系统，下面的代码模仿了内部函数 <code>require()</code> 的一部分功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadModule</span>(<span class="params">filename, module, require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedSrc = <span class="string">`(function(module, exports, require) &#123;</span></span><br><span class="line"><span class="string">         <span class="subst">$&#123;fs.readFileSync(filename, <span class="string">'utf8'</span>)&#125;</span></span></span><br><span class="line"><span class="string">       &#125;)(module, module.exports, require);`</span>;</span><br><span class="line">  <span class="built_in">eval</span>(wrappedSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块的源码被包装入一个函数，并且是使用模块模式的。区别在于传递了一些参数到模块中，实际上就是 <code>module</code>, <code>exports</code>, <code>require</code>。<code>exports</code> 参数被初始化为 <code>module.exports</code>。</p><blockquote><p>注意：上面只是个示例，其实很少使用 <code>eval</code> 来执行源码，这可能导致注入攻击，使用 <code>eval</code> 要十分谨慎。</p></blockquote><p>现在通过实现 <code>require()</code> 函数来看看这都些变量中的包含了什么内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="function">(<span class="params">moduleName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Require invoked for module: <span class="subst">$&#123;moduleName&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">require</span>.resolve(moduleName);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">require</span>.cache[id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>.cache[id].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模块元数据</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    exports: &#123;&#125;,</span><br><span class="line">    id: id</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//更新缓存</span></span><br><span class="line">  <span class="built_in">require</span>.cache[id] = <span class="built_in">module</span>;</span><br><span class="line">  <span class="comment">//加载模块</span></span><br><span class="line">  loadModule(id, <span class="built_in">module</span>, <span class="built_in">require</span>);</span><br><span class="line">  <span class="comment">//返回导出的变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">require</span>.cache = &#123;&#125;;</span><br><span class="line"><span class="built_in">require</span>.resolve = <span class="function">(<span class="params">moduleName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 通过模块名作为参数resolve一个完整的模块 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面函数模拟了原生 <code>require()</code> 函数，并不能准确完美地反应真实的行为，但是却能帮助我们理解一个模块是怎么被定义和加载的：</p><ol><li>一个模块的名字作为输入被接收，我们需要做的第一件事就是找到这个模块的路径(我们称之为<code>id</code>)，这个依靠 <code>require.resolve()</code>来完成。</li><li>如果模块过去被加载过，那它应该存在于缓存。这种情况下我们直接返回就行。</li><li>如果模块尚未加载，我们将初始化首次加载模块环境。具体来说就是，创建一个模块(<code>module</code>)对象，其中包含一个 <code>exports</code> (被初始化为空的对象字面量<code>{}</code>)属性。该属性将被模块的代码用于导出模块的公共 <code>API</code>。</li><li>模块被缓存。</li><li>像前面所看到的一样，源代码从文件中被加载，接着被执行。我们给模块提供一个刚才创建的 <code>module</code> 对象和一个 <code>require()</code> 函数的引用。模块通过修改或替换 <code>module.exports</code> 来提供公共 <code>API</code>。</li><li>最后，包含公共 <code>API</code> 的 <code>module.exports</code> 返回给调用者。</li></ol><h5 id="Defining-a-module-定义一个模块"><a href="#Defining-a-module-定义一个模块" class="headerlink" title="Defining a module(定义一个模块)"></a>Defining a module(定义一个模块)</h5><p>让我们看看怎么定义一个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载另一个依赖</span></span><br><span class="line"><span class="keyword">const</span> dependency = <span class="built_in">require</span>(<span class="string">'./anotherModule'</span>);</span><br><span class="line"><span class="comment">//一个私有函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Well done <span class="subst">$&#123;dependency.username&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//API 被导出给外部用</span></span><br><span class="line"><span class="built_in">module</span>.exports.run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  log(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了 <code>module.exports</code> 的内容其他都是私有的，当模块被加载的时候这个变量的内容被返回且被缓存。</p><h5 id="Defining-globals-定义全局内容"><a href="#Defining-globals-定义全局内容" class="headerlink" title="Defining globals(定义全局内容)"></a>Defining globals(定义全局内容)</h5><p>即使在模块中声明的所有变量和函数都在其本地范围内定义，仍然可以定义全局变量。事实上，模块系统公开了一个名为 <code>global</code> 的特殊变量。分配给此变量的所有内容将会被定义到全局环境下。</p><blockquote><p>注意：污染全局变量是不好的，模块化的优势就不在了，所以只有当你真的需要用的时候再用吧！</p></blockquote><h5 id="module-exports-vs-exports"><a href="#module-exports-vs-exports" class="headerlink" title="module.exports vs exports"></a>module.exports vs exports</h5><p><code>exports</code> 只是 <code>module.exports</code> 的一个引用，所以在 <code>exports</code> 中添加新属性是有效的，能更新 <code>module.exports</code> 的内容，而对 <code>exports</code> 重新赋值则不会更新 <code>module.exports</code>，只是让 <code>exports</code> 指向了另一个对象；但是对 <code>module.exports</code> 重新赋值就是实实在在地更改了 <code>module</code> 了，是能起作用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有效</span></span><br><span class="line">exports.foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">"hello"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无效</span></span><br><span class="line">exports = &#123;</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有效</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="The-require-function-is-synchronous-require函数是同步的"><a href="#The-require-function-is-synchronous-require函数是同步的" class="headerlink" title="The require function is synchronous(require函数是同步的)"></a>The require function is synchronous(require函数是同步的)</h5><p>原生的 <code>require()</code> 函数也是同步的，所以对 <code>module.exports</code> 的赋值操作也是要同步的。下面这种代码就是错误的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这就限制了我们绝大多数情况下都是使用同步的代码定义模块，这就是 <code>Node.js</code> 核心库为一些异步函数提供可选的同步的 <code>API</code> 的原因。</p><p>如果需要在模块初始化过程中使用异步方法，那么可以返回一个未初始化的模块，让使用者之后去初始化这个模块，这就导致了 <code>require</code> 不能保证模块被立即使用。</p><p>出于好奇，你可能想知道为什么 <code>Node.js</code> 早期是有异步的 <code>require()</code> 函数后来又被移除了，这是因为在初始化的过程中处理异步的I/O带来的复杂性比优势大太多了。</p><h5 id="The-resolve-algorithm-resolve算法"><a href="#The-resolve-algorithm-resolve算法" class="headerlink" title="The resolve algorithm(resolve算法)"></a>The resolve algorithm(resolve算法)</h5><p>为了解决<a href="https://zh.wikipedia.org/wiki/相依性地狱" target="_blank" rel="noopener">依赖地狱</a>问题，<code>Node.js</code> 根据模块的被加载的位置来加载不同版本的模块，这些理念也被运用到 <code>npm</code> 和 <code>require</code> 的 <code>resolve</code> 算法中。</p><p><code>resolve()</code> 接收 <code>moduleName</code> 作为参数，并返回模块的完整路径。</p><p><code>resolve</code> 算法的三个主要分支：</p><ol><li><strong>File modules</strong>(文件模块)：模块名是 <code>/</code> 开头认为是绝对路径，以 <code>./</code> 开头则认为是相对当前使用 <code>require</code> 的模块的路径。</li><li><strong>Core modules</strong>(核心模块)：模块名不以 <code>/</code> 或 <code>./</code> 开头则优先从核心库开始查找。</li><li><strong>Package modules</strong>(包模块)：核心库没有查找到时，再从当前目录的 <code>node_modules</code> 中查找相应的模块，没有则继续往上层的 <code>node_modules</code> 中找直到系统的根目录。</li></ol><p>对于文件和包模块，单个文件和目录也可以匹配到 <code>moduleName</code>。特别地，算法将尝试匹配以下内容：</p><ul><li><code>&lt;moduleName&gt;.js</code></li><li><code>&lt;moduleName&gt;/index.js</code></li><li>在<code>&lt;moduleName&gt;/package.json</code> 的 <code>main</code> 值下声明的文件或目录</li></ul><p>更详尽的 <code>resolve</code> 算法请看<a href="https://nodejs.org/api/modules.html#modules_all_together" target="_blank" rel="noopener">这里</a>。</p><p><code>node_modules</code> 目录实际上是 <code>npm</code> 安装每个包并存放相关依赖关系的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myApp</span><br><span class="line">├── foo.js</span><br><span class="line">└── node_modules</span><br><span class="line">    ├── depA</span><br><span class="line">    │   └── index.js</span><br><span class="line">    └── depB</span><br><span class="line">        │</span><br><span class="line">        ├── bar.js</span><br><span class="line">        ├── node_modules</span><br><span class="line">        ├── depA</span><br><span class="line">        │    └── index.js</span><br><span class="line">        └── depC</span><br><span class="line">             ├── foobar.js</span><br><span class="line">             └── node_modules</span><br><span class="line">                 └── depA</span><br><span class="line">                     └── index.js</span><br></pre></td></tr></table></figure><p>可以发现 <code>depA</code>, <code>depB</code>, <code>depC</code> 都有它们自己的依赖，所以同样使用 <code>require(&#39;depA&#39;)</code>，在不同的地方加载就会加载不同的模块，如：</p><ul><li>在 <code>/myApp/foo.js</code> 中调用的 <code>require(&#39;depA&#39;)</code> 会加载 <code>/myApp/node_modules/depA/index.js</code></li><li>在 <code>/myApp/node_modules/depC/foobar.js</code> 中调用的 <code>require(&#39;depA&#39;)</code> 会加载 <code>/myApp/node_modules/depC/node_modules/depA/index.js</code></li></ul><p><code>resolve</code> 算法是 <code>Node.js</code> 依赖关系管理的核心部分，它的存在使得即便应用程序拥有成百上千包的情况下也不会出现冲突和版本不兼容的问题。</p><p>当我们调用 <code>require()</code> 时，解析算法对我们是透明的。然而，仍然可以在任何模块中通过调用 <code>require.resolve()</code> 使用该算法。</p><h5 id="The-module-cache-模块缓存"><a href="#The-module-cache-模块缓存" class="headerlink" title="The module cache(模块缓存)"></a>The module cache(模块缓存)</h5><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node-js-Essential-Patterns-Node-js-基本模式&quot;&gt;&lt;a href=&quot;#Node-js-Essential-Patterns-Node-js-基本模式&quot; class=&quot;headerlink&quot; title=&quot;Node.js Essential Patterns(Node.js 基本模式)&quot;&gt;&lt;/a&gt;Node.js Essential Patterns(Node.js 基本模式)&lt;/h1&gt;&lt;h2 id=&quot;The-callback-pattern-回调模式&quot;&gt;&lt;a href=&quot;#The-callback-pattern-回调模式&quot; class=&quot;headerlink&quot; title=&quot;The callback pattern(回调模式)&quot;&gt;&lt;/a&gt;The callback pattern(回调模式)&lt;/h2&gt;&lt;p&gt;回调是&lt;code&gt;reactor&lt;/code&gt;模式中&lt;code&gt;handler&lt;/code&gt;的实例。&lt;/p&gt;
&lt;h3 id=&quot;The-continuation-passing-pattern-连续传递模式&quot;&gt;&lt;a href=&quot;#The-continuation-passing-pattern-连续传递模式&quot; class=&quot;headerlink&quot; title=&quot;The continuation-passing pattern(连续传递模式)&quot;&gt;&lt;/a&gt;The continuation-passing pattern(连续传递模式)&lt;/h3&gt;&lt;p&gt;在 JavaScript 中回调就是传入作为参数传入另外一个函数中的函数，并且在操作完成后调用。在函数式编程中，这种传递结果的方式被称为&lt;code&gt;continuation-passing style(CPS)&lt;/code&gt;。这是个一般概念，并不是针对异步操作。实际上，它只是通过将结果作为参数传递给另一个函数（回调函数）来传递结果，然后在主体逻辑中调用回调函数拿到操作结果，而不是直接将其返回给调用者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第一章</title>
    <link href="http://1016990109.github.io/2018/05/11/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/05/11/Node-js-设计模式读书笔记-第一章/</id>
    <published>2018-05-11T12:00:45.000Z</published>
    <updated>2018-05-22T03:12:52.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Welcome-to-the-Node-js-Platform"><a href="#Welcome-to-the-Node-js-Platform" class="headerlink" title="Welcome to the Node.js Platform"></a>Welcome to the Node.js Platform</h1><h2 id="Small-modules-小模块"><a href="#Small-modules-小模块" class="headerlink" title="Small modules(小模块)"></a>Small modules(小模块)</h2><p><code>Node.js</code>使用<code>module</code>(模块)的概念组织代码的结构。<br><code>package</code>可提供复用的模块，有一个 module 作为入口。<br><code>Node.js</code>中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：</p><a id="more"></a><blockquote><ul><li>“Small is beautiful.”(小而精)</li><li>“Make each program do one thing well.” (每个程序只有单一的职责)</li></ul></blockquote><p><code>Node.js</code> 通过官方包管理工具<code>npm</code>解决包之间的依赖问题，每个<code>package</code>都有它自己的依赖，故而一个程序中多个<code>package</code>能够无冲突地安装。应用程序都是由一个个很小的、单职责的依赖构成的。</p><p><strong>小模块</strong>应该有的特性：</p><blockquote><ul><li>Easier to understand and use(易理解、易用)</li><li>Simpler to test and maintain(易于测试和维护)</li><li>Perfect to share with the browser(完美支持浏览器)</li></ul></blockquote><p><strong>DRY(Dont’t Repeat Yourself)原则</strong></p><h2 id="Small-surface-area-暴露需要的接口"><a href="#Small-surface-area-暴露需要的接口" class="headerlink" title="Small surface area(暴露需要的接口)"></a>Small surface area(暴露需要的接口)</h2><p>一般使用者只会用到很有限的功能，而很少去  扩展一个模块，所以<code>Node.js</code>的很多模块只会暴露一个函数或者一个构造器，然后把更细节的东西都放在函数或者构造器里，这样能帮助  使用者认清什么是主要的什么是次要的.</p><p>模块是不允许被扩展的，看起来扩展性低，但实际上有很多优势：减少了应用场景(这样考虑的情况就少了，容易实现)，简化了实现，便于维护，提高了可用性。</p><h2 id="Simplicity-and-progmatism-简单而实用"><a href="#Simplicity-and-progmatism-简单而实用" class="headerlink" title="Simplicity and progmatism(简单而实用)"></a>Simplicity and progmatism(简单而实用)</h2><blockquote><p>简单就是复杂到极致。—— 达尔文</p></blockquote><blockquote><p>设计必须简单， 不管是实现还是接口。实现的简洁比接口的简洁更重要。设计中最重要的就是简洁。—— Richard P.Gabriel(一位杰出的计算机科学家)</p></blockquote><p>设计简单的而不是完美或功能完备的软件是一个好的实践：</p><ul><li> 更容易实现</li><li>更少的资源，传输更快</li><li>更容易适应</li><li>容易维护和理解</li></ul><p>设计简单这个原则同样也适用于<code>JavaScript</code>，简单函数、闭包、<code>object</code>替代了复杂的类继承。</p><h2 id="Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6"><a href="#Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6" class="headerlink" title="Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)"></a>Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)</h2><h3 id="The-let-and-const-keywords-let-和-const-关键字"><a href="#The-let-and-const-keywords-let-和-const-关键字" class="headerlink" title="The let and const keywords(let 和 const 关键字)"></a>The let and const keywords(let 和 const 关键字)</h3><p>在之前(ES2015 之前)，<code>js</code>只支持函数作用域和全局作用域，例如在 if 中声明一个变量却能在 if 块之外访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>但是使用<code>let</code>关键字后，if 块外就访问不到其中声明的变量了，这在一定程度上能减少因为误操作其中的变量而导致的 bug：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p><code>const</code>关键字用于声明不可变变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">'This will never change'</span></span><br><span class="line">x = <span class="string">'...'</span></span><br><span class="line"><span class="comment">//TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>const</code>  是意味着变量的绑定不变而不是内容不变，示例入下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cosnt x = &#123;&#125;</span><br><span class="line">x.name = <span class="string">'John'</span><span class="comment">//work</span></span><br><span class="line"></span><br><span class="line">x = <span class="literal">null</span><span class="comment">//don't work</span></span><br></pre></td></tr></table></figure><p>通常来说引入模块使用 <code>const</code>防止模块发生变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> path = <span class="string">'./some/path'</span> <span class="comment">//fail</span></span><br></pre></td></tr></table></figure><p>如果你想要创建一个不可更改的对象，<code>const</code>是不够的，你可以使用 ES5 的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">Object.freeze()</a>或者 <a href="https://www.npmjs.com/package/deep-freeze" target="_blank" rel="noopener">deep-freeze</a>模块，或者我使用<code>react</code>框架时候经常用的<a href="https://www.npmjs.com/package/immutable" target="_blank" rel="noopener">immutable</a>模块也可以。</p><blockquote><p>扩展——这里提一下<strong>ES5</strong>中<code>freeze</code>和<code>seal</code>的区别，<code>seal</code>只限制无法增加和删除对象属性 ，而<code>freeze</code>在<code>seal</code>的基础上还限制了不可更改对象的属性。</p></blockquote><h3 id="The-arrow-function-箭头函数"><a href="#The-arrow-function-箭头函数" class="headerlink" title="The arrow function(箭头函数)"></a>The arrow function(箭头函数)</h3><p>箭头函数是<strong>ES6</strong>的一大亮点，能很大程度上简化代码。一个参数可以不需要圆括号，函数体只有一行且结果为返回值可不需要花括号，具体示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> event = numbers.filter(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event2 = numbers.filter(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>箭头函数中 this 的指向跟随父函数，示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DelayedGreeter</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DelayedGreeter.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> DelayedGreeter(<span class="string">'World'</span>).greet() <span class="comment">//Hello undefined</span></span><br><span class="line"></span><br><span class="line">DelayedGreeter.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> DelayedGreeter(<span class="string">'World'</span>).greet() <span class="comment">//Hello World</span></span><br></pre></td></tr></table></figure><h3 id="Class-syntax-Class-语法"><a href="#Class-syntax-Class-语法" class="headerlink" title="Class syntax(Class 语法)"></a>Class syntax(Class 语法)</h3><p><code>class</code>只是个语法糖，使用 class 实现对象继承并不是通过<code>class</code>继承的，还是通过内部的 prototypes，properties 实现继承，但是<code>class</code>使得程序可读性变强了。</p><p>让我们来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂，晦涩难懂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, surname, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.surname = surname</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.surname</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.older = <span class="function"><span class="keyword">function</span>(<span class="params">person1, person2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//易懂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, surname, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.surname = surname</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.surname</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> older(person1, person2) &#123;</span><br><span class="line">    <span class="keyword">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonWithMiddlename</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, middlename, surname, age) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, surname, age)</span><br><span class="line">    <span class="keyword">this</span>.middlename = middlename</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' '</span> + <span class="keyword">this</span>.middlename + <span class="string">' '</span> + <span class="keyword">this</span>.surname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Enhanced-object-literals-对象字面量语法增强"><a href="#Enhanced-object-literals-对象字面量语法增强" class="headerlink" title="Enhanced object literals(对象字面量语法增强)"></a>Enhanced object literals(对象字面量语法增强)</h3><ul><li>缺省键值，属性名和变量名相同时可省略属性名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">22</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">17</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;</span><br></pre></td></tr></table></figure><ul><li>计算属性，属性可以是由变量计算而来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> namespace = <span class="string">'-webkit-'</span></span><br><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">  [namespace + <span class="string">'box-sizing'</span>]: <span class="string">'border-box'</span>,</span><br><span class="line">  [namespace + <span class="string">'box-shadow'</span>]: <span class="string">'10px 10px 5px #888888'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getter 和 setter</li></ul><p>先看例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'George'</span>,</span><br><span class="line">  surname: <span class="string">'Boole'</span>,</span><br><span class="line">  get fullname() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">''</span> + <span class="keyword">this</span>.surname</span><br><span class="line">  &#125;,</span><br><span class="line">  set fullname(fullname) &#123;</span><br><span class="line">    <span class="keyword">let</span> parts = fullname.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">this</span>.name = parts[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">this</span>.surname = parts[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.fullname) <span class="comment">// "George Boole"</span></span><br><span class="line"><span class="built_in">console</span>.log((person.fullname = <span class="string">'Alan Turing'</span>)) <span class="comment">// "Alan Turing"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "Alan"</span></span><br></pre></td></tr></table></figure><p>可以看到第二个 console.log 输出的是“Alan Turing”，这是因为调用 set 后默认返回 get 获得的值。</p><h3 id="Map-and-Set-collections-Map-和-Set-集合"><a href="#Map-and-Set-collections-Map-和-Set-集合" class="headerlink" title="Map and Set collections(Map 和 Set 集合)"></a>Map and Set collections(Map 和 Set 集合)</h3><p>原来我们建立 hash map 的时候都是用<code>object</code>来完成的，而现在可以直接使用<code>Map</code>原型，提供了 set、get、has、delete 方法和 size 属性，比使用<code>object</code>更加直接、简单，遍历可使用<code>for...of</code>语法，这种遍历方式是和 Map 中属性的插入顺序是一样的(这在普通<code>object</code>中是无法保证的)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tests = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">   tests.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>+<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">   tests.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>*<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">   tests.set(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span>/<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> tests) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log((entry[<span class="number">0</span>]() === entry[<span class="number">1</span>])   <span class="string">'PASS'</span> : <span class="string">'FAIL'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code>只允许存在不同的值，和数学上的集合是一个概念，里面内容可以是<code>number</code>也可以是<code>object</code>或<code>function</code>，除了 set 换成 add 外其他的都与 map 相同，遍历时每一个 entry 内容是 value。</p><h3 id="WeakMap-and-WeakSet-collections"><a href="#WeakMap-and-WeakSet-collections" class="headerlink" title="WeakMap and WeakSet collections"></a>WeakMap and WeakSet collections</h3><p>顾名思义，<code>WeakMap</code>和<code>WeakSet</code>是<code>Map</code>和<code>Set</code>弱化后的原型，但是这其中并无优劣之分，只是适用于不同的场合。</p><p><code>WeakMap</code>的<strong>key</strong>只能是非空对象，对<strong>key</strong>仅保持弱引用，最大的好处是可以避免内存泄漏，一旦<strong>key</strong>的引用为空或者 undefined，垃圾回收器就可以回收这个对象，但是<code>WeakMap</code>不能迭代遍历。</p><p><code>WeakSet</code>与<code>WeakMap</code>同。</p><h3 id="Template-literals-模板字符串"><a href="#Template-literals-模板字符串" class="headerlink" title="Template literals(模板字符串)"></a>Template literals(模板字符串)</h3><p>使用`代替双引号和单引号，在字符串中可以使用表达式${expression}，可以换行。</p><h3 id="ES6-其他语法"><a href="#ES6-其他语法" class="headerlink" title="ES6 其他语法"></a>ES6 其他语法</h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a>(稍后会详细讲到)</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" target="_blank" rel="noopener">函数默认参数</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Rest_parameters" target="_blank" rel="noopener">剩余参数语法</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="noopener">拓展运算符</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="noopener">new.target</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">代理</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener">反射</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol" target="_blank" rel="noopener">Symbol</a></li></ul><h2 id="The-reactor-pattern"><a href="#The-reactor-pattern" class="headerlink" title="The reactor pattern"></a>The reactor pattern</h2><p><code>reactor</code>模式是 <code>Node.js</code> 异步的核心。</p><h3 id="I-O-is-slow-I-O-操作是慢的"><a href="#I-O-is-slow-I-O-操作是慢的" class="headerlink" title="I/O is slow(I/O 操作是慢的)"></a>I/O is slow(I/O 操作是慢的)</h3><p>I/O 操作可以说是计算机操作中最慢的一环，I/O 的速度可能和网络速度、磁盘速率有关，也可能和其他因素有关，比如用户点击事件等等。</p><h3 id="Blocking-I-O-阻塞-I-O"><a href="#Blocking-I-O-阻塞-I-O" class="headerlink" title="Blocking I/O(阻塞 I/O)"></a>Blocking I/O(阻塞 I/O)</h3><p>传统的阻塞 I/O 模型中，I/O 请求会阻塞之后代码块的运行，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直到请求完成，数据可用，线程都是阻塞的</span></span><br><span class="line">data = socket.read()</span><br><span class="line"><span class="comment">// 请求完成，数据可用</span></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><p>而为了达到并发的  目的，传统的 web 服务器是  选择新开一个线程或进程，这样因为线程(或进程)之间的相互独立性，一个线程(或进程)阻塞并不会影响另一个。</p><p>但是创建一个线程是昂贵的，一个线程需要内存，而且切换线程需要保留线程的上下文等等，所以这种方式并不是最佳实践。</p><h3 id="Non-blocking-I-O-非阻塞-I-O"><a href="#Non-blocking-I-O-非阻塞-I-O" class="headerlink" title="Non-blocking I/O(非阻塞 I/O)"></a>Non-blocking I/O(非阻塞 I/O)</h3><p>与阻塞 I/O 相反，遇到 I/O 请求不会阻塞后续代码的执行，如果访问的资源不可用则会返回一个预定义的常量值。</p><p>非阻塞 I/O 最基本的模式是轮询直到有数据已经返回了，也叫做 <code>忙等待</code>模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resources = [socketA, socketB, pipeA]</span><br><span class="line"><span class="keyword">while</span> (!resources.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resources.length; i++) &#123;</span><br><span class="line">    resource = resources[i]</span><br><span class="line">    <span class="comment">// 进行读操作</span></span><br><span class="line">    <span class="keyword">let</span> data = resource.read()</span><br><span class="line">    <span class="keyword">if</span> (data === NO_DATA_AVAILABLE) &#123;</span><br><span class="line">      <span class="comment">// 此时还没有数据</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// 资源被释放，从队列中移除该链接</span></span><br><span class="line">      resources.remove(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      consumeData(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子已经能有单线程处理多个请求了， 但是不够高效，资源不可用时循环占了太多了 CPU 时间，轮询算法浪费 CPU 时间。</p><h3 id="Event-demultiplexing-事件多路复用"><a href="#Event-demultiplexing-事件多路复用" class="headerlink" title="Event demultiplexing(事件多路复用)"></a>Event demultiplexing(事件多路复用)</h3><p>对于获取非阻塞的资源而言，忙等待模型不是一个理想的技术，大多数现代的操作系统都提供了一种机制来处理并发和非阻塞资源，这个机制被称为<code>同步多路复用</code>。</p><p>这个组件从一系列被监听的资源中收集 I/O 事件并放入队列中，而且会一直处于阻塞状态直到有新的事件可以被处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">socketA, pipeB;</span><br><span class="line">wachedList.add(socketA, FOR_READ);</span><br><span class="line">wachedList.add(pipeB, FOR_READ);</span><br><span class="line"><span class="keyword">while</span>(events = demultiplexer.watch(wachedList)) &#123;</span><br><span class="line">  <span class="comment">// 事件循环</span></span><br><span class="line">  foreach(event <span class="keyword">in</span> events) &#123;</span><br><span class="line">    <span class="comment">// 永远不会阻塞，并且总会有返回值</span></span><br><span class="line">    data = event.resource.read();</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// 资源已经被释放，从观察者队列移除</span></span><br><span class="line">      demultiplexer.unwatch(event.resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 获得数据进行处理</span></span><br><span class="line">      consumeData(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的三个重要步骤：</p><ol><li>资源被添加到一个数据结构中，为每个资源关联一个特定的操作，在这个例子中是 read。</li><li>事件通知器由一组被观察的资源组成，事件通知器是同步和阻塞的直到有资源可以被<code>read</code>，事件触发后会从调用中返回，之后这些事件可以被处理。</li><li>多路复用器返回的每个事件被处理，此时，和事件相关的资源都可用且不会在操作中阻塞。当所有的事件都被处理完后，继续进入循环等待下一个可以被处理的事件。这个被称作为<code>事件循环(event loop)</code>。</li></ol><p><img src="/assets/img/node_demultiplexer.png" alt="多路复用"></p><p>上图帮助我们理解如何在一个单线程中使用多路复用器和非阻塞 I/O 来处理并发。我们能够看到，只使用一个线程并不会影响我们处理多个 I/O 任务的性能。同时，我们看到任务是在单个线程中随着时间的推移而展开的，而不是分散在多个线程中。我们看到，在单线程中传播的任务相对于多线程中传播的任务反而节约了线程的总体空闲时间，并且更利于程序员编写代码。</p><h3 id="Introducing-to-reactor-pattern-reactor-模式的介绍"><a href="#Introducing-to-reactor-pattern-reactor-模式的介绍" class="headerlink" title="Introducing to reactor pattern(reactor 模式的介绍)"></a>Introducing to reactor pattern(reactor 模式的介绍)</h3><p>主要思想就是每一个 I/O 操作都有一个<code>handler</code>或者成为回调函数(<code>callback</code>)，当事件发生并且被<code>事件循环</code>处理后，这个回调函数就会被调用：</p><p><img src="/assets/img/event_loop.png" alt="event loop"></p><p>一个应用使用<code>reactor</code>模式后：</p><ol><li>应用提交一个请求给事件多路复用器 ，生成 I/O 操作，同时提供事件触发时的<code>handler</code>， 发送请求给事件多路复用器是一个非阻塞的操作，发送后立即返回到应用。</li><li>当一组 I/O 操作完成，事件多路复用器会将新来的事件添加到事件队列中。</li><li>此时，事件循环会迭代事件队列中的每个事件。</li><li>对于每个事件，对应的<code>handler</code>被处理。</li><li><code>handler</code>，是应用程序代码的一部分，<code>handler</code>执行结束后执行权会交回事件循环。但是，在<code>handler</code>执行时可能请求新的异步操作，从而新的操作被添加到事件多路复用器。</li><li>当事件队列的全部事件被处理完后，事件多路复用器再次阻塞直到有一个新的事件触发。</li></ol><p>现在来定义 Node.js 的核心模式：<br><code>模式(reactor)</code>这样处理 I/O，阻塞直到有新的事件从被观察的资源中触发，然后将事件派发给相应的<code>handler</code>。</p><h3 id="Node-js-非阻塞-I-O-引擎——libuv"><a href="#Node-js-非阻塞-I-O-引擎——libuv" class="headerlink" title="Node.js 非阻塞 I/O 引擎——libuv"></a>Node.js 非阻塞 I/O 引擎——libuv</h3><p>每个操作系统都有不同的接口来实现事件多路复用器，Linux 是 epoll，Mac OSX 是 kqueue，Windows 的 IOCP API，即使是在相同的操作系统中对于不同资源的 I/O 操作也不同，所以 Node.js 使用<code>libuv</code>来统一处理 I/O 操作，来达到兼容不同操作系统的目的。</p><h3 id="Node-js-架构"><a href="#Node-js-架构" class="headerlink" title="Node.js 架构"></a>Node.js 架构</h3><p><img src="/assets/img/node_architecture.png" alt="Node.js 架构"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Welcome-to-the-Node-js-Platform&quot;&gt;&lt;a href=&quot;#Welcome-to-the-Node-js-Platform&quot; class=&quot;headerlink&quot; title=&quot;Welcome to the Node.js Platform&quot;&gt;&lt;/a&gt;Welcome to the Node.js Platform&lt;/h1&gt;&lt;h2 id=&quot;Small-modules-小模块&quot;&gt;&lt;a href=&quot;#Small-modules-小模块&quot; class=&quot;headerlink&quot; title=&quot;Small modules(小模块)&quot;&gt;&lt;/a&gt;Small modules(小模块)&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt;使用&lt;code&gt;module&lt;/code&gt;(模块)的概念组织代码的结构。&lt;br&gt;&lt;code&gt;package&lt;/code&gt;可提供复用的模块，有一个 module 作为入口。&lt;br&gt;&lt;code&gt;Node.js&lt;/code&gt;中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python 处理excel文件</title>
    <link href="http://1016990109.github.io/2018/05/09/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/"/>
    <id>http://1016990109.github.io/2018/05/09/Python-处理excel文件/</id>
    <published>2018-05-09T14:42:58.000Z</published>
    <updated>2018-05-10T09:01:45.774Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要用到Python去处理excel，目标是根据用户输入的信息，先显示每列的列名以及这一列示例行（取前两行信息），然后根据输入的列号删除对应的列。</p><p>网上搜索了下主要有几种方案：</p><h3 id="1-使用xlrd、xlwt、xlutils组合"><a href="#1-使用xlrd、xlwt、xlutils组合" class="headerlink" title="1. 使用xlrd、xlwt、xlutils组合"></a>1. 使用xlrd、xlwt、xlutils组合</h3><p>这种方案比较常见，而且读取和写入速度较快，但是只能操作2003版本之前的xls文件，处理不了xlsx，所以想要处理2003版本之后的请绕道。</p><blockquote><p>注意！<br>xlutils复制的excel格式上会存在一些问题，我在使用的时候就因为这个原因而弃用了，灰底的表格会变成深蓝色底的，难以接受。 </p></blockquote><a id="more"></a><p>xlrd用来读取excel内容，xlwt写入excel内容，xlutils封装了一些常用的操作excel的函数供用户使用，一些使用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">'myexcel.xls'</span>)</span><br><span class="line"><span class="comment">#获取表单</span></span><br><span class="line">worksheet = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line">data = worksheet.cell_value(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">##另一种获取数据，但这种是包含数据类型的，需要内容可通过value获取</span></span><br><span class="line">data2 = worksheet.cell(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">#----xlwt库</span></span><br><span class="line"><span class="comment">#新建excel</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"><span class="comment">#添加工作薄</span></span><br><span class="line">sh = wb.add_sheet(<span class="string">'Sheet1'</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">sh.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">'data'</span>)</span><br><span class="line"><span class="comment">#保存文件</span></span><br><span class="line">wb.save(<span class="string">'myexcel.xls'</span>)</span><br><span class="line"><span class="comment">#----xlutils库</span></span><br><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">book = xlrd.open_workbook(<span class="string">'myexcel.xls'</span>)</span><br><span class="line"><span class="comment">#复制一份</span></span><br><span class="line">new_book = xlutils.copy(book)</span><br><span class="line"><span class="comment">#拿到工作薄</span></span><br><span class="line">worksheet = new_book.getsheet(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">worksheet.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">'new data'</span>)</span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">new_book.save()</span><br></pre></td></tr></table></figure><h3 id="2-使用openpyxl"><a href="#2-使用openpyxl" class="headerlink" title="2. 使用openpyxl"></a>2. 使用openpyxl</h3><p>与xlrd、xlwt、xlutils组合不同，openpyxl只支持excel 2003之后的也就是xlsx文件，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">workbook = openpyxl.Workbook() </span><br><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">sheet = workbook.activesheet[<span class="string">'A1'</span>]=<span class="string">'data'</span></span><br><span class="line"><span class="comment"># 保存文件 </span></span><br><span class="line">workbook.save(<span class="string">'test.xlsx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="comment">#打开文件</span></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'test.xlsx'</span>)</span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line">ws = wb.active</span><br><span class="line">cols = ws.columns</span><br><span class="line">cols[<span class="number">0</span>][<span class="number">1</span>].value = <span class="string">'data'</span></span><br></pre></td></tr></table></figure><h3 id="3-使用win32com操作系统的Excel程序"><a href="#3-使用win32com操作系统的Excel程序" class="headerlink" title="3. 使用win32com操作系统的Excel程序"></a>3. 使用win32com操作系统的Excel程序</h3><p>这种方式约束较多，要求Windows + Microsoft Excel，是使用win32com库来操作Excel程序来完成对excel文件的操作，官方的API特别的复杂，要找到自己需要的API还是要费一番功夫的，但是相应的能做的事也就多了，你能在Excel程序中做的事，几乎使用win32com都能做，具体可用的可查看官方的<a href="https://documentation.devexpress.com/OfficeFileAPI/12078/Spreadsheet-Document-API/Examples/Worksheets" target="_blank" rel="noopener">文档</a>，几乎和vb程序差不多，不用看c++的。<br>举一些我在项目中用到的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开应用</span></span><br><span class="line">xlApp = win32com.client.Dispatch(<span class="string">'Excel.Application'</span>)</span><br><span class="line"><span class="comment">#打开表格</span></span><br><span class="line">xlBook = xlApp.Workbook.Open(<span class="string">'test.xls'</span>)</span><br><span class="line"><span class="comment">#保存文件</span></span><br><span class="line">xlBook.Save()</span><br><span class="line"><span class="comment">#另存为</span></span><br><span class="line">xlBook.SaveAs(<span class="string">'new.xls'</span>)</span><br><span class="line"><span class="comment">#关闭文件</span></span><br><span class="line">xlBook.Close(SaveChanges=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#获得sheet，传入sheet名字</span></span><br><span class="line">sht = xlBook.Worksheets(<span class="string">'Sheet1'</span>)</span><br><span class="line"><span class="comment">#获得sheet2，传入index</span></span><br><span class="line">sht = xlBook.worksheets[index]</span><br><span class="line"><span class="comment">#获得单元格内容</span></span><br><span class="line">data =  sht.Cells(row, col).Value</span><br><span class="line"><span class="comment">#设置单元格内容</span></span><br><span class="line">sht.Cells(row, col).Value = <span class="string">'New Value'</span></span><br><span class="line"><span class="comment">#获得一块</span></span><br><span class="line">myRange = sht.Range(sht.Cells(row1, col1), sht.Cells(row2, col2)).Value</span><br><span class="line"><span class="comment">#选择sheet</span></span><br><span class="line">sht.Activate</span><br><span class="line"><span class="comment">#获得一列</span></span><br><span class="line">sht.Columns(index)</span><br><span class="line"><span class="comment">#删除一列</span></span><br><span class="line">sht.Columns(<span class="number">1</span>).Delete()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是3种常用操作excel的python库，读者可根据自己的情况选择合适的库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要用到Python去处理excel，目标是根据用户输入的信息，先显示每列的列名以及这一列示例行（取前两行信息），然后根据输入的列号删除对应的列。&lt;/p&gt;
&lt;p&gt;网上搜索了下主要有几种方案：&lt;/p&gt;
&lt;h3 id=&quot;1-使用xlrd、xlwt、xlutils组合&quot;&gt;&lt;a href=&quot;#1-使用xlrd、xlwt、xlutils组合&quot; class=&quot;headerlink&quot; title=&quot;1. 使用xlrd、xlwt、xlutils组合&quot;&gt;&lt;/a&gt;1. 使用xlrd、xlwt、xlutils组合&lt;/h3&gt;&lt;p&gt;这种方案比较常见，而且读取和写入速度较快，但是只能操作2003版本之前的xls文件，处理不了xlsx，所以想要处理2003版本之后的请绕道。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意！&lt;br&gt;xlutils复制的excel格式上会存在一些问题，我在使用的时候就因为这个原因而弃用了，灰底的表格会变成深蓝色底的，难以接受。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://1016990109.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Vue 过渡&amp;动画</title>
    <link href="http://1016990109.github.io/2018/05/06/Vue-%E8%BF%87%E6%B8%A1-%E5%8A%A8%E7%94%BB/"/>
    <id>http://1016990109.github.io/2018/05/06/Vue-过渡-动画/</id>
    <published>2018-05-06T12:56:26.000Z</published>
    <updated>2018-05-15T12:37:51.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>使用 transition 封装组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="过渡类名"><a href="#过渡类名" class="headerlink" title="过渡类名"></a>过渡类名</h3><p>使用 transition 之后当触发过渡动画时，会添加相应的 class，没有 name 属性时使用 v-，否则使用定义的{$name}-，共有 6 个 class 切换：</p><ol><li>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li><li>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li><li>v-enter-to: 2.1.8 版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</li><li>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li><li>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li>v-leave-to: 2.1.8 版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li></ol><p>具体过程如下：</p><p><img src="/assets/img/vue_transition.png" alt="vue_transition"></p><h3 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h3><p>可以在属性中声明钩子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-enter</span>=<span class="string">"afterEnter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter-cancelled</span>=<span class="string">"enterCancelled"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-leave</span>=<span class="string">"beforeLeave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-leave</span>=<span class="string">"afterLeave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave-cancelled</span>=<span class="string">"leaveCancelled"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成。</p></blockquote><blockquote><p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p></blockquote><h2 id="多个元素的过渡"><a href="#多个元素的过渡" class="headerlink" title="多个元素的过渡"></a>多个元素的过渡</h2><h3 id="过渡-模式"><a href="#过渡-模式" class="headerlink" title="过渡  模式"></a>过渡  模式</h3><ul><li>in-out：新元素先进行过渡，完成之后当前元素过渡离开。</li><li>out-in：当前元素先进行过渡，完成之后新元素过渡进入。</li></ul><h2 id="平滑过渡-列表过渡"><a href="#平滑过渡-列表过渡" class="headerlink" title="平滑过渡(列表过渡)"></a>平滑过渡(列表过渡)</h2><p>使用 <code>&lt;transition-group&gt;</code>组件，可以使列表过渡起来比较平滑，只需要使用<code>v-move</code>即可，具体例子如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"flip-list"</span> <span class="attr">tag</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flip-list-move</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>读者有兴趣可以研究一下洗牌算法，可以保证每个数出现的唯一性，shuffle 算法。</p></blockquote><p>这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。</p><p>需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中。</p><hr><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单元素-组件的过渡&quot;&gt;&lt;a href=&quot;#单元素-组件的过渡&quot; class=&quot;headerlink&quot; title=&quot;单元素/组件的过渡&quot;&gt;&lt;/a&gt;单元素/组件的过渡&lt;/h2&gt;&lt;p&gt;使用 transition 封装组件：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;transition&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;fade&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;v-if&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;show&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;hello&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;transition&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>VSCode配置</title>
    <link href="http://1016990109.github.io/2018/05/05/VSCode%E9%85%8D%E7%BD%AE/"/>
    <id>http://1016990109.github.io/2018/05/05/VSCode配置/</id>
    <published>2018-05-05T11:30:34.000Z</published>
    <updated>2018-05-06T12:50:42.796Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用IDE从WebStorm更换到VSCode，故在此记录下VSCode的一些配置，供以后查看。</p><h2 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h2><p>VSCode更倾向于定制化，所以需要自行寻找需要的插件，来提高打码的效率~</p><p>我这里使用了一些暂时需要用到的插件：</p><a id="more"></a><h3 id="1-Beautify"><a href="#1-Beautify" class="headerlink" title="1. Beautify"></a>1. Beautify</h3><p>一个很常用的代码格式化工具，一键格式化，非常方便。</p><h3 id="2-Git-History"><a href="#2-Git-History" class="headerlink" title="2. Git History"></a>2. Git History</h3><p>查看log，文件历史记录等等，在自带git功能上多加了许多功能。</p><h3 id="3-Vetur"><a href="#3-Vetur" class="headerlink" title="3. Vetur"></a>3. Vetur</h3><p>Vue的火热使得前端很多时候都使用它来开发，该插件高亮vue代码以及vue的代码格式化。</p><h3 id="4-Auto-Rename-Tag"><a href="#4-Auto-Rename-Tag" class="headerlink" title="4. Auto Rename Tag"></a>4. Auto Rename Tag</h3><p>自动重命名tag名称，类似于webstorm中的功能。</p><h3 id="5-Auto-Close-Tag"><a href="#5-Auto-Close-Tag" class="headerlink" title="5. Auto Close Tag"></a>5. Auto Close Tag</h3><p>自动关闭tag，类似webstorm。</p><h3 id="6-CSS-Peek"><a href="#6-CSS-Peek" class="headerlink" title="6. CSS Peek"></a>6. CSS Peek</h3><p>自动识别css文件中的类名，在模板中插入class时自动提示。</p><h2 id="配置篇"><a href="#配置篇" class="headerlink" title="配置篇"></a>配置篇</h2><p>记录自己用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"git.enableSmartCommit"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"git.autofetch"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"terminal.integrated.shell.osx"</span>: <span class="string">"zsh"</span>,</span><br><span class="line">    <span class="string">"window.zoomLevel"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"beautify.language"</span>: &#123;</span><br><span class="line">        <span class="string">"js"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: [</span><br><span class="line">                <span class="string">"javascript"</span>,</span><br><span class="line">                <span class="string">"json"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"filename"</span>: [</span><br><span class="line">                <span class="string">".jshintrc"</span>,</span><br><span class="line">                <span class="string">".jsbeautifyrc"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"css"</span>: [</span><br><span class="line">            <span class="string">"css"</span>,</span><br><span class="line">            <span class="string">"scss"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"html"</span>: [</span><br><span class="line">            <span class="string">"htm"</span>,</span><br><span class="line">            <span class="string">"html"</span>,</span><br><span class="line">            <span class="string">"vue"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"html.format.endWithNewline"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"prettier.singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"prettier.semi"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"vetur.format.defaultFormatter.html"</span>: <span class="string">"js-beautify-html"</span>,</span><br><span class="line">    <span class="string">"vetur.format.defaultFormatterOptions"</span>: &#123;</span><br><span class="line">      <span class="string">"wrap_attributes"</span>: <span class="string">"force-aligned"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用IDE从WebStorm更换到VSCode，故在此记录下VSCode的一些配置，供以后查看。&lt;/p&gt;
&lt;h2 id=&quot;插件篇&quot;&gt;&lt;a href=&quot;#插件篇&quot; class=&quot;headerlink&quot; title=&quot;插件篇&quot;&gt;&lt;/a&gt;插件篇&lt;/h2&gt;&lt;p&gt;VSCode更倾向于定制化，所以需要自行寻找需要的插件，来提高打码的效率~&lt;/p&gt;
&lt;p&gt;我这里使用了一些暂时需要用到的插件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue 基础的一些注意事项</title>
    <link href="http://1016990109.github.io/2018/04/17/Vue%E5%9F%BA%E7%A1%80%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://1016990109.github.io/2018/04/17/Vue基础的一些注意事项/</id>
    <published>2018-04-17T07:47:16.000Z</published>
    <updated>2018-05-06T12:49:35.543Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备学习一波 Vue，因为有 React 的基础，所以学起来倒也不是很吃力。下面是一些在学习中遇到的可能需要注意的地方。</p><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><blockquote><ol><li>绝对不要使用用户的输入作为插值，可能造成 XSS 攻击。</li><li>每个绑定只能包含单个表达式，下面表达式都不会生效。</li></ol></blockquote><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault():</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>默认只有 getter，但是也可以有 setter</p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>何时使用侦听器（watch）:当需要在数据变化时执行异步或开销较大的操作。</p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>Vue 默认情况下是会复用元素的，例如切换用户名或邮箱登录，如果两者都有 input 元素，那么在切换的时候 input 不会被替换掉，只会更改 placeholder 之类的属性。</p><p>如果添加了唯一的 key 值，Vue 将不会再复用元素， 使用 key 来判断是否元素变更。</p><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>注意，v-show 不支持 &lt;template> 元素，也不支持 v-else，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-show</span>=<span class="string">"!show"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- will show 'template-show' --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>template-show<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"!show"</span>&gt;</span></span><br><span class="line">    if</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- can't use v-else after v-show --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-for-与-v-if"><a href="#v-for-与-v-if" class="headerlink" title="v-for 与 v-if"></a>v-for 与 v-if</h3><p>v-for 的优先级更高，所以可以对每一项进行 if 判断是否显示。</p><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><p>直接改变数组内容的称为变异方法，如 push、pop、shift、unshift、splice、sort 等，可以响应更新；而直接生成新数组的方法如 slice、concat、filter 等则需要对 data 进行赋值，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="不能检测更新"><a href="#不能检测更新" class="headerlink" title="不能检测更新"></a>不能检测更新</h3><p>利用索引更改，arr[index] = newValue，或者改变数组长度，arr.length = newLength，可以用下面两种方式实现更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br><span class="line"><span class="comment">//change length</span></span><br><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>@keyup.ctrl 控制时，仅仅按下 ctrl 并弹起是无用的，其他键必须同时按下才有效。</p><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>v-model 绑定时，如果是基于输入法（中文、日文等）不会实时更新，只是输入结束后才会更新。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="DOM-模板-解析注意事项"><a href="#DOM-模板-解析注意事项" class="headerlink" title="DOM 模板  解析注意事项"></a>DOM 模板  解析注意事项</h3><blockquote><p>当使用 DOM 作为模板时 (例如，使用 el 选项来把 Vue 实例挂载到一个已有内容的元素上)，你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。尤其要注意，像 &lt;ul>、&lt;ol>、&lt;table>、&lt;select> 这样的元素里允许包含的元素有限制，而另一些像 &lt;option> 这样的元素只能出现在某些特定元素的内部。在自定义组件中使用这些受限制的元素时会导致一些问题，例如：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-row</span>&gt;</span>...<span class="tag">&lt;/<span class="name">my-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自定义组件 <my-row> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性：</my-row></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在.vue 文件或者使用字符串模板（template: ‘&lt;div>123&lt;/div>‘）则不会有这个问题。</p><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><p>class 和 style 会合并属性，父组件值和组件内的值进行合并</p><h3 id="给组件绑定原生事件"><a href="#给组件绑定原生事件" class="headerlink" title="给组件绑定原生事件"></a>给组件绑定原生事件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:click.native</span>=<span class="string">"doTheThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h3><p>2.0 移除但是 2.3 版本又加了回来，但是变成了编译的语法糖，会自动添加 v-on 绑定，如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo.sync</span>=<span class="string">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会被扩展为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo</span>=<span class="string">"bar"</span> @<span class="attr">update:foo</span>=<span class="string">"val =&gt; bar = val"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:foo'</span>, newValue)</span><br></pre></td></tr></table></figure><h3 id="非父子组件之间的通信"><a href="#非父子组件之间的通信" class="headerlink" title="非父子组件之间的通信"></a>非父子组件之间的通信</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发组件 A 中的事件</span></span><br><span class="line">bus.$emit(<span class="string">'id-selected'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></span><br><span class="line">bus.$on(<span class="string">'id-selected'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用插槽分发内容"><a href="#使用插槽分发内容" class="headerlink" title="使用插槽分发内容"></a>使用插槽分发内容</h3><blockquote><p>除非子组件模板包含至少一个 <strong>&lt;slot></strong> 插口，否则父组件的内容将会被<strong>丢弃</strong>。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件的标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">    只有在没有要分发的内容时才会显示。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote><p><strong>&lt;slot></strong> 元素可以用一个特殊的特性 name 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。</p></blockquote><blockquote><p>在 2.5.0+，<strong>slot-scope</strong> 能被用在任意元素或组件中而不再局限于 <strong>&lt;template></strong>。</p></blockquote><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>slot-scope 支持解构，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">"&#123; text &#125;"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 { text } 将子组件传递来的值进行解构，比如子组件有值 obj: {text: ‘test message’}。</p><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><blockquote><p>通过使用保留的 <component> 元素，并对其 is 特性进行动态绑定，你可以在同一个挂载点动态切换多个组件：</component></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: <span class="string">'home'</span> <span class="comment">//也可以是对象组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home: &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    posts: &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    archive: &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>动态组件需要缓存的时候可以使用 keep-alive，失活的组件会被缓存，避免重复渲染：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件间的循环引用"><a href="#组件间的循环引用" class="headerlink" title="组件间的循环引用"></a>组件间的循环引用</h3><p>常见的情况是文件系统，文件夹(folder)包含的内容(content)可能包含文件夹(folder)，这样就形成了循环引用，当使用 Vue.component 将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。然而，如果你使用诸如 webpack 或者 Browserify 之类的模块化管理工具来 require/import 组件的话，就会报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to mount component: template or render function not defined.</span><br></pre></td></tr></table></figure><p>我们可以选择在文件夹(folder)组件中声明在 beforeCreate 时才注册组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>使用 v-once 指令使得模板只会渲染一遍而不会监听数据改变。</p><h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h2><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><blockquote><p>provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 <google-map> 内部的 getMap 方法：</google-map></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getMap: <span class="keyword">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在任何后代都能使用getMap方法，只要在后代组件里声明注入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inject: [<span class="string">'getMap'</span>]</span><br></pre></td></tr></table></figure><h3 id="内联模板"><a href="#内联模板" class="headerlink" title="内联模板"></a>内联模板</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button-message</span> <span class="attr">v-on:message</span>=<span class="string">"handleMessage"</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>slot<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button-message</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后渲染的会是slot，而不是button-message定义的模板内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备学习一波 Vue，因为有 React 的基础，所以学起来倒也不是很吃力。下面是一些在学习中遇到的可能需要注意的地方。&lt;/p&gt;
&lt;h2 id=&quot;模板语法&quot;&gt;&lt;a href=&quot;#模板语法&quot; class=&quot;headerlink&quot; title=&quot;模板语法&quot;&gt;&lt;/a&gt;模板语法&lt;/h2&gt;&lt;h3 id=&quot;插值&quot;&gt;&lt;a href=&quot;#插值&quot; class=&quot;headerlink&quot; title=&quot;插值&quot;&gt;&lt;/a&gt;插值&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;绝对不要使用用户的输入作为插值，可能造成 XSS 攻击。&lt;/li&gt;
&lt;li&gt;每个绑定只能包含单个表达式，下面表达式都不会生效。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>rbac分析（php源码）</title>
    <link href="http://1016990109.github.io/2016/05/23/rbac-php/"/>
    <id>http://1016990109.github.io/2016/05/23/rbac-php/</id>
    <published>2016-05-23T14:23:47.000Z</published>
    <updated>2018-04-17T08:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rbac简介"><a href="#rbac简介" class="headerlink" title="rbac简介"></a>rbac简介</h2><blockquote><p>基于角色的访问控制（Role-Based Access Control）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。</p></blockquote><a id="more"></a><p>用一张图来简单地描述一下</p><p><img src="/assets/img/rbac_intro.png" alt="rbac图解"></p><p>rbac有3个重要概念：<strong>用户</strong>、<strong>角色</strong>、<strong>权限</strong>。通俗地来说，就是把若干个<strong>权限</strong>分配给某个<strong>角色</strong>，然后在需要时把若干个<strong>角色</strong>分配给指定的<strong>用户</strong>，rbac就是通过这种方式实现访问控制的。</p><p>管理员通过分配给一个用户角色来允许该用户可以做某些事情。</p><p><strong>RBAC支持三个著名的安全原则</strong>：</p><ol><li>最小权限原则<br>将其角色配置成其完成任务所需要的最小的权限集</li><li>责任分离原则<br>可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一过帐</li><li>数据抽象<br>可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限</li></ol><h2 id="为什么使用rbac"><a href="#为什么使用rbac" class="headerlink" title="为什么使用rbac"></a>为什么使用rbac</h2><p>普通的ACL在权限越来越多的时候需要维护的权限太多，这造成了ACL的瓶颈。而rbac可以有效地解决这个问题。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>仍然有很多权限存在于系统（问题）</li><li>人员移动的时候只需要改变人员的角色</li><li>维护大量的权限仍然是个问题</li><li>维护分配给每个角色的权限比较容易</li><li>角色的权限分配需要双重检查确保不会分配错误的权限给任何角色</li></ul><h2 id="一款开源的rbac库——PHP-RBAC"><a href="#一款开源的rbac库——PHP-RBAC" class="headerlink" title="一款开源的rbac库——PHP-RBAC"></a>一款开源的rbac库——PHP-RBAC</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="http://phprbac.net/" title="PHP-RBAC" target="_blank" rel="noopener">PHP-RBAC</a>是php的一个简单库，实现了rbac一些基本的功能（不包括用户组），它为开发者提供了NIST Level 2 Standard Role Based Access Control。</p><p>下面是PHP-RBAC的一个demo：它实现了角色的分层管理，更贴近实际。<br><img src="http://phprbac.net/img/rbac.png" alt="rbac-demo"></p><p>我自己简单地试了下库，代码是这样：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// turn on all errors</span></span><br><span class="line">error_reporting(E_ALL);</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpRbac</span>\<span class="title">Rbac</span>;</span><br><span class="line"><span class="comment">// autoloader</span></span><br><span class="line"><span class="keyword">require</span> dirname(<span class="keyword">__DIR__</span>) . <span class="string">'/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line">$test = <span class="keyword">new</span> Test();</span><br><span class="line">$test-&gt;myTest();</span><br><span class="line"><span class="comment">// myTest();</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">$rbac = <span class="keyword">new</span> Rbac(<span class="string">'unit_test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">myTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">$rbac = <span class="keyword">new</span> Rbac();</span><br><span class="line">$rbac-&gt;reset(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Permission</span></span><br><span class="line">$perm_id = $rbac-&gt;Permissions-&gt;add(<span class="string">'delete_posts'</span>, <span class="string">'Can delete forum posts'</span>);</span><br><span class="line">$perm_id2 = $rbac-&gt;Permissions-&gt;add(<span class="string">'add_posts'</span>, <span class="string">'Can add forum posts'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Role</span></span><br><span class="line">$role_id = $rbac-&gt;Roles-&gt;add(<span class="string">'forum_moderator'</span>, <span class="string">'User can moderate forums'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following are equivalent statements</span></span><br><span class="line">$rbac-&gt;assign($role_id, $perm_id);</span><br><span class="line">$rbac-&gt;assign($role_id, $perm_id2);</span><br><span class="line"></span><br><span class="line">$rbac-&gt;Users-&gt;assign($role_id, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">$res = $rbac-&gt;Roles-&gt;permissions(<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($res <span class="keyword">as</span> $perm) &#123;</span><br><span class="line"><span class="keyword">print</span>($rbac-&gt;Permissions-&gt;getDescription($perm).<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">print</span>($rbac-&gt;Permissions-&gt;depth($perm).<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">print</span>($rbac-&gt;Permissions-&gt;getPath($perm).<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="/assets/img/phprbac_result.png" alt="运行结果"><br>使用非常容易吧，这是一个轻量的库，只有几百k的大小，所以对于一些对权限管理要求不是特别复杂的（没有用户组、分类等）系统可以考虑使用哦！</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>PHP-RBAC的表设计同许多rbac的软件类似：<br><img src="/assets/img/rbac_table.png" alt="rbac表"><br><img src="/assets/img/phprbac_table.png" alt="php-rbac表"></p><p>PHP-RBAC分层实现：<br>使用树形结构实现（嵌套集合）：<br><img src="/assets/img/phprbac_tree.png" alt="树形结构数据库实现"><br><img src="/assets/img/phprbac_tree_em.png" alt="php-rbac例子"></p><p>End.<br><em>关于rbac的扩展以后有时间再给大家讲讲。</em></p><p>参考资料：</p><ol><li><a href="http://baike.baidu.com/link?url=5FPK3srV0UpUKEJProX7MIJDmX4FFlEp8tQI5VQ8-pnI1xMUv8BY9E4TDeM89astDTGW9Mr0uBWOXpwk_2egr" target="_blank" rel="noopener">http://baike.baidu.com/link?url=5FPK3srV0UpUKEJProX7MIJDmX4FFlEp8tQI5VQ8-pnI1xMUv8BY9E4TDeM89astDTGW9Mr0uBWOXpwk_2egr</a>_</li><li><a href="http://phprbac.net/" target="_blank" rel="noopener">http://phprbac.net/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;rbac简介&quot;&gt;&lt;a href=&quot;#rbac简介&quot; class=&quot;headerlink&quot; title=&quot;rbac简介&quot;&gt;&lt;/a&gt;rbac简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;基于角色的访问控制（Role-Based Access Control）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="源码" scheme="http://1016990109.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="php" scheme="http://1016990109.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>开始我的instagrame</title>
    <link href="http://1016990109.github.io/2016/05/20/instagrame/"/>
    <id>http://1016990109.github.io/2016/05/20/instagrame/</id>
    <published>2016-05-20T07:09:39.000Z</published>
    <updated>2018-04-17T07:29:54.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一次偶然的机会，我认识了instagrame"><a href="#一次偶然的机会，我认识了instagrame" class="headerlink" title="一次偶然的机会，我认识了instagrame"></a>一次偶然的机会，我认识了instagrame</h2><p>一天，一个偶然，我逛了下<a href="http://litten.github.io/" title="litten的博客" target="_blank" rel="noopener">litten</a>的博客，发现了他把自己的照片分享在了博客上，于是我便很好奇博主是用了什么方法分享的。于是我查看了博主搭建博客的过程，了解到他是分享了在instagrame上的照片，这就是我第一次认识instagrame。</p><h2 id="开始了解instagrame"><a href="#开始了解instagrame" class="headerlink" title="开始了解instagrame"></a>开始了解instagrame</h2><p>秉着好学的心态，我也想在自己的博客上搭建一个这样分享照片的平台，就这样我开始了我的instagrame之旅。<br><a id="more"></a></p><h3 id="百度百科的介绍："><a href="#百度百科的介绍：" class="headerlink" title="百度百科的介绍："></a>百度百科的介绍：</h3><blockquote><p>Instagram是一款最初运行在iOS平台上的移动应用，以一种快速、美妙和有趣的方式将你随时抓拍下的图片分享彼此，安卓版Instagram于2012年4月3日起登陆Android应用商店Google Play。2012年4月10号，Facebook宣布以10亿美元收购Instagram。2012年10月25号，Facebook以总值7.15亿美元收购Instagram。2012年12月，Facebook旗下的图片共享服务Instagram因其使用图片共享服务的新条款而在互联网上引起轩然大波，Instagram对此进行了澄清，称不会在广告中使用或销售用户的照片，从而打消了用户的顾虑。北京时间2013年10月22日，诺基亚宣布instagram将会入驻Windows Phone市场，11月21日Instagram正式登录Windows Phone 8平台。</p></blockquote><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><blockquote><p>☆ 100%免费自定义设计的过滤器和边框，例如XPro-II、Earlybird、Rise、Amaro、Hudson、Lo-fi、Sutro、Toaster、 Brannan、Inkwell、Walden、Hefe、Nashville、1977等等[8]<br>☆ 实时分享到新浪微博、Facebook、Twitter、Flickr、Tumblr和Foursquare<br>☆ 平行和放射状移轴模糊特效可提供额外的景深效果[9]<br>☆ 上传不受限，即拍即传即分享<br>☆ 通过接收和发送赞和评论与朋友互动<br>☆ iPhone前置和后置摄像头的全面支持</p></blockquote><p>可能大家用的时候会感到很奇怪，<strong>怎么网页版的instagrame不支持上传照片么</strong>？可能是instagrame更注重生活中的抓拍吧，生活中还是使用移动设备多一点，所以它这个设计也是符合它的理念的（快速记录生活）。</p><p>instagrame分享图片的时候可以选择地理位置（最后还可以生成图片地图哦^_^），也可以选择分享的对象，非常的个性化，可以看下效果哦！<br><img src="/assets/img/instagrame.png" alt="图片地图" title="图片地图"></p><h2 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h2><p>instagrame还可以上传小视频，有点像现在的微信小视频之类的，不过只能最多15秒。<br>总之，我还是比较喜欢instagrame来收录生活中的场景的。</p><p>参考资料：</p><ol><li><a href="http://baike.baidu.com/link?url=QoodiA5Hzcnxlq268Lk3jkOPedAy3ICAVI-T6LKpay6A08o6UaTSU4tUrpqQuXJhFix9R3IAYzWN0KFY01iPRa" target="_blank" rel="noopener">http://baike.baidu.com/link?url=QoodiA5Hzcnxlq268Lk3jkOPedAy3ICAVI-T6LKpay6A08o6UaTSU4tUrpqQuXJhFix9R3IAYzWN0KFY01iPRa</a></li><li><a href="http://1016990109.github.io/2016/05/20/instagrame/">http://1016990109.github.io/2016/05/20/instagrame/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一次偶然的机会，我认识了instagrame&quot;&gt;&lt;a href=&quot;#一次偶然的机会，我认识了instagrame&quot; class=&quot;headerlink&quot; title=&quot;一次偶然的机会，我认识了instagrame&quot;&gt;&lt;/a&gt;一次偶然的机会，我认识了instagrame&lt;/h2&gt;&lt;p&gt;一天，一个偶然，我逛了下&lt;a href=&quot;http://litten.github.io/&quot; title=&quot;litten的博客&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;litten&lt;/a&gt;的博客，发现了他把自己的照片分享在了博客上，于是我便很好奇博主是用了什么方法分享的。于是我查看了博主搭建博客的过程，了解到他是分享了在instagrame上的照片，这就是我第一次认识instagrame。&lt;/p&gt;
&lt;h2 id=&quot;开始了解instagrame&quot;&gt;&lt;a href=&quot;#开始了解instagrame&quot; class=&quot;headerlink&quot; title=&quot;开始了解instagrame&quot;&gt;&lt;/a&gt;开始了解instagrame&lt;/h2&gt;&lt;p&gt;秉着好学的心态，我也想在自己的博客上搭建一个这样分享照片的平台，就这样我开始了我的instagrame之旅。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://1016990109.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://1016990109.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
