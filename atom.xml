<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七秒悲伤的博客</title>
  
  <subtitle>一个深藏功与名的软件开发爱好者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1016990109.github.io/"/>
  <updated>2019-04-14T14:11:43.366Z</updated>
  <id>http://1016990109.github.io/</id>
  
  <author>
    <name>七秒悲伤</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Cloud 项目搭建(基于 Greenwich.M3 版本)</title>
    <link href="http://1016990109.github.io/2019/01/29/Spring-Cloud-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>http://1016990109.github.io/2019/01/29/Spring-Cloud-项目搭建/</id>
    <published>2019-01-29T09:44:41.000Z</published>
    <updated>2019-04-14T14:11:43.366Z</updated>
    
    <content type="html"><![CDATA[<p><code>Spring Cloud</code> 是一个基于 <code>Spring Boot</code> 实现的云应用开发工具，它为基于 <code>JVM</code> 的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p><p><code>Spring Cloud</code> 包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：<code>Spring Cloud Config</code>、<code>Spring Cloud Netflix</code>、<code>Spring Cloud Data</code>、<code>Spring Cloud AWS</code>、<code>Spring Cloud Security</code>、<code>Spring Cloud Commons</code>、<code>Spring Cloud Gateway</code>、<code>Spring Cloud CLI</code> 等项目。</p><p>下面分别从以下几块来开始搭建我们的 <code>Spring Cloud</code> 应用（基于 <code>Greenwich.M3</code> 版本，建议读者使用稳定版本，这里只是尝试新特性，文末有项目地址）：</p><ul><li>公共父项目（<code>spring-cloud-example</code>）</li><li>注册中心（<code>eureka</code>）</li><li>配置中心（<code>config-server</code>）</li><li>网关（<code>gateway</code>）</li><li>服务提供者（<code>feign-server</code>）</li><li>服务消费者（<code>feign-client</code>）</li></ul><a id="more"></a><h2 id="公共父项目"><a href="#公共父项目" class="headerlink" title="公共父项目"></a>公共父项目</h2><p>开发 <code>Java</code> 项目一般使用 <code>Intellij Idea</code> 开发，创建项目的时候勾选 <code>Spring Initializr</code>，使用默认的服务 <code>https://start.spring.io</code> 即可。接下来一步步按照提示操作，选择 <code>Spring Boot</code> 版本为 <code>2.1.1.RELEASE</code>，接着选择需要的依赖，勾选 <code>Ops</code> 的 <code>Actuator</code>（可检测服务的健康状态等等，具体功能可查看 <a href="https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/multi/multi__actuator_api.html" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/multi/multi__actuator_api.html</a>）。生成的 <code>pom.xml</code> 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.edu.nju<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>$&#123;artifactId&#125;<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>spring cloud parent<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!-- !!!important!!! 2.1.0.RELEASE 版本 spring-cloud-bus 的 spring-cloud-config-monitor 不会发送消息到bus上--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.M3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-pmd-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/assets/img/idea_spring_io.png" alt="Idea Spring IO"><br><img src="/assets/img/idea_spring_io_metadata.png" alt="Idea Spring IO"><br><img src="/assets/img/idea_spring_io_dependencies.png" alt="Idea Spring IO"></p><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>微服务框架的核心就是注册中心，有了注册中心后各个服务可以将多个实例都注册到注册中心，需要调用时可根据需要选择对应的服务实例，比如实现负载均衡等。</p><p>1.右键项目新建新的 <code>module</code>，同样选择 <code>Spring initializr</code>，选择需要的依赖，注册中心我们勾选 <code>Cloud Discovery</code> 中的 <code>EurekaServer</code>（当然也可以选择其他注册中心，如 <code>Zookeeper</code>、<code>Consul</code> 等）和 <code>Cloud Core</code> 中的 <code>Cloud Security</code>（需要验证才能注册到注册中心，否则泄漏注册中心地址后会有危险服务注册从而被攻击），当然也可以手动新建模块，具体读者可参考 <code>maven</code> 的文档 <a href="https://maven.apache.org/guides/mini/guide-multiple-modules.html" target="_blank" rel="noopener">https://maven.apache.org/guides/mini/guide-multiple-modules.html</a>。生成的 <code>pom.xml</code> 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.edu.nju<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Cloud Eureka<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在启动类上加上注解，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.配置 <code>Security</code>，新建类 <code>WebSecurityConfig</code> 继承 <code>WebSecurityConfigurerAdapter</code>，设置 <code>csrf</code> 关闭，否则服务不能正常注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(http);</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.配置文件 <code>application.yml</code>。</p><ul><li><code>eureka.instance.prefer-ip-address</code> 设置为 <code>true</code> 使服务都是以 <code>ip</code> 地址形式提供的；</li><li><code>eureka.client.register-with-eureka</code> 表示是否将自己注册到服务中心，默认为 <code>true</code>，因为这里就是注册中心，所以设置为 <code>false</code>；</li><li><code>eureka.client.fetch-registry</code> 表示是否从其他注册中心同步信息，这里我们是单点的注册中心，所以不需要同步，设置为 <code>false</code>；</li><li><p><code>eureka.client.service-url.defaultZone</code> 设置与 <code>Eureka Server</code> 交互的地址，查询服务和注册服务都需要依赖这个地址；在开发过程中，我们常常希望 <code>Eureka Server</code> 能够迅速有效地踢出已关停的节点，但是由于 <code>Eureka</code> 自我保护模式，以及心跳周期长的原因，常常会遇到<code>Eureka Server</code>不踢出已关停的节点的问题，解决方法如下:<br><code>Eureka Server</code> 端：配置关闭自我保护，并按需配置 <code>Eureka Server</code> 清理无效节点的时间间隔。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.server.enable-self-preservation</span><span class="comment"># 设为false，关闭自我保护</span></span><br><span class="line"><span class="string">eureka.server.eviction-interval-timer-in-ms</span>     <span class="comment"># 清理间隔（单位毫秒，默认是60*1000）</span></span><br></pre></td></tr></table></figure><p><code>Eureka Client</code> 端：配置开启健康检查，并按需配置续约更新时间和到期时间。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.client.healthcheck.enabled</span><span class="comment"># 开启健康检查（需要spring-boot-starter-actuator依赖）</span></span><br><span class="line"><span class="string">eureka.instance.lease-renewal-interval-in-seconds</span><span class="comment"># 续约更新时间间隔（默认30秒）</span></span><br><span class="line"><span class="string">eureka.instance.lease-expiration-duration-in-seconds</span> <span class="comment"># 续约到期时间（默认90秒）</span></span><br></pre></td></tr></table></figure></li><li><p><code>spring.security.user</code> 配置鉴权有关信息，这里使用简单的用户名密码的形式鉴权，更复杂的安全机制可查看 <code>Spring Security</code> 的文档。配置用户名为 <code>user</code>，密码为 <code>123456</code>，则客户端的注册地址需要写成 <code>http://user:123456@localhost:8761/eureka/</code>。</p></li></ul><p>示例：<br>服务端配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    appname:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    eviction-interval-timer-in-ms:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    user:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">      password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line"><span class="attr">  app:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Eureka</span> <span class="string">Server</span></span><br></pre></td></tr></table></figure><p>客户端配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">feign-server</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      retry:</span></span><br><span class="line"><span class="attr">        initial-interval:</span> <span class="number">2000</span></span><br><span class="line"><span class="attr">        max-attempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">config-server</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">config</span></span><br><span class="line"><span class="attr">      password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    healthcheck:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://user:123456@localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    lease-expiration-duration-in-seconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">    lease-renewal-interval-in-seconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：更改 Eureka 更新频率将打破服务器的自我保护功能，生产环境下不建议自定义这些配置。详见：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/373" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix/issues/373</a></p></blockquote><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>配置管理在分布式项目中有着非常重要的作用，在 <code>Spring Cloud</code> 应用的开发过程中，我们通常使用配置文件 <code>application.yml</code> 或 <code>bootstrap.yml</code> 来管理项目配置，对于单体应用来说，一次配置的修改并不会耗费多少的时间，但是对于许多个微服务都需要更新某项配置时，就需要更改每个服务的配置并重启服务完成更新。而有了配置中心统一管理项目配置后，则无需变动服务本身，只需更改配置中心对应配置即可，提高系统的可扩展性。<code>Spring Cloud Config</code> 提供了这样一种配置中心服务，并且能够通过消息总线实时更新已启动的服务的配置（除在项目启动时就已经读取并不能再更新的配置，如 <code>port</code>）。</p><p><code>Spring Cloud Config</code> 可以使用 <code>Git</code> 仓库作为配置仓库，也可以使用本地的文件系统作为仓库（本质上是在本地创建了 <code>Git</code> 仓库并管理），提供服务端和客户端的支持。</p><p>1.右键项目新建新的 <code>module</code>，同样选择 <code>Spring initializr</code>，选择需要的依赖，配置服务端勾选 <code>Cloud Config</code> 中的 <code>Config Server</code>，配置客户端勾选 <code>Cloud Config</code> 中的 <code>Config Client</code>。</p><p>2.配置中心服务端配置。生成的依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动类添加 <code>@EnableConfigServer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server.port=8888</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring</span></span><br><span class="line">  <span class="string">application</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config-server</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/spring-cloud-samples/config-repo</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">your</span> <span class="string">git</span> <span class="string">username</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">your</span> <span class="string">git</span> <span class="string">password</span></span><br><span class="line"><span class="attr">          repos:</span> <span class="comment">#配置从 git 仓库获取的路径，这里为 https://github.com/spring-cloud-samples/config-repo/multi-repo-demo-*，*为通配符</span></span><br><span class="line"><span class="attr">            - patterns:</span> <span class="string">multi-repo-demo-*</span></span><br></pre></td></tr></table></figure><p>3.配置中心客户端配置。生成的依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置文件（注意这里一定要为 <code>bootstrap.yml</code> 而不能是 <code>application.yml</code>，因为需要从引导上下文中读取配置中心的配置数据，作为应用上下文的配置，两者有先后关系）:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config-client</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      retry:</span></span><br><span class="line"><span class="attr">        initial-interval:</span> <span class="number">2000</span> <span class="comment">#初始重试间隔时间</span></span><br><span class="line"><span class="attr">        max-attempts:</span> <span class="number">3</span> <span class="comment">#重试次数</span></span><br><span class="line"><span class="attr">      discovery:</span> <span class="comment">#使用注册中心查找具体的配置中心地址</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">config-server</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">config</span> <span class="comment">#如果配置中心服务端配置了安全限制，则需要提供用户名和密码</span></span><br><span class="line"><span class="attr">      password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>如果需要配置重试，则需要添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.动态刷新配置。有时动态更新了 <code>Git</code> 仓库的配置，需要在不重启服务的情况下完成配置的动态更新，这需要引入另一个依赖 <code>actuator</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设客户端在 <code>Git</code> 仓库中的配置文件名为 <code>config-client-dev</code>（<code>config-client</code> 为服务名，<code>dev</code> 为活跃的 <code>profile</code>，这些在 <code>bootstrap.yml</code> 中配置，则可将在仓库中的对应的文件结合仓库中默认的 <code>application.yml</code> 作为客户端的配置文件 <code>appilcation.yml</code> 使用），为实现动态更新需要暴露 <code>refresh</code> 端点，这里简单起见开放所有端点，在 <code>bootstrap.yml</code> 或 <code>Git</code> 仓库中的 <code>config-client-dev.yml</code> 中配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure><p>在修改了远程仓库的配置文件（如 <code>application-client.yml</code>）后，需要使用 <code>POST</code> 请求访问服务的 <code>/actuator/refresh</code> 端点完成更新。</p><p>动态刷新配置对使用配置的方式有限制，客户端需通过 <code>@ConfigurationProperties</code>、<code>@Value(&quot;${…​}&quot;)</code> 或 <code>Environment</code> 使用配置中心的配置，这些配置在服务启动时已经加载，而为了强制刷新这些已读取的配置需要加上 <code>@RefreshScope</code> 注解，该注解可对类或者方法作用。</p><blockquote><p>一般配置中心会配合消息总线一起使用，以便通知所有服务某项配置的更新。需要引入消息总线的依赖，具体如何使用可参考 <a href="https://github.com/1016990109/spring-cloud-example" target="_blank" rel="noopener">https://github.com/1016990109/spring-cloud-example</a> 中的 <code>config-server</code> 和 <code>feign-server</code> 的相关配置及代码，这里的例子基于 <code>RabbitMQ</code> 消息队列实现。</p></blockquote><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供 <code>REST API</code> 的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。<code>Spring</code> 官方有推出自己的组件 <code>Spring Cloud Gateway</code>，相比于之前的 <code>Zuul(1.x)</code> 有许多优势：<code>Zuul</code> 基于 <code>servlet 2.5</code>（使用 3.x），使用阻塞 <code>API</code>。 它不支持任何长连接，如 <code>websockets</code>。而 <code>Gateway</code> 建立在 <code>Spring Framework 5</code>，<code>Project Reactor</code> 和 <code>Spring Boot 2</code> 之上，使用非阻塞 <code>API</code>。<code>Websockets</code> 得到支持，并且由于它与 <code>Spring</code> 紧密集成，所以将会是一个更好的开发体验。<code>Spring Cloud Gateway</code> 为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p><p>1.右键项目新建新的 <code>module</code>，同样选择 <code>Spring initializr</code>，选择需要的依赖，勾选 <code>Cloud Routing</code> 中的 <code>Gateway</code>。生成的依赖如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.<code>application.yml</code> 配置示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6606</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      filter:</span></span><br><span class="line">        <span class="comment"># 一些过滤器的配置</span></span><br><span class="line"><span class="attr">        remove-non-proxy-headers:</span> <span class="comment">#以下配置的 Header 不会转发到其他服务去</span></span><br><span class="line"><span class="attr">          headers:</span> <span class="comment"># 配置 RemoveNonProxyHeaders GatewayFilter Factory ?? 好像没有这个工厂</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">dummy</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Connection</span></span><br><span class="line"><span class="attr">        secure-headers:</span> <span class="comment"># 配置 SecureHeaders GatewayFilter Factory，所有返回的响应都带上下面的头部</span></span><br><span class="line"><span class="attr">          content-security-policy:</span> <span class="string">"default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline'"</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">apifeign</span></span><br><span class="line">          <span class="comment"># 重点！/info必须使用http进行转发，lb代表从注册中心获取服务</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">lb://feign_server</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line">            <span class="comment"># 重点！转发该路径！,/feignapi/**,也可以对 Method、Cookie、Header、Query、Host、Time、RemoteAddr 做匹配</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/feignapi/**</span></span><br><span class="line"><span class="attr">          filters:</span> <span class="comment"># 使用 name 配置 filter，自定义（内置不带）的 filter 可在 Config.java 中使用 @Bean 注解获取一个 RouteLocator</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">SecureHeaders</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">RequestRateLimiter</span> <span class="comment">#配置请求频率限制</span></span><br><span class="line"><span class="attr">              args:</span></span><br><span class="line"><span class="attr">                key-resolver:</span> <span class="string">'#&#123;@userKeyResolver&#125;'</span> <span class="comment"># 一定需要 key-resolver 不然默认的 PrincipalNameKeyResolver 会失败</span></span><br><span class="line">                <span class="string">redis-rate-limiter.replenishRate:</span> <span class="number">10</span> <span class="comment">#允许用户每秒处理多少个请求</span></span><br><span class="line">                <span class="string">redis-rate-limiter.burstCapacity:</span> <span class="number">20</span> <span class="comment">#令牌桶的容量，允许在一秒钟内完成的最大请求数</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">StripPrefix=1</span> <span class="comment"># http://localhost:6604/feignapi/instance/2, 必须加上StripPrefix=1，否则访问服务时会带上 feignapi 而不是我们期望的去掉 feign，只保留**部分</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">PrefixPath=/feign-server</span> <span class="comment"># 请求会转发到 /feign-server/** 上</span></span><br></pre></td></tr></table></figure><p>上述的配置可以达到以下效果：凡是以 <code>/feignapi/</code> 开头的请求都会路由到注册中心的 <code>feign-server</code> 服务，并自动实现负载均衡，转发后的请求不再有 <code>/feignapi</code> 前缀但是会添加 <code>/feign-server</code> 作为前缀，且每个用户请求频率不得超过每秒 10 个，总请求数不得超过 20。转发请求时，不再携带头部 <code>dummy</code>、<code>Connection</code>，响应附带头部 <code>default-src &#39;self&#39; https:; font-src &#39;self&#39; https: data:; img-src &#39;self&#39; https: data:; object-src &#39;none&#39;; script-src https:; style-src &#39;self&#39; https: &#39;unsafe-inline&#39;</code>。</p><p>注意：实现网关限流需额外安装依赖以及配置 <code>key-resolver</code>，详情可移步作者 <code>Github</code> 仓库 <a href="https://github.com/1016990109/spring-cloud-example" target="_blank" rel="noopener">https://github.com/1016990109/spring-cloud-example</a>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">userKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了根据请求路径路由外，<code>Spring Cloud Gateway</code> 还可以根据时间、<code>Cookie</code>、<code>Header</code>、<code>Host</code>、请求方式、请求参数、请求 <code>ip</code> 地址，或者将它们组合使用。具体使用方式读者可以自行查询 <code>Predicate</code> 的介绍。</p></blockquote><h2 id="服务提供者（基于-Fiegn-服务调用中的服务端）"><a href="#服务提供者（基于-Fiegn-服务调用中的服务端）" class="headerlink" title="服务提供者（基于 Fiegn 服务调用中的服务端）"></a>服务提供者（基于 Fiegn 服务调用中的服务端）</h2><p>服务的提供者，提供接口供调用者调用，是服务调用中的“服务端”。</p><p>1.服务端依赖。包括 <code>web</code>、<code>open-feign</code>、注册中心：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.<code>application.yml</code> 配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    response:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>目的是为了启动服务间调用的压缩（<code>GZIP</code>），减少通信中的性能损耗。</p><p>3.启动类配置：需加上 <code>@EnableFeignClients</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(FeignServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.提供接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/feign-server"</span>)</span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignServiceController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;feign-server.version&#125;"</span>)</span><br><span class="line">    String version;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/instance/&#123;serviceId&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InstanceDTO <span class="title">getInstanceByServiceId</span><span class="params">(@PathVariable(<span class="string">"serviceId"</span>)</span> String serviceId) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstanceDTO(<span class="string">"version:"</span> + version + <span class="string">",serviceId:"</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即完成了基于 <code>Spring Cloud OpenFeign</code> 的服务间调用的服务端配置。</p><h2 id="服务调用者（基于-Fiegn-服务调用中的客户端）"><a href="#服务调用者（基于-Fiegn-服务调用中的客户端）" class="headerlink" title="服务调用者（基于 Fiegn 服务调用中的客户端）"></a>服务调用者（基于 Fiegn 服务调用中的客户端）</h2><p>服务的调用者，是服务间调用的发起者。</p><p>1.客户端依赖。包括 <code>web</code>、注册中心、熔断器等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.<code>application.yml</code> 配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span> <span class="comment"># feign 集成了熔断器，通过 feign.hystrix.enabled=true 启动</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line">    <span class="comment"># 启用 gzip 压缩</span></span><br><span class="line"><span class="attr">    response:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">'*'</span> <span class="comment"># 默认只有 info 和 health， 允许 hystrix.stream 等</span></span><br><span class="line"><span class="attr">  endpoint:</span></span><br><span class="line"><span class="attr">    health:</span></span><br><span class="line"><span class="attr">      show-details:</span> <span class="string">always</span> <span class="comment"># 在 health 的信息中显示详情，包括hystrix</span></span><br></pre></td></tr></table></figure><p>上述出了配置 <code>Feign</code> 的相关配置、熔断外，还配置了 <code>hystrix</code> 监控即 <code>hystrix.stream</code>(访问 <code>http://localhost:port/actuator/hystrix.stream</code> 可查看相关统计数据，当然也可以配合 <code>turbine</code> 统一监控应用，这需要加入 <code>hystrix-dashboard</code> 依赖，又在上文提到，本项目采用单体应用的监控，可访问 <code>http://localhost:post/hystrix</code> 进入 <code>Hystrix DashBoard</code> 界面)。</p><p>3.启动类配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>EnableCircuitBreaker</code> 配置 <code>Feign</code> 的熔断，使用 <code>EnableHystrixDashBoard</code> 启用熔断监控，使用 <code>@EnableFeignClients</code> 启动 <code>Open Fiegn</code>。</p><p>4.声明调用的服务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"feign-server"</span>, fallback = FeignServiceClientFallBack.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 feign-server 的 feign-server/instance/&#123;serviceId&#125; 接口，获得返回值（类型 InstanceDTO）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/feign-server/instance/&#123;serviceId&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function">TestDTO <span class="title">getInstanceByServiceId</span><span class="params">(@PathVariable(<span class="string">"serviceId"</span>)</span> String serviceId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@FeignClient(value = &quot;feign-server&quot;, fallback = FeignServiceClientFallBack.class)</code> 配置调用服务的名称（在注册中心的名称），以便像注册中心获取相应的服务实例地址（负载均衡的），接口主体部分保持和服务端相同即可，即 <code>Test getInstanceByServiceId(..)</code>。</p><p>而 <code>fallback</code> 则是断路器的配置，当服务（服务端）的错误率超过一定阀值时，<code>Hystrix</code> 可以触发断路机制，停止向该服务请求一段时间，而直接使用 <code>fallback</code> 指定的类作为接口实现，直接返回数据。</p><p>阀值有几个指标： 1.一定时间（默认 10s）内错误一定数量（默认 20 次）； 2.请求错误数量超过一定百分比（默认 50%）。</p><p>当某个服务的断路器打开后，<code>Hystrix</code> 将不会请求至该服务，直接 <code>fallback</code>，这样对于已经确定的故障在一定时间内不会再尝试。当断路器打开一段时间后，<code>Hystrix</code> 会进入”半开”状态，断路器会允许一个请求尝试对服务进行请求，如果该服务可以调用成功，则关闭断路器，否则将继续保持断路器打开，并进入倒计时，倒计时结束后继续尝试自动恢复。</p><p>5.开始服务调用。使用非常简单，像使用普通的本地接口一般使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">FeignServiceClient feignServiceClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/instance/&#123;serviceId&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> TestDTO <span class="title">getInstanceByServiceId</span><span class="params">(@PathVariable(<span class="string">"serviceId"</span>)</span> String serviceId) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> feignServiceClient.getInstanceByServiceId(serviceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里声明的接口返回数据类型的名称可以不相同，也可以只保留部分字段，如服务端提供的是 <code>InstanceDTO</code> 而客户端调用时声明的为 <code>TestDTO</code>，<code>Feign</code> 会自动地序列化与反序列化（<code>JSON</code>），不像 <code>Java</code> 自带的序列化工具那般要求类完全相同（序列号即成员变量等等都要求相同）。具体使用可参考 <a href="https://github.com/1016990109/spring-cloud-example" target="_blank" rel="noopener">https://github.com/1016990109/spring-cloud-example</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Spring Cloud&lt;/code&gt; 是一个基于 &lt;code&gt;Spring Boot&lt;/code&gt; 实现的云应用开发工具，它为基于 &lt;code&gt;JVM&lt;/code&gt; 的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Spring Cloud&lt;/code&gt; 包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：&lt;code&gt;Spring Cloud Config&lt;/code&gt;、&lt;code&gt;Spring Cloud Netflix&lt;/code&gt;、&lt;code&gt;Spring Cloud Data&lt;/code&gt;、&lt;code&gt;Spring Cloud AWS&lt;/code&gt;、&lt;code&gt;Spring Cloud Security&lt;/code&gt;、&lt;code&gt;Spring Cloud Commons&lt;/code&gt;、&lt;code&gt;Spring Cloud Gateway&lt;/code&gt;、&lt;code&gt;Spring Cloud CLI&lt;/code&gt; 等项目。&lt;/p&gt;
&lt;p&gt;下面分别从以下几块来开始搭建我们的 &lt;code&gt;Spring Cloud&lt;/code&gt; 应用（基于 &lt;code&gt;Greenwich.M3&lt;/code&gt; 版本，建议读者使用稳定版本，这里只是尝试新特性，文末有项目地址）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公共父项目（&lt;code&gt;spring-cloud-example&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;注册中心（&lt;code&gt;eureka&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;配置中心（&lt;code&gt;config-server&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;网关（&lt;code&gt;gateway&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;服务提供者（&lt;code&gt;feign-server&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;服务消费者（&lt;code&gt;feign-client&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="spring cloud" scheme="http://1016990109.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Linux 命令 —— 编写Shell脚本</title>
    <link href="http://1016990109.github.io/2018/12/04/Linux-%E5%91%BD%E4%BB%A4-%E7%BC%96%E5%86%99Shell%E8%84%9A%E6%9C%AC/"/>
    <id>http://1016990109.github.io/2018/12/04/Linux-命令-编写Shell脚本/</id>
    <published>2018-12-04T12:36:52.000Z</published>
    <updated>2019-01-29T09:43:29.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写第一个-Shell-脚本"><a href="#编写第一个-Shell-脚本" class="headerlink" title="编写第一个 Shell 脚本"></a>编写第一个 Shell 脚本</h2><ol><li>编写一个脚本</li><li>使脚本可执行</li><li>把脚本放到 <code>Shell</code> 能找到的地方</li></ol><a id="more"></a><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># This is our first script.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Hello World!'</span></span><br></pre></td></tr></table></figure><p><code>#</code> 代表注释，可以在单独一行，也可以在一行的末尾。<code>#!</code> 字符序列是一种特殊的结构叫做 <code>shebang</code>。 这个 <code>shebang</code> 被用来告诉操作系统将执行此脚本所用的解释器的名字。<strong>每个 <code>shell</code> 脚本都应该把这一文本行作为它的第一行</strong>。</p><h3 id="可执行权限"><a href="#可执行权限" class="headerlink" title="可执行权限"></a>可执行权限</h3><p>对于脚本文件，有两个常见的权限设置；权限为 755 的脚本，则每个人都能执行，和权限为 700 的脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。</p><h3 id="脚本文件位置"><a href="#脚本文件位置" class="headerlink" title="脚本文件位置"></a>脚本文件位置</h3><p>直接执行脚本文件是会报错的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ hello_world</span><br><span class="line">bash: hello_world: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>如果没有给出可执行程序的明确路径名，那么系统每次都会搜索一系列的目录，来查找此可执行程序。这个 <code>/bin</code> 目录就是其中一个系统会自动搜索的目录。这个目录列表被存储在一个名为 <code>PATH</code> 的环境变量中。这个 <code>PATH</code> 变量包含一个由冒号分隔开的目录列表。</p><p>所以如果我们创建了一个 <code>bin</code> 目录，并把我们的脚本放在这个目录下，那么这个脚本就应该像其它程序一样开始工作了。如果这个 <code>PATH</code> 变量不包含这个目录，我们能够轻松地添加它，通过在我们的 <code>.bashrc</code> 文件中包含下面这一行文本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=~/bin:<span class="string">"<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure><p>可以通过 “sourcing” .bashrc 文件来使得修改立即生效，这个 <code>.</code> 和 <code>source</code> 是同样的作用，一个 <code>shell</code> 内建命令，用来读取一个指定的 <code>shell</code> 命令文件。</p><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写第一个-Shell-脚本&quot;&gt;&lt;a href=&quot;#编写第一个-Shell-脚本&quot; class=&quot;headerlink&quot; title=&quot;编写第一个 Shell 脚本&quot;&gt;&lt;/a&gt;编写第一个 Shell 脚本&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;编写一个脚本&lt;/li&gt;
&lt;li&gt;使脚本可执行&lt;/li&gt;
&lt;li&gt;把脚本放到 &lt;code&gt;Shell&lt;/code&gt; 能找到的地方&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://1016990109.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Web Components</title>
    <link href="http://1016990109.github.io/2018/11/28/Web-Components/"/>
    <id>http://1016990109.github.io/2018/11/28/Web-Components/</id>
    <published>2018-11-28T07:37:35.000Z</published>
    <updated>2019-01-01T14:02:26.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义元素-Custom-Elements"><a href="#自定义元素-Custom-Elements" class="headerlink" title="自定义元素(Custom Elements)"></a>自定义元素(Custom Elements)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>借助自定义元素，网络开发者可以创建新的 <code>HTML</code> 标记、扩展现有 <code>HTML</code> 标记，或者扩展其他开发者编写的组件。</p><h2 id="定义新元素"><a href="#定义新元素" class="headerlink" title="定义新元素"></a>定义新元素</h2><p>定义一个新元素需要使用 <code>customElements.define()</code>：</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况，普通类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.private = <span class="string">'private'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> get observedAttributes() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'disabled'</span>, <span class="string">'open'</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开放属性的 getter 和 setter</span></span><br><span class="line">  get open() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get property'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getAttribute(<span class="string">'open'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set open(val) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set property'</span>)</span><br><span class="line">    <span class="keyword">if</span> (val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setAttribute(<span class="string">'open'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeAttribute(<span class="string">'open'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用短横线</span></span><br><span class="line">customElements.define(<span class="string">'app-drawer'</span>, AppDrawer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'app-drawer'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;...&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>名称必须包含短横线（不能无短横线，也不能是下划线）。<br>不能多次注册同一标记。否则，将产生 <code>DOMException</code>。让浏览器了解新标记后，它就这样定了下来，不能撤回。<br>自定义元素不能自我封闭，因为 <code>HTML</code> 仅允许少数元素自我封闭。必须编写封闭标记 (<code>&lt;app-drawer&gt;&lt;/app-drawer&gt;</code>)。</p></blockquote><h2 id="扩展元素"><a href="#扩展元素" class="headerlink" title="扩展元素"></a>扩展元素</h2><p>可扩展自定义的元素，也可以扩展原生元素，使用 <code>extends</code> 来扩展。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyDrawer</span> <span class="keyword">extends</span> <span class="title">AppDrawer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// always call super() first in the constructor. This also calls the extended class' constructor.</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'fancy-app-drawer'</span>, FancyDrawer);</span><br></pre></td></tr></table></figure><p>扩展原生元素需要继承内置的元素比如：<code>HTMLButtonElement</code>、<code>HTMLQuoteElement</code>，且 <code>define</code> 必须传第三个参数以声明是扩展哪个具体的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展内置 html 元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.style.backgroundColor = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'click'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展原生元素第三个参数需要告知是哪个原生组件</span></span><br><span class="line">customElements.define(<span class="string">'custom-button'</span>, CustomButton, &#123; <span class="attr">extends</span>: <span class="string">'button'</span> &#125;)</span><br></pre></td></tr></table></figure><p>自定义内置元素的用户有多种方法来使用该元素。他们可以通过在原生标记上添加 <code>is=&quot;&quot;</code> 属性来声明(某些浏览器不推荐使用 <code>is</code>)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- This &lt;button&gt; is a custom button. --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 某些浏览器不推荐使用is  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"custom-button"</span> <span class="attr">disabled</span>&gt;</span>Custom button!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者在 <code>JavaScript</code> 中创建实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Custom elements overload createElement() to support the is="" attribute.</span></span><br><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>, &#123; <span class="attr">is</span>: <span class="string">'fancy-button'</span> &#125;)</span><br><span class="line">button.textContent = <span class="string">'Fancy button!'</span></span><br><span class="line">button.disabled = <span class="literal">true</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(button)</span><br></pre></td></tr></table></figure><p>或者使用 <code>new</code> 运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> FancyButton()</span><br><span class="line">button.textContent = <span class="string">'Fancy button!'</span></span><br><span class="line">button.disabled = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="创建限制"><a href="#创建限制" class="headerlink" title="创建限制"></a>创建限制</h2><p>1.创建自定义元素或扩展元素必须在 <code>&lt;/body&gt;</code> 前，不允许放在 <code>&lt;head&gt;&lt;/head&gt;</code> 中。</p><p>2.自定义元素构造函数约束：</p><ul><li>一个无参数的调用 <code>super()</code> 必须在构造函数体的第一条语句，树立正确的原型链，这是运行任何进一步的代码前提。</li><li>一个 <code>return</code> 语句不能在构造函数体内的任何地方出现，除非它是一个简单的返回（<code>return</code> 或 <code>return this</code>）。</li><li>构造函数中不能使用 <code>document.write()</code> 或 <code>document.open()</code> 方法。</li><li>该元素的属性和 <code>children</code> 获取不了，如不升级(即 <code>customElements.define()</code>)的情况下，是不会存在的。</li><li>该元素不能获得任何属性或 <code>children</code>，因为这违反了使用 <code>createElement</code> 或 <code>createElementNS</code> 方法的限制。</li><li>在一般情况下，工作应尽可能推迟到 <code>connectedCallback</code>，尤其是抓取资源或渲染。但是请注意，<code>connectedCallback</code> 可以调用一次以上，从而需要保证只运行了一次，以阻止其运行两次任何初始化工作。</li><li>一般来说，构造函数是用来建立初始状态和默认值的，并设置事件侦听器和可能的 <code>Shadow Root</code>。</li></ul><h2 id="自定义元素响应"><a href="#自定义元素响应" class="headerlink" title="自定义元素响应"></a>自定义元素响应</h2><p>自定义元素可以定义特殊生命周期钩子，以便在其存续的特定时间内运行代码。</p><table><thead><tr><th>名称</th><th>调用时机</th></tr></thead><tbody><tr><td>constructor</td><td>创建或升级元素的一个实例。用于初始化状态、设置事件侦听器或创建 Shadow DOM。参见规范，了解可在 constructor 中完成的操作的相关限制。</td></tr><tr><td>connectedCallback</td><td>元素每次插入到 DOM 时都会调用。用于运行安装代码，例如获取资源或渲染。一般来说，应将工作延迟至合适时机执行。</td></tr><tr><td>disconnectedCallback</td><td>元素每次从 DOM 中移除时都会调用。用于运行清理代码（例如移除事件侦听器等）。</td></tr><tr><td>attributeChangedCallback(attrName, oldVal, newVal)</td><td>属性添加、移除、更新或替换。解析器创建元素时，或者升级时，也会调用它来获取初始值。Note: 仅 observedAttributes 属性中列出的特性才会收到此回调。</td></tr><tr><td>adoptedCallback()</td><td>自定义元素被移入新的 document（例如，有人调用了 document.adoptNode(el)）。或者从一个 iframe 移动到另一个 iframe。</td></tr></tbody></table><blockquote><p>浏览器对在 <code>attributeChangedCallback()</code> 数组中添加到白名单的任何属性调用 <code>observedAttributes</code>（请参阅<a href="#保留对属性的更改">保留对属性</a>的更改）。实际上，这是一项性能优化。当用户更改一个通用属性（如 <code>style</code> 或 <code>class</code>）时，不希望出现大量的回调。</p></blockquote><blockquote><p>响应回调是同步的。如果对的元素调用 <code>el.setAttribute(...)</code>，浏览器将立即调用 <code>attributeChangedCallback()</code>。 同理，从 <code>DOM</code> 中移除元素（例如用户调用 <code>el.remove()</code>）后，就会立即收到 <code>disconnectedCallback()</code>。</p></blockquote><h2 id="属性和特性（property-and-attribute）"><a href="#属性和特性（property-and-attribute）" class="headerlink" title="属性和特性（property and attribute）"></a>属性和特性（property and attribute）</h2><h3 id="将属性-property-映射为特性-attribute"><a href="#将属性-property-映射为特性-attribute" class="headerlink" title="将属性(property)映射为特性(attribute)"></a>将属性(property)映射为特性(attribute)</h3><p><code>HTML</code> 属性通常会将其值以 <code>HTML</code> 特性的形式映射回 <code>DOM</code>。例如，如果 <code>hidden</code> 或 <code>id</code> 的值在 <code>JS</code> 中发生变更：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.id = <span class="string">'my-id'</span></span><br><span class="line">div.hidden = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>值将以特性的形式应用于活动 <code>DOM</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"my-id"</span> <span class="attr">hidden</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这称为“将属性映射为特性”。几乎所有的 <code>HTML</code> 属性都会如此。为何？特性也可用于以声明方式配置元素，且无障碍功能和 <code>CSS</code> 选择器等某些 <code>API</code> 依赖于特性工作。关于 <code>property</code> 和 <code>attribute</code> 的关系可以查看 <a href="/2018/09/08/前端基础之JS/#attribute-和-property">前端基础之 JS——attribute 和 property</a>。</p><h3 id="保留对属性的更改"><a href="#保留对属性的更改" class="headerlink" title="保留对属性的更改"></a>保留对属性的更改</h3><p><code>HTML</code> 属性可方便地让用户声明初始状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;app-drawer open disabled /&gt;</span><br></pre></td></tr></table></figure><p>元素可通过定义 <code>attributeChangedCallback</code> 来对属性的更改作出响应。对于 <code>observedAttributes</code> 数组中列出的每一属性更改，浏览器都将调用此方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> get observedAttributes() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'disabled'</span>, <span class="string">'open'</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get disabled() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hasAttribute(<span class="string">'disabled'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set disabled(val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setAttribute(<span class="string">'disabled'</span>, <span class="string">''</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeAttribute(<span class="string">'disabled'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only called for the disabled and open attributes due to observedAttributes</span></span><br><span class="line">  attributeChangedCallback(name, oldValue, newValue) &#123;</span><br><span class="line">    <span class="comment">// When the drawer is disabled, update keyboard/screen reader behavior.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.disabled) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setAttribute(<span class="string">'tabindex'</span>, <span class="string">'-1'</span>);</span><br><span class="line">      <span class="keyword">this</span>.setAttribute(<span class="string">'aria-disabled'</span>, <span class="string">'true'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setAttribute(<span class="string">'tabindex'</span>, <span class="string">'0'</span>);</span><br><span class="line">      <span class="keyword">this</span>.setAttribute(<span class="string">'aria-disabled'</span>, <span class="string">'false'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> also react to the open attribute changing.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素升级"><a href="#元素升级" class="headerlink" title="元素升级"></a>元素升级</h2><h3 id="自定义元素可以在定义注册之前使用"><a href="#自定义元素可以在定义注册之前使用" class="headerlink" title="自定义元素可以在定义注册之前使用"></a>自定义元素可以在定义注册之前使用</h3><p>渐进式增强是自定义元素的一项特点。换句话说，可以在页面声明多个 <code>&lt;app-drawer&gt;</code> 元素，并在等待较长的时间之后才调用 <code>customElements.define(&#39;app-drawer&#39;, ...)</code>。之所以会这样，原因是浏览器会因为存在未知标记而采用不同方式处理潜在自定义元素。调用 <code>define()</code> 并将类定义赋予现有元素的过程称为“元素升级”。</p><p>要了解标记名称何时获得定义，可以使用 <code>window.customElements.whenDefined()</code>。它提供可在元素获得定义时进行解析的 <code>Promise</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">customElements.whenDefined(<span class="string">'app-drawer'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当组件加载完，比如获取完需要的资源时候进行的操作</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'app-drawer defined'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="元素定义的内容"><a href="#元素定义的内容" class="headerlink" title="元素定义的内容"></a>元素定义的内容</h2><h3 id="创建使用-Shadow-DOM-的元素"><a href="#创建使用-Shadow-DOM-的元素" class="headerlink" title="创建使用 Shadow DOM 的元素"></a>创建使用 Shadow DOM 的元素</h3><p>元素的内容推荐使用 <code>Shadow DOM</code> 的 <code>API</code> 来创建，因为使用其他的 <code>API</code> 来填充元素内容会覆盖用户元素的子项(<code>&lt;custom-button&gt;&lt;div&gt;&lt;/div&lt;/custom-button&gt;</code> 中的 <code>div</code> 会被舍弃)，这和用户预期的可能不太一样。</p><p><code>Shadow DOM</code> 提供了一种方法，可让元素以独立于页面其余部分的方式拥有和渲染 <code>DOM</code> 并设置其样式。 甚至可以使用一个标记来隐藏整个应用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- chat-app 具体的实现细节隐藏在 Shadow DOM. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">chat-app</span>&gt;</span><span class="tag">&lt;/<span class="name">chat-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要在自定义元素中使用 <code>Shadow DOM</code>，可在 <code>constructor</code> 内调用 <code>this.attachShadow</code>，<code>slot</code> 标签包含的内容就是用户自定义的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">customElements.define(</span><br><span class="line">  <span class="string">'x-foo-shadowdom'</span>,</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">super</span>() <span class="comment">// always call super() first in the constructor.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach a shadow root to the element.</span></span><br><span class="line">      <span class="keyword">let</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">'open'</span> &#125;)</span><br><span class="line">      <span class="comment">// innerHTML 或者其他 API 使用就略显丑陋，推荐 template</span></span><br><span class="line">      shadowRoot.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;style&gt;:host &#123; ... &#125;&lt;/style&gt; &lt;!-- look ma, scoped styles --&gt;</span></span><br><span class="line"><span class="string">      &lt;b&gt;I'm in shadow dom!&lt;/b&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="通过-创建元素"><a href="#通过-创建元素" class="headerlink" title="通过  创建元素"></a>通过 <template> 创建元素</template></h3><p><code>template</code> 片段在页面加载时解析并驻留，且于后续运行时激活。它是网页组件家族中的另一 <code>API</code> 原语。<strong>模板是声明自定义元素结构的理想之选</strong>。</p><p>使用示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这部分是不会渲染的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"x-foo-from-template"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    p &#123;</span></span><br><span class="line"><span class="undefined">      color: orange;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm in Shadow DOM.My markup was stamped from a &amp;lt;template&amp;gt;.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  customElements.define(</span></span><br><span class="line"><span class="javascript">    <span class="string">'x-foo-from-template'</span>,</span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span>() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">super</span>() <span class="comment">// always call super() first in the constructor.</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">'open'</span> &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> t = <span class="built_in">document</span>.querySelector(<span class="string">'#x-foo-from-template'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> instance = t.content.cloneNode(<span class="literal">true</span>)</span></span><br><span class="line"><span class="undefined">        shadowRoot.appendChild(instance)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// other code</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  )</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="设置自定义元素样式"><a href="#设置自定义元素样式" class="headerlink" title="设置自定义元素样式"></a>设置自定义元素样式</h2><p>自定义元素样式和原生元素样式使用方式一样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">app-drawer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用户定义样式优先级大于 <code>Shadow DOM</code> 中定义的样式。</p></blockquote><h3 id="预设置未注册元素的样式"><a href="#预设置未注册元素的样式" class="headerlink" title="预设置未注册元素的样式"></a>预设置未注册元素的样式</h3><p>还没有调用 <code>customElements.define</code> 的未定义元素可以使用 <code>CSS</code> 中 <code>:defined</code> 伪类来定义目标。</p><p>在定义前隐藏元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">app-drawer</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:defined)</span> &#123;</span><br><span class="line">  <span class="comment">/* Pre-style, give layout, replicate app-drawer's eventual styles, etc. */</span></span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.3s</span> ease-in-out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>浏览器支持非标准元素，例如 <code>&lt;randomtagthatdoesntexist&gt;&lt;/&lt;randomtagthatdoesntexist&gt;</code> 在浏览器中也能正常解析，<code>HTML</code> 规范允许这样。规范没有定义的元素作为 <code>HTMLUnknownElement</code> 进行解析。自定义元素则并非如此。如果在创建时使用有效的名称（包含“-”），则潜在的自定义元素将解析为 <code>HTMLElement</code>，就是说 <code>&lt;has-line&gt;&lt;/has-line&gt;</code> 会被解析为 <code>HTMLElement</code>，这和普通非标准元素不同，所以严格要求自定义元素名称必须包含中横线。</p><h2 id="结论（Web-Fundamentals-自定义元素-v1：可重用网络组件）"><a href="#结论（Web-Fundamentals-自定义元素-v1：可重用网络组件）" class="headerlink" title="结论（Web Fundamentals 自定义元素 v1：可重用网络组件）"></a>结论（Web Fundamentals 自定义元素 v1：可重用网络组件）</h2><p>自定义元素提供了一种新工具，可让我们在浏览器中定义新 <code>HTML</code> 标记并创建可重用的组件。将它们与 <code>Shadow DOM</code> 和 <code>&lt;template&gt;</code> 等新平台原语结合使用，我们可开始实现网络组件的宏大图景：</p><ul><li>创建和扩展<strong>可重复</strong>使用组件的跨浏览器（网络标准）。</li><li>无需库或框架即可使用。<strong>原生</strong> <code>JS/HTML</code> 威武！</li><li>提供熟悉的编程模型。仅需使用 <code>DOM/CSS/HTML</code>。</li><li>与其他网络平台功能良好匹配（<code>Shadow DOM</code>、<code>&lt;template&gt;</code>、<code>CSS</code> 自定义属性等）</li><li>与浏览器的 <code>DevTools</code> 紧密集成。</li><li>利用现有的无障碍功能。</li></ul><h1 id="Shadow-DOM-Shadow-DOM-v1-规范"><a href="#Shadow-DOM-Shadow-DOM-v1-规范" class="headerlink" title="Shadow DOM(Shadow DOM v1 规范)"></a>Shadow DOM(Shadow DOM v1 规范)</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><code>Shadow DOM</code> 解决了构建网络应用的脆弱性问题。脆弱性是由 <code>HTML</code>、<code>CSS</code> 和 <code>JS</code> 的全局性引起的，例如同一个 <code>class</code> 可能会在多处定义，造成了用户不期望的覆盖，这就逼迫开发者使用 <code>!important</code>，最终使得代码可读性变得很差。</p><p><code>Shadow DOM</code> 修复了 <code>CSS</code> 和 <code>DOM</code>。它在网络平台中引入作用域样式。无需工具或命名约定，即可使用原生 <code>JavaScript</code> 捆绑 <code>CSS</code> 和标记、隐藏实现详情以及编写独立的组件。</p><p><code>Shadow DOM</code> 作用：</p><ul><li>隔离 <code>DOM</code>：组件的 <code>DOM</code> 是独立的（例如，<code>document.querySelector()</code> 不会返回组件 <code>Shadow DOM</code> 中的节点）。</li><li>作用域 <code>CSS</code>：<code>Shadow DOM</code> 内部定义的 <code>CSS</code> 在其作用域内。样式规则不会泄漏，页面样式也不会渗入。</li><li>组合：为组件设计一个声明性、基于标记的 <code>API</code>。</li><li>简化 <code>CSS</code>： 作用域 <code>DOM</code> 意味着可以使用简单的 <code>CSS</code> 选择器，更通用的 <code>id/类</code> 名称，而无需担心命名冲突。</li><li>效率： 将应用看成是多个 <code>DOM</code> 块，而不是一个大的（全局性）页面。</li></ul><h2 id="什么是-Shadow-DOM"><a href="#什么是-Shadow-DOM" class="headerlink" title="什么是 Shadow DOM"></a>什么是 Shadow DOM</h2><p><code>Shadow DOM</code> 与普通 <code>DOM</code> 相同，但有两点区别：</p><ol><li>创建/使用的方式；</li><li>与页面其他部分有关的行为方式。</li></ol><p>通常，创建 <code>DOM</code> 节点并将其附加至其他元素作为子项。借助于 <code>Shadow DOM</code>，可以创建作用域 <code>DOM</code> 树，该 <code>DOM</code> 树附加至该元素上，但与其自身真正的子项分离开来。这一作用域子树称为影子树。被附着的元素称为影子宿主。在影子中添加的任何项均将成为宿主元素的本地项，包括 <code>&lt;style&gt;</code>。 这就是 <code>Shadow DOM</code> 实现 <code>CSS</code> 样式作用域的方式。</p><h2 id="创建-Shadow-DOM"><a href="#创建-Shadow-DOM" class="headerlink" title="创建 Shadow DOM"></a>创建 Shadow DOM</h2><p>影子根是附加至“宿主”元素的文档片段。使用 <code>element.attachShadow()</code> 创建 <code>Shadow DOM</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">'header'</span>)</span><br><span class="line"><span class="keyword">const</span> shadowRoot = header.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">'open'</span> &#125;)</span><br><span class="line">shadowRoot.innerHTML = <span class="string">'&lt;h1&gt;Hello Shadow DOM&lt;/h1&gt;'</span> <span class="comment">// Could also use appendChild().</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// header.shadowRoot === shadowRoot</span></span><br><span class="line"><span class="comment">// shadowRoot.host === header</span></span><br></pre></td></tr></table></figure><p>规范定义了元素列表，这些元素无法托管影子树，可托管的元素查看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow</a> 元素之所以在所选之列，其原因如下：</p><ul><li>浏览器已为该元素托管其自身的内部 <code>shadow DOM</code>（<code>&lt;textarea&gt;</code>、<code>&lt;input&gt;</code>）。</li><li>让元素托管 <code>shadow DOM</code> 毫无意义 (<code>&lt;img&gt;</code>)。</li></ul><p>为自定义元素创建 <code>shadow DOM</code> 在上文<a href="#自定义元素-Custom-Elements">自定义元素</a>中已经提到了。</p><h2 id="组合和-slot"><a href="#组合和-slot" class="headerlink" title="组合和 slot"></a>组合和 slot</h2><h3 id="Light-DOM"><a href="#Light-DOM" class="headerlink" title="Light DOM"></a>Light DOM</h3><p>组件用户编写的标记。该 <code>DOM</code> 不在组件 <code>shadow DOM</code> 之内。 它是元素实际的子项。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"better-button"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- the image and span are better-button's light DOM --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"gear.svg"</span> <span class="attr">slot</span>=<span class="string">"icon"</span> /&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Settings<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h3><p>该 <code>DOM</code> 是由组件的作者编写。<code>Shadow DOM</code> 对于组件而言是本地的，它定义内部结构、作用域 <code>CSS</code> 并封装实现详情。它还可定义如何渲染由组件使用者编写的标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#shadow-root</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  ...;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span> <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="扁平的-DOM-树"><a href="#扁平的-DOM-树" class="headerlink" title="扁平的 DOM 树"></a>扁平的 DOM 树</h3><p>浏览器将用户的 <code>light DOM</code> 分布到 <code>shadow DOM</code> 的结果，对最终产品进行渲染。扁平树是指在 <code>DevTools</code> 中最终看到的树以及在页面上渲染的对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"better-button"</span>&gt;</span></span><br><span class="line">  #shadow-root</span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    ...;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"icon"</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"gear.svg"</span> <span class="attr">slot</span>=<span class="string">"icon"</span> /&gt;</span> <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Settings<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="元素"><a href="#元素" class="headerlink" title=" 元素"></a><slot> 元素</slot></h3><p><code>Shadow DOM</code> 使用 <code>&lt;slot&gt;</code> 元素将不同的 <code>DOM</code> 树组合在一起。<code>slot</code> 是组件内部的占位符，用户可以使用自己的标记来填充。</p><p>通过定义一个或多个 <code>slot</code>，可将外部标记引入到组件的 <code>shadow DOM</code> 中进行渲染。这相当于在说“在此处渲染用户的标记”。</p><p><strong>这个和 <code>Vue</code> 中的 <code>slot</code> 很像。</strong></p><p>组件可在其 <code>shadow DOM</code> 中定义零个或多个 <code>slot</code>。<code>slot</code> 可以为空，或者提供回退内容。如果用户不提供 <code>light DOM</code> 内容，<code>slot</code> 将对其备用内容进行渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Default slot. If there's more than one default slot, the first is used. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 备用内容的 slot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span>Fancy button<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- default slot with fallback content --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- default slot entire DOM tree as fallback --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>Description text<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还可以创建指定名称的 <code>slot</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#shadow-root</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tabs"</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span> <span class="attr">id</span>=<span class="string">"tabsSlot"</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"panels"</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span> <span class="attr">id</span>=<span class="string">"panelsSlot"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fancy-tabs</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 三个 button 会插入到 id 为 tabsSlot 的 slot 中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">"title"</span> <span class="attr">selected</span>&gt;</span>Title 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>Title 3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他的 light DOM 都会插入到默认 slot 中，即 id 为 panelsSlot 的 slot 中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span>content panel 1<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span>content panel 2<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span>content panel 3<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fancy-tabs</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果(扁平的 DOM 树)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fancy-tabs</span>&gt;</span></span><br><span class="line">  #shadow-root</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tabs"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">id</span>=<span class="string">"tabsSlot"</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">"title"</span> <span class="attr">selected</span>&gt;</span>Title 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>Title 3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"panels"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">id</span>=<span class="string">"panelsSlot"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span>&gt;</span>content panel 1<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span>&gt;</span>content panel 2<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span>&gt;</span>content panel 3<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fancy-tabs</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="设定样式"><a href="#设定样式" class="headerlink" title="设定样式"></a>设定样式</h2><h3 id="组件定义的样式"><a href="#组件定义的样式" class="headerlink" title="组件定义的样式"></a>组件定义的样式</h3><p>通常的做法就是在 <code>template</code> 中定义样式，也可以使用样式表。如果需要为组件自身定义样式可以使用 <code>:host</code> 伪类：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">display</span>: <span class="selector-tag">block</span>; <span class="comment">/* by default, custom elements are display: inline */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">contain</span>: <span class="selector-tag">content</span>; <span class="comment">/* CSS containment FTW. */</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>:host</code> 的一个问题是，父页面中的规则较之在元素中定义的 <code>:host</code> 规则具有更高的特异性。也就是说，外部样式优先。这可让用户从外部替换的顶级样式。此外，<code>:host</code> 仅在影子根范围内起作用，因此无法在 <code>shadow DOM</code> 之外使用，也就是必须在 <code>template</code> 中使用或者对 <code>shadow-root</code> 使用其他样式 <code>API</code> 来完成。</p><p>使用 <code>:host</code> 的一些例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">opacity</span>: 0<span class="selector-class">.4</span>;</span></span><br><span class="line"><span class="undefined">    will-change: opacity;</span></span><br><span class="line"><span class="undefined">    transition: opacity 300ms ease-in-out;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-pseudo">:host(</span><span class="selector-pseudo">:hover)</span> &#123;</span></span><br><span class="line"><span class="undefined">    opacity: 1;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-pseudo">:host(</span><span class="selector-attr">[disabled]</span>) &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* style when host has disabled attribute. */</span></span></span><br><span class="line"><span class="undefined">    background: grey;</span></span><br><span class="line"><span class="undefined">    pointer-events: none;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">opacity</span>: 0<span class="selector-class">.4</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-pseudo">:host(.blue)</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-tag">blue</span>; <span class="comment">/* color host when it has class="blue" */</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-pseudo">:host(.pink)</span> &gt; <span class="selector-id">#tabs</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-tag">pink</span>; <span class="comment">/* color internal #tabs node when host has class="pink". */</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于情景设定样式"><a href="#基于情景设定样式" class="headerlink" title="基于情景设定样式"></a>基于情景设定样式</h3><p>如果 <code>:host-context(&lt;selector&gt;)</code> 或其任意父级与 <code>&lt;selector&gt;</code> 匹配，它将与组件匹配。一个常见用途是根据组件的环境进行主题化。其中的 <code>&lt;selector&gt;</code> 是父级的选择器。</p><p><code>:host-context()</code> 对于主题化很有用，但更好的方法是使用 <code>CSS</code> 自定义属性创建样式钩子。</p><h3 id="为分布式节点设定样式"><a href="#为分布式节点设定样式" class="headerlink" title="为分布式节点设定样式"></a>为分布式节点设定样式</h3><p><code>::slotted(&lt;compound-selector&gt;)</code> 与分布到 <code>&lt;slot&gt;</code> 中的节点匹配。</p><h3 id="从外部为组件设定样式"><a href="#从外部为组件设定样式" class="headerlink" title="从外部为组件设定样式"></a>从外部为组件设定样式</h3><p>直接使用标记名称作为选择器即可。</p><h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="创建闭合影子根（应避免）"><a href="#创建闭合影子根（应避免）" class="headerlink" title="创建闭合影子根（应避免）"></a>创建闭合影子根（应避免）</h3><p><code>shadow DOM</code> 的另一情况称为“闭合”模式。创建闭合影子树后，在 <code>JavaScript</code> 外部无法访问组件的内部 <code>DOM</code>。</p><p>创建的时候指定 <code>mode</code> 为 <code>close</code> 即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">const</span> shadowRoot = div.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">'closed'</span> &#125;) <span class="comment">// close shadow tree</span></span><br><span class="line"><span class="comment">// div.shadowRoot === null 获取不到阴影，因为是关闭的</span></span><br><span class="line"><span class="comment">// shadowRoot.host === div</span></span><br></pre></td></tr></table></figure><p>任何时候都不要使用 <code>{mode: &#39;closed&#39;}</code> 来创建网络组件，有以下几点原因：</p><ol><li>人为的安全功能。没有什么能够阻止攻击者入侵 <code>Element.prototype.attachShadow</code>。</li><li>闭合模式阻止自定义元素代码访问其自己的 <code>shadow DOM</code>。(这根本没用)</li><li>闭合模式使组件对最终用户的灵活性大为降低。</li></ol><h3 id="在-JS-中使用-slot"><a href="#在-JS-中使用-slot" class="headerlink" title="在 JS 中使用 slot"></a>在 JS 中使用 slot</h3><h4 id="slotchange-事件"><a href="#slotchange-事件" class="headerlink" title="slotchange 事件"></a>slotchange 事件</h4><p>当 <code>slot</code> 的分布式节点发生变化时，<code>slotchange</code> 事件会触发。例如，当用户从 <code>light DOM</code> 中添加/移除子项时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> slot = <span class="keyword">this</span>.shadowRoot.querySelector(<span class="string">'#slot'</span>)</span><br><span class="line">slot.addEventListener(<span class="string">'slotchange'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'light dom children changed!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>当组件的实例首次初始化时，slotchange 不触发。</p></blockquote><h4 id="哪些元素在-slot-中进行渲染"><a href="#哪些元素在-slot-中进行渲染" class="headerlink" title="哪些元素在 slot 中进行渲染"></a>哪些元素在 slot 中进行渲染</h4><p>调用 <code>slot.assignedNodes()</code> 可查看 <code>slot</code> 正在渲染哪些元素。<code>{flatten: true}</code> 选项将返回 <code>slot</code> 的备用内容（前提是没有分布任何节点）。</p><h4 id="元素分配给哪个-Slot"><a href="#元素分配给哪个-Slot" class="headerlink" title="元素分配给哪个 Slot"></a>元素分配给哪个 Slot</h4><p><code>element.assignedSlot</code> 返回元素绑定的 <code>slot</code>。</p><h3 id="Shadow-DOM-事件模型"><a href="#Shadow-DOM-事件模型" class="headerlink" title="Shadow DOM 事件模型"></a>Shadow DOM 事件模型</h3><p>当事件从 <code>shadow DOM</code> 中触发时，其目标将会调整为维持 <code>shadow DOM</code> 提供的封装。 也就是说，事件的目标重新进行了设定，因此这些事件看起来像是来自组件，而不是来自 <code>shadow DOM</code> 中的内部元素。</p><p>有些事件甚至不会从 <code>shadow DOM</code> 中传播出去。</p><p>确实会跨过影子边界的事件有：</p><ul><li>聚焦事件：<code>blur</code>、<code>focus</code>、<code>focusin</code>、<code>focusout</code></li><li>鼠标事件：<code>click</code>、<code>dblclick</code>、<code>mousedown</code>、<code>mouseenter</code>、<code>mousemove</code>，等等</li><li>滚轮事件：<code>wheel</code></li><li>输入事件：<code>beforeinput</code>、<code>input</code></li><li>键盘事件：<code>keydown</code>、<code>keyup</code></li><li>组合事件：<code>compositionstart</code>、<code>compositionupdate</code>、<code>compositionend</code></li><li>拖放事件：<code>dragstart</code>、<code>drag</code>、<code>dragend</code>、<code>drop</code>，等等</li></ul><h2 id="重置可继承样式"><a href="#重置可继承样式" class="headerlink" title="重置可继承样式"></a>重置可继承样式</h2><p>可继承样式（<code>background</code>、<code>color</code>、<code>font</code> 以及 <code>line-height</code> 等）可在 <code>shadow DOM</code> 中继续继承。也就是说，默认情况下它们会突破 <code>shadow DOM</code> 作用域限制，从自定义组件外部继承样式下来。如果想从头开始，可在它们超出影子边界时，使用 <code>all: initial;</code> 将可继承样式重置为初始值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自定义元素-Custom-Elements&quot;&gt;&lt;a href=&quot;#自定义元素-Custom-Elements&quot; class=&quot;headerlink&quot; title=&quot;自定义元素(Custom Elements)&quot;&gt;&lt;/a&gt;自定义元素(Custom Elements)&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;借助自定义元素，网络开发者可以创建新的 &lt;code&gt;HTML&lt;/code&gt; 标记、扩展现有 &lt;code&gt;HTML&lt;/code&gt; 标记，或者扩展其他开发者编写的组件。&lt;/p&gt;
&lt;h2 id=&quot;定义新元素&quot;&gt;&lt;a href=&quot;#定义新元素&quot; class=&quot;headerlink&quot; title=&quot;定义新元素&quot;&gt;&lt;/a&gt;定义新元素&lt;/h2&gt;&lt;p&gt;定义一个新元素需要使用 &lt;code&gt;customElements.define()&lt;/code&gt;：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux 命令 —— 常见任务和基本工具</title>
    <link href="http://1016990109.github.io/2018/10/29/Linux-%E5%91%BD%E4%BB%A4-%E5%B8%B8%E8%A7%81%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
    <id>http://1016990109.github.io/2018/10/29/Linux-命令-常见任务和基本工具/</id>
    <published>2018-10-29T03:13:55.000Z</published>
    <updated>2018-12-09T13:32:43.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="打包系统"><a href="#打包系统" class="headerlink" title="打包系统"></a>打包系统</h3><p>不同的 <code>Linux</code> 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： <code>Debian</code> 的”.deb”，和红帽的”.rpm”。</p><p>表格: 主要的包管理系统家族</p><table><thead><tr><th>包管理系统</th><th>发行版 (部分列表)</th></tr></thead><tbody><tr><td>Debian Style (.deb)</td><td>Debian, Ubuntu, Xandros, Linspire</td></tr><tr><td>Red Hat Style (.rpm)</td><td>Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</td></tr></tbody></table><a id="more"></a><h3 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h3><p>在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包 可能由大量程序以及支持这些程序的数据文件组成。除了安装文件之外，软件包文件也包括 关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本， 这些脚本用来在软件安装之前和之后执行配置任务。</p><p>软件包文件是由软件包维护者创建的，他通常是（但不总是）一名软件发行商的雇员。软件维护者从上游提供商（程序作者）那里得到软件源码，然后编译源码，创建软件包元数据以及所需要的 安装脚本。通常，软件包维护者要把所做的修改应用到最初的源码当中，来提高此软件与 <code>Linux</code> 发行版其它部分的融合性。</p><h3 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h3><p>虽然某些软件项目选择执行他们自己的打包和发布策略，但是现在大多数软件包是由发行商和感兴趣 的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资源库可能 包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。</p><h3 id="依赖性"><a href="#依赖性" class="headerlink" title="依赖性"></a>依赖性</h3><p>现代的软件包管理系统都提供了一些依赖项解析方法，以确保安装软件包时，其所有的依赖也被安装。</p><h3 id="上层和底层软件包工具"><a href="#上层和底层软件包工具" class="headerlink" title="上层和底层软件包工具"></a>上层和底层软件包工具</h3><p>软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件， 和上层工具，完成元数据搜索和依赖解析。</p><p>表格: 包管理工具</p><table><thead><tr><th>发行版</th><th>底层工具</th><th>上层工具</th></tr></thead><tbody><tr><td>Debian-Style</td><td>dpkg</td><td>apt-get, aptitude</td></tr><tr><td>Fedora, Red Hat, Enterprise Linux, CentOS</td><td>rpm</td><td>yum</td></tr></tbody></table><h3 id="查找资源库中的软件包"><a href="#查找资源库中的软件包" class="headerlink" title="查找资源库中的软件包"></a>查找资源库中的软件包</h3><p>表格：软件包查找工具</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get update; apt-cache search search_string</td></tr><tr><td>Red Hat</td><td>yum search search_string</td></tr></tbody></table><h3 id="从资源库中安装一个软件包"><a href="#从资源库中安装一个软件包" class="headerlink" title="从资源库中安装一个软件包"></a>从资源库中安装一个软件包</h3><p>表格: 软件包安装命令</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get update; apt-get install package_name</td></tr><tr><td>Red Hat</td><td>yum install package_name</td></tr></tbody></table><h3 id="通过软件包文件安装软件"><a href="#通过软件包文件安装软件" class="headerlink" title="通过软件包文件安装软件"></a>通过软件包文件安装软件</h3><p>有时候不是从资源库下载了一个软件安装包，这时候就需要使用底层工具来直接安装了。</p><p>表格：底层软件包安装命令</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>dpkg –install package_file</td></tr><tr><td>Red Hat</td><td>rpm -i package_file</td></tr></tbody></table><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><p>表格: 软件包删除命令</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get remove package_name</td></tr><tr><td>Red Hat</td><td>yum erase package_name</td></tr></tbody></table><h3 id="通过资源库更新软件"><a href="#通过资源库更新软件" class="headerlink" title="通过资源库更新软件"></a>通过资源库更新软件</h3><p>表格：软件包更新命令</p><table><thead><tr><th>风格</th><th>命令</th></tr></thead><tbody><tr><td>Debian</td><td>apt-get update; apt-get upgrade</td></tr><tr><td>Red Hat</td><td>yum update</td></tr></tbody></table><h2 id="存储媒介"><a href="#存储媒介" class="headerlink" title="存储媒介"></a>存储媒介</h2><h3 id="挂载和卸载存储设备"><a href="#挂载和卸载存储设备" class="headerlink" title="挂载和卸载存储设备"></a>挂载和卸载存储设备</h3><p>管理存储设备的第一步是把设备连接到文件系统树中。这个叫做”挂载”的过程允许设备连接到操作系统中。 有一个叫做 <code>/etc/fstab</code> 的文件可以列出系统启动时要挂载的设备（典型地，硬盘分区）。下面是 来自于 <code>Fedora 7</code> 系统的 <code>/etc/fstab</code> 文件实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LABEL=/12               /               ext3        defaults        1   1</span><br><span class="line">LABEL=/home             /home           ext3        defaults        1   2</span><br><span class="line">LABEL=/boot             /boot           ext3        defaults        1   2</span><br><span class="line">tmpfs                   /dev/shm        tmpfs       defaults        0   0</span><br><span class="line">devpts                  /dev/pts        devpts      gid=5,mode=620  0   0</span><br><span class="line">sysfs                   /sys            sysfs       defaults        0   0</span><br><span class="line">proc                    /proc           proc        defaults        0   0</span><br><span class="line">LABEL=SWAP-sda3         /swap           swap        defaults        0   0</span><br></pre></td></tr></table></figure><p>表格: <code>/etc/fstab</code> 字段</p><table><thead><tr><th>字段</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>设备名</td><td>传统上，这个字段包含与物理设备相关联的设备文件的实际名字，比如说 <code>/dev/hda1</code>（第一个 <code>IDE</code> 通道上第一个主设备分区）。然而今天的计算机，有很多热插拔设备（像 <code>USB</code> 驱动设备），许多现代的 <code>Linux</code> 发行版用一个文本标签和设备相关联。当这个设备连接到系统中时，这个标签（当储存媒介格式化时，这个标签会被添加到存储媒介中）会被操作系统读取。那样的话，不管赋给实际物理设备哪个设备文件，这个设备仍然能被系统正确地识别。</td></tr><tr><td>2</td><td>挂载点</td><td>设备所连接到的文件系统树的目录。</td></tr><tr><td>3</td><td>文件系统类型</td><td><code>Linux</code> 允许挂载许多文件系统类型。大多数本地的 <code>Linux</code> 文件系统是 <code>ext3</code>，但是也支持很多其它的，比方说 <code>FAT16 (msdos)</code>, <code>FAT32 (vfat)</code>，<code>NTFS (ntfs)</code>，<code>CD-ROM (iso9660)</code>，等等。</td></tr><tr><td>4</td><td>选项</td><td>文件系统可以通过各种各样的选项来挂载。有可能，例如，挂载只读的文件系统，或者挂载阻止执行任何程序的文件系统（一个有用的安全特性，避免删除媒介。）</td></tr><tr><td>5</td><td>频率</td><td>一位数字，指定是否和在什么时间用 <code>dump</code> 命令来备份一个文件系统。</td></tr><tr><td>6</td><td>次序</td><td>一位数字，指定 <code>fsck</code> 命令按照什么次序来检查文件系统。</td></tr></tbody></table><h3 id="查看挂载的文件系统列表"><a href="#查看挂载的文件系统列表" class="headerlink" title="查看挂载的文件系统列表"></a>查看挂载的文件系统列表</h3><p>使用不带参数的 <code>mount</code> 命令，会显示当前挂载的文件系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ mount</span><br><span class="line">/dev/sda2 on / <span class="built_in">type</span> ext3 (rw)</span><br></pre></td></tr></table></figure><p>这个列表的格式是：设备 <code>on</code> 挂载点 <code>type</code> 文件系统类型（选项）。例如，第一行所示设备 <code>/dev/sda2</code> 作为根文件系统被挂载，文件系统类型是 <code>ext3</code>，并且可读可写（这个“rw”选项）。</p><p>卸载只需要 <code>unmount /dev/sda2</code> 就可以了。</p><h3 id="创建新的文件系统"><a href="#创建新的文件系统" class="headerlink" title="创建新的文件系统"></a>创建新的文件系统</h3><ul><li>用 <code>fdisk</code> 命令操作分区<br>使用这个 <code>fdisk</code> 可以在设备上编辑，删除，和创建分区。(注意要先卸载)</li><li>用 <code>mkfs</code> 命令创建一个新的文件系统<br>它能创建各种格式的文件系统。 在此设备上创建一个 <code>ext3</code> 文件系统，我们使用”-t” 选项来指定这个”ext3”系统类型，随后是我们要格式化的设备分区名称。</li></ul><h2 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h2><h3 id="检查和监测网络"><a href="#检查和监测网络" class="headerlink" title="检查和监测网络"></a>检查和监测网络</h3><ol><li><code>ping</code><br>检测网络各个部件是否正常工作，<strong>大多数网络设备（包括 <code>Linux</code> 主机）都可以被配置为忽略这些数据包来避免受到 <code>IMCP</code> 攻击</strong>。</li><li><code>traceroute</code><br>这个 <code>traceroute</code> 程序（一些系统使用相似的 <code>tracepath</code> 程序来代替）会显示从本地到指定主机要经过的所有“跳数”的网络流量列表。</li><li><code>netstat</code><br><code>netstat</code> 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们可以看看网络设置中的各种特性。使用方法可以 <code>netstat --help</code> 或者 <code>man netstat</code> 查看。</li></ol><h3 id="网络中传输文件"><a href="#网络中传输文件" class="headerlink" title="网络中传输文件"></a>网络中传输文件</h3><ol><li><code>ftp</code><br><code>FTP</code>（它的原始形式）并不是安全的，因为它会以明码形式发送帐号的姓名和密码。这就意味着这些数据没有加密，任何嗅探网络的人都能看到。由于此种原因，几乎因特网中所有 <code>FTP</code> 服务器 都是匿名的。一个匿名服务器能允许任何人使用注册名“anonymous”和无意义的密码登录系统。<br>在 “ftp&gt;” 提示符下，输入 “help”，会显示所支持命令的列表。</li><li><code>wget</code><br>若想从网络和 <code>FTP</code> 网站两者上都能下载数据，<code>wget</code> 是很有用处的。不只能下载单个文件，多个文件，甚至整个网站都能下载。</li></ol><h3 id="与远程主机安全通信"><a href="#与远程主机安全通信" class="headerlink" title="与远程主机安全通信"></a>与远程主机安全通信</h3><ol><li><code>ssh</code><br><code>SSH</code>（Secure Shell）。首先，它要认证远端主机是否为它所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间所有的通讯信息。通过远程与本地建立的一个 <code>VPN</code> 可以实现：在运行着 X 服务端的系统（也就是，能显示 <code>GUI</code> 的机器）上，能登录远端系统并运行一个 X 客户端程序（一个图形化应用），而应用程序的显示结果出现在本地。</li><li><code>scp</code> 和 <code>sftp</code><br>它们可以利用 <code>SSH</code> 加密通道在网络间复制文件。第一个，<code>scp</code>（安全复制）被用来复制文件，与熟悉的 <code>cp</code> 程序非常相似。最显著的区别就是源或者目标路径名要以远端主机的名字，后跟一个冒号字符开头。例如：<code>scp remote-sys:document.txt .</code>。第二个 <code>SSH</code> 文件复制程序是 <code>sftp</code>，顾名思义，它是 <code>ftp</code> 程序的安全替代品。<code>sftp</code> 工作起来与我们之前使用的 <code>ftp</code> 程序很相似；然而，它不用明码形式来传递数据，它使用加密的 <code>SSH</code> 通道。<code>sftp</code> 有一个重要特性强于传统的 <code>ftp</code> 命令，就是 <code>sftp</code> 不需要远端系统中运行 <code>FTP</code> 服务端。它仅仅需要 <code>SSH</code> 服务端。<strong>这意味着任何一台能用 <code>SSH</code> 客户端连接的远端机器，也可当作类似于 <code>FTP</code> 的服务器来使用。</strong></li></ol><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>能基于各种各样的属性搜索一个给定目录（以及它的子目录），来查找文件。</p><p>最简单的就是接收一个或多个目录名来执行搜索搜索，可以递归输出目录的结构。</p><p><code>-type</code> 指定搜索的类型，有以下几种：<code>b</code> 块特殊设备文件，<code>c</code> 字符特殊设备文件，<code>d</code> 目录，<code>f</code> 普通文件，<code>l</code> 符号链接。其他测试条件：</p><table><thead><tr><th>测试条件</th><th>描述</th></tr></thead><tbody><tr><td>-cmin n</td><td>匹配内容或属性最后修改时间正好在 n 分钟之前的文件或目录。 指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。</td></tr><tr><td>-cnewer file</td><td>匹配内容或属性最后修改时间晚于 file 的文件或目录。</td></tr><tr><td>-ctime n</td><td>匹配内容和属性最后修改时间在 n*24 小时之前的文件和目录</td></tr><tr><td>-empty</td><td>匹配空文件和目录。</td></tr><tr><td>-group name</td><td>匹配属于一个组的文件或目录。组可以用组名或组 ID 来表示。</td></tr><tr><td>-iname pattern</td><td>就像-name 测试条件，但是不区分大小写。</td></tr><tr><td>-inum n</td><td>匹配 inode 号是 n 的文件。这对于找到某个特殊 inode 的所有硬链接很有帮助。</td></tr><tr><td>-mmin n</td><td>匹配内容被修改于 n 分钟之前的文件或目录。</td></tr><tr><td>-mtime n</td><td>匹配的文件或目录的内容被修改于 n*24 小时之前。</td></tr><tr><td>-name pattern</td><td>用指定的通配符模式匹配的文件和目录。</td></tr><tr><td>-newer file</td><td>匹配内容晚于指定的文件的文件和目录。这在编写执行备份的 <code>shell</code> 脚本的时候很有帮。每次你制作一个备份，更新文件（比如说日志），然后使用 <code>find</code> 命令来判断哪些文件自从上一次更新之后被更改了。</td></tr><tr><td>-nouser</td><td>匹配不属于一个有效用户的文件和目录。这可以用来查找 属于被删除的帐户的文件或监测攻击行为。</td></tr><tr><td>-nogroup</td><td>匹配不属于一个有效的组的文件和目录。</td></tr><tr><td>-perm mode</td><td>匹配权限已经设置为指定的 mode 的文件或目录。mode 可以用 八进制或符号表示法。</td></tr><tr><td>-samefile name</td><td>类似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。</td></tr><tr><td>-size n</td><td>匹配大小为 n 的文件</td></tr><tr><td>-type c</td><td>匹配文件类型是 c 的文件。</td></tr><tr><td>-user name</td><td>匹配属于某个用户的文件或目录。这个用户可以通过用户名或用户 ID 来表示。</td></tr></tbody></table><p>即使拥有了 <code>find</code> 命令提供的所有测试条件，我们还需要一个更好的方式来描述测试条件之间的逻辑关系。<code>find</code> 命令提供了 一种方法来结合测试条件，通过使用逻辑操作符来创建更复杂的逻辑关系。例如：<code>find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)</code> 表示查找当前用户目录下权限不是 <code>0600</code> 的文件和全新啊不是 <code>0700</code> 的文件夹。更多操作符：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>-and</td><td>如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。 注意若没有使用操作符，则默认使用 -and。</td></tr><tr><td>-or</td><td>若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。</td></tr><tr><td>-not</td><td>若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号（!）。</td></tr><tr><td>()</td><td>把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。 默认情况下，<code>find</code> 命令按照从左到右的顺序计算。经常有必要重写默认的求值顺序，以得到期望的结果。 即使没有必要，有时候包括组合起来的字符，对提高命令的可读性是很有帮助的。注意 因为圆括号字符对于 <code>shell</code> 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 <code>find</code> 命令。通常反斜杠字符被用来转义圆括号字符。</td></tr></tbody></table><p><code>find</code> 命令允许基于搜索结果来执行操作。有许多预定义的操作和几种方式来应用用户定义的操作。</p><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>-delete</td><td>删除当前匹配的文件。</td></tr><tr><td>-ls</td><td>对匹配的文件执行等同的 <code>ls -dils</code> 命令。并将结果发送到标准输出。</td></tr><tr><td>-print</td><td>把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。</td></tr><tr><td>-quit</td><td>一旦找到一个匹配，退出。</td></tr></tbody></table><p>例如：<code>find ~ -type f -name &#39;*.BAK&#39; -delete</code> 代表在用户目录下递归找到文件名以 <code>.BAK</code> 结尾的文件，并删除。</p><p>当然除了上面 4 个操作外，还可以执行任何用户自定义的命令，只要使用 <code>-exec</code> 来连接就好了，<code>-ok</code> 和 <code>-exec</code> 类似，只不过多了提升用户的信息：</p><p><code>find ~ -type f -name &#39;foo*&#39; -ok ls -l &#39;{}&#39; &#39;;&#39;</code> 代表在用户目录下查找名字以 <code>foo</code> 开头的文件，并提示用户是否对匹配的文件执行 <code>ls -l</code> 命令。</p><blockquote><p>当 <code>-exec</code> 行为被使用的时候，若每次找到一个匹配的文件，它会启动一个新的指定命令的实例。我们可能更愿意把所有的搜索结果结合起来，再运行一个命令的实例。例如，与其像这样执行命令：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l file1</span><br><span class="line">ls -l file2</span><br></pre></td></tr></table></figure><blockquote><p>我们更喜欢：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l file1 file2</span><br></pre></td></tr></table></figure><blockquote><p>通过把末尾的分号改为加号，就激活了 <code>find</code> 命令的一个功能，把搜索结果结合为一个参数列表，然后用于所期望的命令的一次执行。<br><code>find ~ -type f -name &#39;foo*&#39; -exec ls -l &#39;{}&#39; +</code> 这样系统只用执行一次 <code>ls</code> 命令。</p></blockquote><h2 id="归档和备份"><a href="#归档和备份" class="headerlink" title="归档和备份"></a>归档和备份</h2><h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p>压缩算法（数学技巧被用来执行压缩任务）分为两大类，无损压缩和有损压缩。无损压缩保留了原始文件的所有数据。有损压缩的例子有 <code>JPEG</code>（图像）文件和 <code>MP3</code>（音频）文件。</p><h4 id="gzip-无损"><a href="#gzip-无损" class="headerlink" title="gzip(无损)"></a>gzip(无损)</h4><p>这个 <code>gzip</code> 程序被用来压缩一个或多个文件。当执行 <code>gzip</code> 命令时，则原始文件的压缩版会替代原始文件。相对应的 <code>gunzip</code> 程序被用来把压缩文件复原为没有被压缩的版本。</p><p><code>gzip</code> 命令有许多选项：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>把输出写入到标准输出，并且保留原始文件。也有可能用–stdout 和–to-stdout 选项来指定。</td></tr><tr><td>-d</td><td>解压缩。正如 gunzip 命令一样。也可以用–decompress 或者–uncompress 选项来指定.</td></tr><tr><td>-f</td><td>强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用–force 选项来指定。</td></tr><tr><td>-h</td><td>显示用法信息。也可用–help 选项来指定。</td></tr><tr><td>-l</td><td>列出每个被压缩文件的压缩数据。也可用–list 选项。</td></tr><tr><td>-r</td><td>若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用–recursive 选项来指定。</td></tr><tr><td>-t</td><td>测试压缩文件的完整性。也可用–test 选项来指定。</td></tr><tr><td>-v</td><td>显示压缩过程中的信息。也可用–verbose 选项来指定。</td></tr><tr><td>-number</td><td>设置压缩指数。number 是一个在 1（最快，最小压缩）到 9（最慢，最大压缩）之间的整数。 数值 1 和 9 也可以各自用–fast 和–best 选项来表示。默认值是整数 6。</td></tr></tbody></table><h4 id="bzip2-无损"><a href="#bzip2-无损" class="headerlink" title="bzip2(无损)"></a>bzip2(无损)</h4><p>与 <code>gzip</code> 程序相似，但是使用了不同的压缩算法，舍弃了压缩速度，而实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 <code>gzip</code>。由 <code>bzip2</code> 压缩的文件，用扩展名 <code>.bz2</code> 来表示。<code>gzip</code> 程序的所有选项（除了 <code>-r</code>），<code>bzip2</code> 程序同样也支持。注意，然而，压缩级别选项（<code>-number</code>）对于 <code>bzip2</code> 程序来说，有少许不同的含义。</p><blockquote><p>不要强制压缩。如果你再次压缩已经压缩过的文件，实际上你会得到一个更大的文件。这是因为所有的压缩技术都会涉及一些开销，文件中会被添加描述此次压缩过程的信息。如果你试图压缩一个已经不包含多余信息的文件，那么再次压缩不会节省空间，以抵消额外的花费。</p></blockquote><h3 id="归档文件"><a href="#归档文件" class="headerlink" title="归档文件"></a>归档文件</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar mode[options] pathname...</span><br></pre></td></tr></table></figure><p>这里的 <code>mode</code> 是指以下操作模式（这里只展示了一部分，查看 <code>tar</code> 的手册(<code>man tar</code>)来得到完整列表）之一：</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>c</td><td>为文件和／或目录列表创建归档文件。</td></tr><tr><td>x</td><td>抽取归档文件。</td></tr><tr><td>r</td><td>追加具体的路径到归档文件的末尾。</td></tr><tr><td>t</td><td>列出归档文件的内容。</td></tr></tbody></table><p><code>tar</code> 命令另一个有趣的行为是它处理归档文件路径名的方式。默认情况下，路径名是相对的，而不是绝对路径。当以相对路径创建归档文件的时候，<code>tar</code> 命令会简单地删除路径名开头的斜杠。这就意味着到时候解压出来是在运行命令的目录下解压出相对目录结构，例如：<code>tar cf playground.tar playground</code> 打的压缩包解压出来还是只有 <code>playground</code> 的目录，而 <code>tar cf playground2.tar ~/playground</code> 打的压缩包解压出来会包含 <code>/home/user/playground</code> 的父级目录，故而一般绝对路径可以完整复原压缩前的目录结构（<strong>要求解压命令在根目录执行</strong>）。</p><p>当抽取一个归档文件时，有可能限制从归档文件中抽取什么内容。例如，如果我们想要抽取单个文件，可以这样实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf archive.tar pathname</span><br></pre></td></tr></table></figure><p><code>tar</code> 命令经常结合 <code>find</code> 命令一起来制作归档文件。在这个例子里，我们将会使用 <code>find</code> 命令来产生一个文件集合，然后这些文件被包含到归档文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find playground -name <span class="string">'file-A'</span> -<span class="built_in">exec</span> tar rf playground.tar <span class="string">'&#123;&#125;'</span> <span class="string">'+'</span></span><br></pre></td></tr></table></figure><p>这里我们使用 <code>find</code> 命令来匹配 <code>playground</code> 目录中所有名为 <code>file-A</code> 的文件，然后使用 <code>-exec</code> 行为，来唤醒带有追加模式（<code>r</code>）的 <code>tar</code> 命令，把匹配的文件添加到归档文件 <code>playground.tar</code> 里面。</p><p><code>tar</code> 还可以和标准输入输出连接，使用“-”来表示 标准输入／输出的惯例，也被大量的其它程序使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find playground -name <span class="string">'file-A'</span> | tar cf - --files-from=- | gzip &gt; playground.tgz</span><br></pre></td></tr></table></figure><p>上面的命令以为这从 <code>playground</code> 文件夹中找到文件名为 <code>file-A</code> 的文件，并将结果输出标准输出，接着 <code>tar</code> 命令利用 <code>--files-from=-</code> 从标准输入读取要归档的文件进行归档，最后连接到 <code>gzip</code> 进行打包，结果输出到文件 <code>playground.tgz</code>。</p><blockquote><p>虽然我们使用 <code>gzip</code> 程序来制作我们的压缩归档文件，但是现在的 <code>GUN</code> 版本的 <code>tar</code> 命令，<code>gzip</code> 和 <code>bzip2</code> 压缩两者都直接支持，各自使用 <code>z</code> 和 <code>j</code> 选项。</p></blockquote><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>这个 <code>zip</code> 程序既是压缩工具，也是一个打包工具。这程序使用的文件格式，<code>Windows</code> 用户比较熟悉，因为它读取和写入 <code>.zip</code> 文件。然而，在 <code>Linux</code> 中 <code>gzip</code> 是主要的压缩程序，而 <code>bzip2</code> 则位居第二。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip options zipfile file...</span><br></pre></td></tr></table></figure><p>除非包含 <code>-r</code> 选项，要不然只有目录（<strong>没有任何它的内容</strong>）被存储。(<code>zip -r test.zip home/user/test</code>)</p><p>在创建 <code>zip</code> 版本的文件包时，<code>zip</code> 命令通常会显示一系列的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adding: github/<span class="built_in">test</span>/<span class="built_in">source</span>/src/node/express.js (deflated 57%)</span><br><span class="line">adding: github/<span class="built_in">test</span>/<span class="built_in">source</span>/src/node/mysql.js (deflated 55%)</span><br><span class="line">adding: github/<span class="built_in">test</span>/<span class="built_in">source</span>/src/node/callback/ (stored 0%)</span><br></pre></td></tr></table></figure><p>这些信息显示了添加到文件包中每个文件的状态。<code>zip</code> 命令会使用两种存储方法之一，来添加文件到文件包中：要不它会“store”没有压缩的文件，正如这里所示，或者它会“deflate”文件，执行压缩操作。在存储方法之后显示的数值表明了压缩量。</p><p>对于 <code>zip</code> 命令（与 <code>tar</code> 命令相反）要注意一点，就是如果指定了一个已经存在的文件包，其被更新而不是被替代。</p><p>像 <code>tar</code> 命令一样，<code>zip</code> 命令能够利用标准输入和输出，虽然它的实施不大有用。通过 <code>-@</code> 选项，有可能把一系列的文件名管道到 <code>zip</code> 命令。<code>find playground -name &quot;file-A&quot; | zip -@ file-A.zip</code></p><h3 id="同步文件和目录"><a href="#同步文件和目录" class="headerlink" title="同步文件和目录"></a>同步文件和目录</h3><p><code>rsync</code> 这个程序能同步本地与远端的目录，通过使用 <code>rsync</code> 远端更新协议，此协议允许 <code>rsync</code> 快速地检测两个目录的差异，执行最小量的复制来达到目录间的同步。比起其它种类的复制程序，这就使 <code>rsync</code> 命令非常快速和高效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync options <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure><p>这里 <code>source</code> 和 <code>destination</code> 是下列选项之一：</p><ul><li>一个本地文件或目录</li><li>一个远端文件或目录，以 <code>[user@]host:path</code> 的形式存在</li><li>一个远端 <code>rsync</code> 服务器，由 <code>rsync://[user@]host[:port]/path</code> 指定</li></ul><p><code>rsync</code> 也可以作为本地一个守护进程启动，然后监听网络上的 <code>rsync</code> 请求来同步目录。可以支持 <code>ssh</code> 和 <code>rsycn</code> 协议。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>“grep”这个名字 来自于短语“global regular expression print”，所以 <code>grep</code> 程序与正则表达式有着千丝万缕的联系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] regex [file...]</span><br></pre></td></tr></table></figure><p>表格: grep 选项</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-i</td><td>忽略大小写。不会区分大小写字符。也可用–ignore-case 来指定。</td></tr><tr><td>-v</td><td>不匹配。通常，grep 程序会打印包含匹配项的文本行。这个选项导致 grep 程序只会打印不包含匹配项的文本行。也可用–invert-match 来指定。</td></tr><tr><td>-c</td><td>打印匹配的数量（或者是不匹配的数目，若指定了-v 选项），而不是文本行本身。 也可用–count 选项来指定。</td></tr><tr><td>-l</td><td>打印包含匹配项的文件名，而不是文本行本身，也可用–files-with-matches 选项来指定。</td></tr><tr><td>-L</td><td>相似于-l 选项，但是只是打印不包含匹配项的文件名。也可用–files-without-match 来指定。</td></tr><tr><td>-n</td><td>在每个匹配行之前打印出其位于文件中的相应行号。也可用–line-number 选项来指定。</td></tr><tr><td>-h</td><td>应用于多文件搜索，不输出文件名。也可用–no-filename 选项来指定。</td></tr></tbody></table><h3 id="元字符和原义字符-Metacharacters-And-Literals"><a href="#元字符和原义字符-Metacharacters-And-Literals" class="headerlink" title="元字符和原义字符(Metacharacters And Literals)"></a>元字符和原义字符(Metacharacters And Literals)</h3><p>像 <code>grep -L bzip dirlist*.txt</code> 中的 <code>bzip</code> 每一个字符都是原义字符，因此它们匹配本身。除了原义字符之外，正则表达式也可能包含元字符，其被用来指定更复杂的匹配项。正则表达式元字符由以下字符组成(反斜杠可以将元字符转化为原义字符)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ $ . [ ] &#123; &#125; - ? * + ( ) | \</span><br></pre></td></tr></table></figure><h3 id="POSIX-字符集"><a href="#POSIX-字符集" class="headerlink" title="POSIX 字符集"></a>POSIX 字符集</h3><p>表格: POSIX 字符集</p><table><thead><tr><th>字符集</th><th>说明</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>字母数字字符。在 ASCII 中，等价于：[A-Za-z0-9]</td></tr><tr><td>[:word:]</td><td>与[:alnum:]相同, 但增加了下划线字符。</td></tr><tr><td>[:alpha:]</td><td>字母字符。在 ASCII 中，等价于：[A-Za-z]</td></tr><tr><td>[:blank:]</td><td>包含空格和 tab 字符。</td></tr><tr><td>[:cntrl:]</td><td>ASCII 的控制码。包含了 0 到 31，和 127 的 ASCII 字符。</td></tr><tr><td>[:digit:]</td><td>数字 0 到 9</td></tr><tr><td>[:graph:]</td><td>可视字符。在 ASCII 中，它包含 33 到 126 的字符。</td></tr><tr><td>[:lower:]</td><td>小写字母。</td></tr><tr><td>[:punct:]</td><td>标点符号字符。在 ASCII 中，等价于：[-!”#\$%&amp;’()*+,./:;&lt;=&gt;?@[\]_`{</td><td>}~]</td></tr><tr><td>[:print:]</td><td>可打印的字符。在[:graph:]中的所有字符，再加上空格字符。</td></tr><tr><td>[:space:]</td><td>空白字符，包括空格、tab、回车、换行、vertical tab 和 form feed.在 ASCII 中， 等价于：[ \t\r\n\v\f]</td></tr><tr><td>[:upper:]</td><td>大写字母。</td></tr><tr><td>[:xdigit:]</td><td>用来表示十六进制数字的字符。在 ASCII 中，等价于：[0-9A-Fa-f]</td></tr></tbody></table><p><code>POSIX</code> 把正则表达式的实现分成了两类：基本正则表达式（BRE）和扩展的正则表达式（ERE）。</p><p><code>BRE</code> 可以辨别以下元字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ $ . [ ] *</span><br></pre></td></tr></table></figure><p><code>ERE</code> 添加了以下元字符（以及与其相关的功能）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( ) &#123; &#125; ? + |</span><br></pre></td></tr></table></figure><p>我们熟知的 <code>grep</code> 就同时支持这两种，通过 <code>-E</code> 来启用 <code>ERE</code>:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本正则表达式，| 被看做字符</span></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">"BBB"</span> | grep <span class="string">'AAA|BBB'</span></span><br><span class="line"></span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">"BBB"</span> | grep -E <span class="string">'AAA|BBB'</span></span><br><span class="line">BBB</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他正则表达式可查看 <a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">表达式全集</a></p><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p><code>cat</code> 程序具有许多有趣的选项。其中许多选项用来帮助更好的可视化文本内容。一个例子是 <code>-A</code> 选项，其用来在文本中显示非打印字符(比如 <code>tab</code> 字符和回车字符)。</p><p><code>cat</code> 程序也包含用来修改文本的选项。最著名的两个选项是 <code>-n</code>，其给文本行添加行号和 <code>-s</code>，禁止输出多个空白行。</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><code>sort</code> 程序可以对对标准输入的内容，或命令行中指定的一个或多个文件进行排序，然后把排序结果发送到标准输出。</p><p>表格: 常见的 <code>sort</code> 程序选项</p><table><thead><tr><th>选项</th><th>长选项</th><th>描述</th></tr></thead><tbody><tr><td>-b</td><td>–ignore-leading-blanks</td><td>默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 <code>sort</code> 程序忽略 每行开头的空格，从第一个非空白字符开始排序。</td></tr><tr><td>-f</td><td>–ignore-case</td><td>让排序不区分大小写。</td></tr><tr><td>-n</td><td>–numeric-sort</td><td>基于字符串的数值来排序。使用此选项允许根据数字值执行排序，而不是字母值。<strong>如果一个字段由数字和字母组成，那么只会对前面的数字排序，忽略后续的所有字符，当数字部分相同时才将后面剩余的字符串按字母顺序排列</strong>，如 <code>1n3</code> 会忽略 <code>n3</code>。</td></tr><tr><td>-r</td><td>–reverse</td><td>按相反顺序排序。结果按照降序排列，而不是升序。</td></tr><tr><td>-k</td><td>–key=field1[,field2]</td><td>对从 field1 到 field2 之间的字符排序，而不是整个文本行。看下面的讨论。</td></tr><tr><td>-m</td><td>–merge</td><td>把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。</td></tr><tr><td>-o</td><td>–output=file</td><td>把排好序的输出结果发送到文件，而不是标准输出。</td></tr><tr><td>-t</td><td>–field-separator=char</td><td>定义域分隔字符。默认情况下，域由空格或制表符分隔。</td></tr></tbody></table><p>如果要对日期排序，在计算机中，日期通常设置为 <code>YYYY-MM-DD</code> 格式，这样使按时间顺序排序变得容易，但是如果日期为美国格式 <code>MM/DD/YYYY</code>，排序就更加困难了。幸运地是，<code>sort</code> 程序提供了一种方式。这个 <code>key</code> 选项允许在字段中指定偏移量，所以我们能在字段中定义键值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt</span><br><span class="line">Fedora         10    11/25/2008</span><br><span class="line">Ubuntu         8.10  10/30/2008</span><br><span class="line">SUSE           11.0  06/19/2008</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过指定 -k 3.7，我们指示 sort 程序使用一个排序键值，其始于第三个字段中的第七个字符，对应于 年的开头。同样地，我们指定 -k 3.1 和 -k 3.4 来分离日期中的月和日。 我们也添加了 n 和 r 选项来实现一个逆向的数值排序。这个 b 选项用来删除日期字段中开头的空格（ 行与行之间的空格数迥异，因此会影响 sort 程序的输出结果）。</p><h3 id="uniq-默认删除相邻的重复行"><a href="#uniq-默认删除相邻的重复行" class="headerlink" title="uniq(默认删除相邻的重复行)"></a>uniq(默认删除相邻的重复行)</h3><p>与 <code>sort</code> 程序相比，这个 <code>uniq</code> 程序是个轻量级程序。<code>uniq</code> 执行一个看似琐碎的行为。当给定一个排好序的文件（包括标准输出），<code>uniq</code> 会删除任意重复行，并且把结果发送到标准输出。它常常和 <code>sort</code> 程序一块使用，来清理重复的输出。</p><p>表格: 常用的 <code>uniq</code> 选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>输出所有的重复行，并且每行开头显示重复的次数。</td></tr><tr><td>-d</td><td>只输出重复行，而不是特有的文本行。</td></tr><tr><td>-f</td><td>n 忽略每行开头的 n 个字段，字段之间由空格分隔，正如 <code>sort</code> 程序中的空格分隔符；然而，不同于 <code>sort</code> 程序，<code>uniq</code> 没有选项来设置备用的字段分隔符。</td></tr><tr><td>-i</td><td>在比较文本行的时候忽略大小写。</td></tr><tr><td>-s</td><td>n 跳过（忽略）每行开头的 n 个字符。</td></tr><tr><td>-u</td><td>只输出独有的文本行。这是默认的。</td></tr></tbody></table><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>表格: <code>cut</code> 程序选择项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c char_list</td><td>从文本行中抽取由 char_list 定义的文本。这个列表可能由一个或多个逗号分隔开的数值区间组成(<code>1,3</code> 或 <code>1-3,5-6</code> 都是合法的)。</td></tr><tr><td>-f field_list</td><td>从文本行中抽取一个或多个由 field_list 定义的字段。这个列表可能 包括一个或多个字段，或由逗号分隔开的字段区间。</td></tr><tr><td>-d delim_char</td><td>当指定-f 选项之后，使用 delim_char 做为字段分隔符。默认情况下， 字段之间必须由单个 tab 字符分隔开。</td></tr><tr><td>–complement</td><td>抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。</td></tr></tbody></table><h3 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h3><p>这个 <code>paste</code> 命令的功能正好与 <code>cut</code> 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。类似于 <code>cut</code> 命令，<code>paste</code> 接受多个文件参数和 <code>／</code> 或标准输入。例如将 <code>A</code> 文件的每一行的 3 个字段(<code>A1 A2 A3</code>)与 <code>B</code> 文件的每一行 2 个字段(<code>B1 B2</code>)合并并输出到标准输出流(<code>A1 A2 A3 B1 B2</code>)，命令为 <code>paste A B</code>。</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>类似关系型数据库的 <code>join</code> 操作，找到两个或多个文件中相同的字段，然后进行合并。</p><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><p>这个 <code>comm</code> 程序会比较两个文本文件，并且会显示每个文件特有的文本行和共有的文本行。</p><p><code>comm</code> 命令产生了三列输出。第一列包含第一个文件独有的文本行；第二列，文本行是第二列独有的；第三列包含两个文件共有的文本行。<code>comm</code> 支持 <code>-n</code> 形式的选项，这里 <code>n</code> 代表 1，2 或 3。这些选项使用的时候，指定了要<strong>隐藏</strong>的列。</p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>类似于 <code>comm</code> 程序，<code>diff</code> 程序被用来监测文件之间的差异。然而，<code>diff</code> 是一款更加复杂的工具，它支持许多输出格式，并且一次能处理许多文本文件。软件开发员经常使用 <code>diff</code> 程序来检查不同程序源码版本之间的更改，<code>diff</code> 能够递归地检查源码目录，经常称之为源码树。</p><p>和 <code>git diff</code> 有点类似。</p><p>表格: <code>diff</code> 更改命令</p><table><thead><tr><th>改变</th><th>说明</th></tr></thead><tbody><tr><td>r1ar2</td><td>把第二个文件中位置 r2 处的文件行添加到第一个文件中的 r1 处。</td></tr><tr><td>r1cr2</td><td>用第二个文件中位置 r2 处的文本行更改（替代）位置 r1 处的文本行。</td></tr><tr><td>r1dr2</td><td>删除第一个文件中位置 r1 处的文本行，这些文本行将会出现在第二个文件中位置 r2 处。</td></tr></tbody></table><p>表格：<code>diff -c</code></p><table><thead><tr><th>指示符</th><th>意思</th></tr></thead><tbody><tr><td>blank</td><td>上下文显示行。它并不表示两个文件之间的差异。</td></tr><tr><td>-</td><td>删除行。这一行将会出现在第一个文件中，而不是第二个文件内。</td></tr><tr><td>+</td><td>添加行。这一行将会出现在第二个文件内，而不是第一个文件中。</td></tr><tr><td>!</td><td>更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。</td></tr></tbody></table><p>表格：<code>diff -u</code></p><table><thead><tr><th>字符</th><th>意思</th></tr></thead><tbody><tr><td>空格</td><td>两个文件都包含这一行。</td></tr><tr><td>-</td><td>在第一个文件中删除这一行。</td></tr><tr><td>+</td><td>添加这一行到第一个文件中。</td></tr></tbody></table><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>这个 <code>patch</code> 程序被用来把更改应用到文本文件中。它接受从 <code>diff</code> 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff -Naur old_file new_file &gt; diff_file</span><br><span class="line">patch &lt; diff_file</span><br></pre></td></tr></table></figure><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>这个 <code>tr</code> 程序被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。如 <code>echo &quot;lowercase letters&quot; | tr a-z A-Z</code> 输出 <code>LOWERCASE LETTERS</code>。</p><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>名字 <code>sed</code> 是 <code>stream editor</code>（流编辑器）的简称。它对文本流，即一系列指定的文件或标准输入进行编辑。<code>sed</code> 是一款强大的，并且有些复杂的程序（有整本内容都是关于 <code>sed</code> 程序的书籍），这里只简单介绍。</p><p>表格: <code>sed</code> 地址表示法</p><table><thead><tr><th>地址</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>行号，n 是一个正整数。</td></tr><tr><td>\$</td><td>最后一行。</td></tr><tr><td>/regexp/</td><td>所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过 斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc 来 指定表达式，这里 c 就是一个备用的字符。</td></tr><tr><td>addr1,addr2</td><td>从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意 单独的地址形式。</td></tr><tr><td>first~step</td><td>匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。例如 1~2 是指每个位于偶数行号的文本行，5~5 则指第五行和之后每五行位置的文本行。</td></tr><tr><td>addr1,+n</td><td>匹配地址 addr1 和随后的 n 个文本行。</td></tr><tr><td>addr!</td><td>匹配所有的文本行，除了 addr 之外，addr 可能是上述任意的地址形式。</td></tr></tbody></table><p>表格: <code>sed</code> 基本编辑命令</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>输出当前的行号。</td></tr><tr><td>a</td><td>在当前行之后追加文本。</td></tr><tr><td>d</td><td>删除当前行。</td></tr><tr><td>i</td><td>在当前行之前插入文本。</td></tr><tr><td>p</td><td>打印当前行。默认情况下，sed 程序打印每一行，并且只是编辑文件中匹配 指定地址的文本行。通过指定-n 选项，这个默认的行为能够被忽略。</td></tr><tr><td>q</td><td>退出 sed，不再处理更多的文本行。如果不指定-n 选项，输出当前行。</td></tr><tr><td>Q</td><td>退出 sed，不再处理更多的文本行。</td></tr><tr><td>s/regexp/replacement/</td><td>只要找到一个 regexp 匹配项，就替换为 replacement 的内容。 replacement 可能包括特殊字符 &amp;，其等价于由 regexp 匹配的文本。另外， replacement 可能包含序列 \1 到 \9，其是 regexp 中相对应的子表达式的内容。更多信息，查看 下面 back references 部分的讨论。在 replacement 末尾的斜杠之后，可以指定一个 可选的标志，来修改 s 命令的行为。</td></tr><tr><td>y/</td><td>set1/set2 执行字符转写操作，通过把 set1 中的字符转变为相对应的 set2 中的字符。 注意不同于 tr 程序，sed 要求两个字符集合具有相同的长度。</td></tr></tbody></table><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><h3 id="nl-添加行号"><a href="#nl-添加行号" class="headerlink" title="nl-添加行号"></a>nl-添加行号</h3><p>表格: 常用 <code>nl</code> 选项</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b style</td><td>把 body 按被要求方式数行，可以是以下方式： a = 数所有行; t = 数非空行。这是默认设置;n = 无;pregexp = 只数那些匹配了正则表达式的行</td><td></td></tr><tr><td>-f style</td><td>将 footer 按被要求设置数。默认是无</td></tr><tr><td>-h style</td><td>将 header 按被要求设置数。默认是</td></tr><tr><td>-i number</td><td>将页面增加量设置为数字。默认是一。</td></tr><tr><td>-n format</td><td>设置数数的格式，格式可以是：ln = 左偏，没有前导零;rn = 右偏，没有前导零;rz = 右偏，有前导零。</td></tr><tr><td>-p</td><td>不要在没一个逻辑页面的开始重设页面数。</td></tr><tr><td>-s string</td><td>在没一个行的末尾加字符作分割符号。默认是单个的 tab。</td></tr><tr><td>-v number</td><td>将每一个逻辑页面的第一行设置成数字。默认是一。</td></tr><tr><td>-w width</td><td>将行数的宽度设置，默认是六。</td></tr></tbody></table><h3 id="fold-限制文件行宽"><a href="#fold-限制文件行宽" class="headerlink" title="fold - 限制文件行宽"></a>fold - 限制文件行宽</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="string">"The quick brown fox jumped over the lazy dog."</span> | fold -w 12 -s</span><br><span class="line">The quick</span><br><span class="line">brown fox</span><br><span class="line">jumped over</span><br><span class="line">the lazy</span><br><span class="line">dog.</span><br></pre></td></tr></table></figure><h3 id="fmt-一个简单的文本格式器"><a href="#fmt-一个简单的文本格式器" class="headerlink" title="fmt - 一个简单的文本格式器"></a>fmt - 一个简单的文本格式器</h3><p><code>fmt</code> 程序同样折叠文本，外加很多功能。它接受文本或标准输入并且在文本流上呈现照片转换。它主要是填充和连接文本行，同时保留空白符和缩进。</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>表格: <code>printf</code> 转换规范组件</p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>d</td><td>将数字格式化为带符号的十进制整数</td></tr><tr><td>f</td><td>格式化并输出浮点数</td></tr><tr><td>o</td><td>将整数格式化为八进制数</td></tr><tr><td>s</td><td>将字符串格式化</td></tr><tr><td>x</td><td>将整数格式化为十六进制数，必要时使用小写 a-f</td></tr><tr><td>X</td><td>与 x 相同，但变为大写</td></tr><tr><td>%</td><td>打印 % 符号 (比如，指定 “%%”)</td></tr></tbody></table><p><code>printf</code> 转换规范组件:</p><ol><li><code>flags</code><br>有 5 种不同的标志:<br><code>#</code>: 使用“备用格式”输出。这取决于数据类型。对于 o（八进制数）转换，输出以 0 为前缀.对于 x 和 X（十六进制数）转换，输出分别以 0x 或 0X 为前缀。0–(零) 用零填充输出。这意味着该字段将填充前导零，比如“000380”。<br><code>-</code>: (破折号) 左对齐输出。默认情况下，<code>printf</code> 右对齐输出。<br><code>&#39; &#39;</code>: (空格) 在正数前空一格。<br><code>+</code>: (加号) 在正数前添加加号。默认情况下，<code>printf</code> 只在负数前添加符号。</li><li><code>width</code> 指定最小字段宽度的数。</li><li><code>.precision</code> 对于浮点数，指定小数点后的精度位数。对于字符串转换，指定要输出的字符数。</li></ol><h2 id="打印和编译请查看源书"><a href="#打印和编译请查看源书" class="headerlink" title="打印和编译请查看源书"></a>打印和编译请查看源书</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;软件包管理&quot;&gt;&lt;a href=&quot;#软件包管理&quot; class=&quot;headerlink&quot; title=&quot;软件包管理&quot;&gt;&lt;/a&gt;软件包管理&lt;/h2&gt;&lt;h3 id=&quot;打包系统&quot;&gt;&lt;a href=&quot;#打包系统&quot; class=&quot;headerlink&quot; title=&quot;打包系统&quot;&gt;&lt;/a&gt;打包系统&lt;/h3&gt;&lt;p&gt;不同的 &lt;code&gt;Linux&lt;/code&gt; 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： &lt;code&gt;Debian&lt;/code&gt; 的”.deb”，和红帽的”.rpm”。&lt;/p&gt;
&lt;p&gt;表格: 主要的包管理系统家族&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;包管理系统&lt;/th&gt;
&lt;th&gt;发行版 (部分列表)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Debian Style (.deb)&lt;/td&gt;
&lt;td&gt;Debian, Ubuntu, Xandros, Linspire&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Red Hat Style (.rpm)&lt;/td&gt;
&lt;td&gt;Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://1016990109.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第十一章</title>
    <link href="http://1016990109.github.io/2018/10/29/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/10/29/Node-js-设计模式读书笔记-第十一章/</id>
    <published>2018-10-29T02:00:51.000Z</published>
    <updated>2018-11-25T06:45:59.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Messaging-and-Integration-Patterns-消息传递和相应集成模式"><a href="#Messaging-and-Integration-Patterns-消息传递和相应集成模式" class="headerlink" title="Messaging and Integration Patterns(消息传递和相应集成模式)"></a>Messaging and Integration Patterns(消息传递和相应集成模式)</h1><h2 id="Fundamentals-of-a-messaging-system-一个消息系统的基础"><a href="#Fundamentals-of-a-messaging-system-一个消息系统的基础" class="headerlink" title="Fundamentals of a messaging system(一个消息系统的基础)"></a>Fundamentals of a messaging system(一个消息系统的基础)</h2><p>一般来说消息系统有以下 4 个基础：</p><ul><li>消息传递的方向，是单向的还是“请求/响应”的方向。</li><li>消息的目的，这也决定了消息的内容</li><li>消息的时间性，是同步还是异步</li><li>消息的分发，是直接发送还是通过代理</li></ul><a id="more"></a><h3 id="Message-types-消息的类型"><a href="#Message-types-消息的类型" class="headerlink" title="Message types(消息的类型)"></a>Message types(消息的类型)</h3><h4 id="Command-Message-命令消息"><a href="#Command-Message-命令消息" class="headerlink" title="Command Message(命令消息)"></a>Command Message(命令消息)</h4><p>这类消息的目的是在接收方执行一个动作或任务，因此消息通常包含了执行任务所需要的参数(操作的名称+运行的参数)。命令消息可以用来实现 <code>RPC</code>、分布式计算、请求数据等。<code>RESTful HTTP</code> 请求就是命令的例子，<code>HTTP</code> 的动作都有特定的含义：<code>GET</code> 表示获取资源，<code>POST</code> 表示创建新资源，<code>PUT</code> 表示更新，<code>DELETE</code> 表示删除。</p><h4 id="Event-Message-事件消息"><a href="#Event-Message-事件消息" class="headerlink" title="Event Message(事件消息)"></a>Event Message(事件消息)</h4><p>事件消息是用来通知其他组件有事情发横了，通常包含了事件的类型，甚至有时候包含了一些细节如上下文、创建者。</p><h4 id="Document-Message-文档消息"><a href="#Document-Message-文档消息" class="headerlink" title="Document Message(文档消息)"></a>Document Message(文档消息)</h4><p>主要用于组件和机器之间传递数据。和命令消息的区别就是不含如何处理命令的任何内容，和事件消息的区别就是没有特定的事件的关联。通常对命令消息的回复是文档消息。</p><h3 id="Asynchronous-messaging-and-queues-异步消息队列"><a href="#Asynchronous-messaging-and-queues-异步消息队列" class="headerlink" title="Asynchronous messaging and queues(异步消息队列)"></a>Asynchronous messaging and queues(异步消息队列)</h3><p>异步消息类似于 <code>SMS</code>，发邮件时不要求对方已连接互联网，可能立即或者一段时间后收到回复，甚至是没有回复，这样我们就可以不用等待回复继续发送下一封邮件。总之，就是以更少的资源获得更好的并发性。</p><p>另一个优点是可以将消息存储并尽快或延迟发送，当接收方太忙或者我们想要保证传送时非常有用。这可以使用消息队列来实现：</p><p><img src="/assets/img/message_queue.png" alt="message queue"></p><h3 id="Peer-to-peer-or-broker-based-messaging-点对点通信或基于代理的消息"><a href="#Peer-to-peer-or-broker-based-messaging-点对点通信或基于代理的消息" class="headerlink" title="Peer-to-peer or broker-based messaging(点对点通信或基于代理的消息)"></a>Peer-to-peer or broker-based messaging(点对点通信或基于代理的消息)</h3><p>消息可以点对点直接发送，也可以使用中心化的消息代理系统转发。</p><p><img src="/assets/img/message_architecture.png" alt="message architecture"></p><p>在点对点体系中要求每个节点知道接收方得地址和端口，并且得使用相同的协议和消息格式，限制太多；而消息代理则不需要，每个节点完全独立，还可以有多种协议。</p><h2 id="Publish-subscribe-pattern-发布-订阅-模式"><a href="#Publish-subscribe-pattern-发布-订阅-模式" class="headerlink" title="Publish/subscribe pattern(发布/订阅 模式)"></a>Publish/subscribe pattern(发布/订阅 模式)</h2><p>”发布/订阅“ 模式也有点对点架构和代理架构：</p><p><img src="/assets/img/pub_sub_architecture.png" alt="Pub/Sub architecture"></p><h3 id="Building-a-minimalist-real-time-chat-application-构建一个微型实时聊天应用"><a href="#Building-a-minimalist-real-time-chat-application-构建一个微型实时聊天应用" class="headerlink" title="Building a minimalist real-time chat application(构建一个微型实时聊天应用)"></a>Building a minimalist real-time chat application(构建一个微型实时聊天应用)</h3><p>为了展示 “发布/订阅” 模式如何帮助我们构建一个分布式架构，我们通过构建一个简单的基于 <code>WebSockets</code> 实时聊天应用来说明。</p><h4 id="Implementing-the-server-side"><a href="#Implementing-the-server-side" class="headerlink" title="Implementing the server side"></a>Implementing the server side</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server</span><br><span class="line"></span><br><span class="line"><span class="comment">//static file server</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(</span><br><span class="line">  <span class="comment">//[1]</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'ecstatic'</span>)(&#123; <span class="attr">root</span>: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/www`</span> &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; <span class="attr">server</span>: server &#125;) <span class="comment">//[2]</span></span><br><span class="line">wss.on(<span class="string">'connection'</span>, ws =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">  ws.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="comment">//[3]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    broadcast(msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//[4]</span></span><br><span class="line">  wss.clients.forEach(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">    client.send(msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.listen(process.argv[<span class="number">2</span>] || <span class="number">8080</span>)</span><br></pre></td></tr></table></figure><h4 id="Implementing-the-client-side"><a href="#Implementing-the-client-side" class="headerlink" title="Implementing the client side"></a>Implementing the client side</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://'</span> + <span class="built_in">window</span>.document.location.host)</span></span><br><span class="line"><span class="javascript">      ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> msgDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">        msgDiv.innerHTML = message.data</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'messages'</span>).appendChild(msgDiv)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">'msgBox'</span>).value</span></span><br><span class="line"><span class="undefined">        ws.send(message)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Messages:</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"messages"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Send a message"</span> <span class="attr">id</span>=<span class="string">"msgBox"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"sendMessage()"</span> <span class="attr">value</span>=<span class="string">"Send"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Running-and-scaling-the-chat-application-运行并扩展聊天应用"><a href="#Running-and-scaling-the-chat-application-运行并扩展聊天应用" class="headerlink" title="Running and scaling the chat application(运行并扩展聊天应用)"></a>Running and scaling the chat application(运行并扩展聊天应用)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node app 8080</span><br><span class="line">node app 8081</span><br></pre></td></tr></table></figure><p>启动两个服务，当在一个客户端发送消息时，只是将消息广播给本地连接的客户端了，另一个连着另外一个服务器的客户端并收不到消息，这和我们的意愿是相悖的。</p><h3 id="Using-Redis-as-a-message-broker-使用-Redis-作为消息代理"><a href="#Using-Redis-as-a-message-broker-使用-Redis-作为消息代理" class="headerlink" title="Using Redis as a message broker(使用 Redis 作为消息代理)"></a>Using Redis as a message broker(使用 Redis 作为消息代理)</h3><p>了解 <code>Redis</code> 请查看 <a href="http://redis.io/topics/quickstart" target="_blank" rel="noopener">http://redis.io/topics/quickstart</a>。</p><p><img src="/assets/img/redis_broker.png" alt="redis broker"></p><p>修改服务器代码，并引入 <code>redis</code> 模块，代码可查看 []：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server</span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'redis'</span>)</span><br><span class="line"><span class="keyword">const</span> redisSub = redis.createClient()</span><br><span class="line"><span class="keyword">const</span> redisPub = redis.createClient()</span><br><span class="line"></span><br><span class="line"><span class="comment">//static file server</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'ecstatic'</span>)(&#123; <span class="attr">root</span>: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/www`</span> &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; <span class="attr">server</span>: server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, ws =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">  ws.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    redisPub.publish(<span class="string">'chat_messages'</span>, msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">redisSub.subscribe(<span class="string">'chat_messages'</span>)</span><br><span class="line">redisSub.on(<span class="string">'message'</span>, (channel, msg) =&gt; &#123;</span><br><span class="line">  wss.clients.forEach(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">    client.send(msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(process.argv[<span class="number">2</span>] || <span class="number">8080</span>)</span><br></pre></td></tr></table></figure><p>然后再启动多个服务就发现可以正常通信了。</p><blockquote><p>详细代码可以查看 <a href="https://github.com/1016990109/front_end_practice/tree/master/src/node/design-pattern/basic-chat" target="_blank" rel="noopener">https://github.com/1016990109/front_end_practice/tree/master/src/node/design-pattern/basic-chat</a></p></blockquote><h3 id="Peer-to-peer-publish-subscribe-with-􏱔􏰊􏰖􏱔􏰊􏰖􏱔􏰊􏰖OMQ-使用-OMQ-实现点对点发布订阅"><a href="#Peer-to-peer-publish-subscribe-with-􏱔􏰊􏰖􏱔􏰊􏰖􏱔􏰊􏰖OMQ-使用-OMQ-实现点对点发布订阅" class="headerlink" title="Peer-to-peer publish/subscribe with 􏱔􏰊􏰖􏱔􏰊􏰖􏱔􏰊􏰖ØMQ(使用 ØMQ 实现点对点发布订阅)"></a>Peer-to-peer publish/subscribe with 􏱔􏰊􏰖􏱔􏰊􏰖􏱔􏰊􏰖ØMQ(使用 ØMQ 实现点对点发布订阅)</h3><h4 id="Introducing-OMQ"><a href="#Introducing-OMQ" class="headerlink" title="Introducing ØMQ"></a>Introducing ØMQ</h4><p>在 <code>ØMQ</code> 中，我们有两种专门为此设计的套接字:<code>PUB</code> 和 <code>SUB</code>。典型的模式是将 <code>PUB</code> 套接字绑定到一个端口，该端口将开始侦听来自其他 <code>SUB</code> 套接字的订阅。订阅可以有一个过滤器，指定将传递到 <code>SUB</code> 套接字的消息。该过滤器是一个简单的二进制缓冲区(所以它也可以是一个字符串)，它将与消息的开头(这也是一个二进制缓冲区)相匹配。当通过 <code>PUB</code> 套接字发送一条消息时，它将被广播到所有连接的 <code>SUB</code> 套接字，但仅在应用了它们的订阅过滤器之后。仅当使用连接的协议时，过滤器才会应用到发布方，例如 <code>TCP</code>。</p><h4 id="Designing-a-peer-to-peer-architecture-for-the-chat-server-为聊天服务设计一个点对点架构"><a href="#Designing-a-peer-to-peer-architecture-for-the-chat-server-为聊天服务设计一个点对点架构" class="headerlink" title="Designing a peer-to-peer architecture for the chat server(为聊天服务设计一个点对点架构)"></a>Designing a peer-to-peer architecture for the chat server(为聊天服务设计一个点对点架构)</h4><p><img src="/assets/img/ØMQ_pub_sub.png" alt="ØMQ pub sub"></p><h4 id="Using-the-OMQ-PUB-SUB-sockets-使用-OMQ-发布订阅套接字"><a href="#Using-the-OMQ-PUB-SUB-sockets-使用-OMQ-发布订阅套接字" class="headerlink" title="Using the ØMQ PUB/SUB sockets(使用 ØMQ 发布订阅套接字)"></a>Using the ØMQ PUB/SUB sockets(使用 ØMQ 发布订阅套接字)</h4><p>修改服务端代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server</span><br><span class="line"><span class="keyword">const</span> args = <span class="built_in">require</span>(<span class="string">'minimist'</span>)(process.argv.slice(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">const</span> zmq = <span class="built_in">require</span>(<span class="string">'zmq'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//static file server</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'ecstatic'</span>)(&#123; <span class="attr">root</span>: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/www`</span> &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pubSocket = zmq.socket(<span class="string">'pub'</span>)</span><br><span class="line">pubSocket.bind(<span class="string">`tcp://127.0.0.1:<span class="subst">$&#123;args[<span class="string">'pub'</span>]&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subSocket = zmq.socket(<span class="string">'sub'</span>)</span><br><span class="line"><span class="keyword">const</span> subPorts = [].concat(args[<span class="string">'sub'</span>])</span><br><span class="line">subPorts.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Subscribing to <span class="subst">$&#123;p&#125;</span>`</span>)</span><br><span class="line">  subSocket.connect(<span class="string">`tcp://127.0.0.1:<span class="subst">$&#123;p&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">subSocket.subscribe(<span class="string">'chat'</span>)</span><br><span class="line"></span><br><span class="line">subSocket.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`From other server: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">  broadcast(msg.toString().split(<span class="string">' '</span>)[<span class="number">1</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; <span class="attr">server</span>: server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, ws =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">  ws.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    broadcast(msg)</span><br><span class="line">    pubSocket.send(<span class="string">`chat <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  wss.clients.forEach(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">    client.send(msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.listen(args[<span class="string">'http'</span>] || <span class="number">8080</span>)</span><br></pre></td></tr></table></figure><ol><li>创建 <code>pub</code> 套接字，绑定到对应参数的端口。</li><li>创建 <code>sub</code> 套接字，连接到应用其他实例的 <code>pub</code> 套接字。</li><li>然后通过 <code>chat</code> 作为过滤器创建实际的发布订阅。</li><li>当我们的 <code>WebSocket</code> 收到新小时时，广播给所有连接的客户端，也通过 <code>pub</code> 套接字发布它。注意内容是 <code>chat ${msg}</code> 前面加了 <code>chat</code>，所以发布到所有使用 <code>chat</code> 订阅者。</li><li><code>sub</code> 套接字收到消息则做处理，取得需要的消息，并广播到所有连接当前 <code>WebSocket</code> 的客户端。</li></ol><p>尝试运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node app --http 8080 --pub 5000 --sub 5001 --sub 5002</span><br><span class="line">node app --http 8081 --pub 5001 --sub 5000 --sub 5002</span><br><span class="line">node app --http 8082 --pub 5002 --sub 5000 --sub 5001</span><br></pre></td></tr></table></figure><blockquote><p>详细代码可以查看 <a href="https://github.com/1016990109/front_end_practice/tree/master/src/node/design-pattern/chat-zmq" target="_blank" rel="noopener">https://github.com/1016990109/front_end_practice/tree/master/src/node/design-pattern/chat-zmq</a></p></blockquote><h3 id="Durable-subscribers-持久订阅者"><a href="#Durable-subscribers-持久订阅者" class="headerlink" title="Durable subscribers(持久订阅者)"></a>Durable subscribers(持久订阅者)</h3><p>消息传递系统中的一个重要抽象是消息队列(<code>MQ</code>)。对于消息队列，消息的发送者和接收者不需要同时处于活动状态和连接状态以建立通信，因为排队系统负责存储消息直到目的地能够接收他们。这种行为与 <code>set and forget</code> 范式相反，订户只能在消息系统连接期间才能接收消息。</p><p>一个能够始终可靠地接收所有消息的订阅者，即使是在没有收听这些消息时发送的消息，也被称为<strong>持久订阅者</strong>。</p><p><img src="/assets/img/durable_subscribers.png" alt="durable subscribers"></p><p><code>MQTT</code> 协议为发送方和接收方之间交换的消息定义了服务质量(<code>QoS</code>)级别。这些级别对描述任何其他消息系统(不仅仅是 MQTT )的可靠性也非常有用。如下描述:</p><ol><li><code>QoS0</code> ,最多一次:也被称为“设置并忘记”,消息不会被保留,并且传送未被确认。这意味着在接收机崩溃或断开的情况下,信息可能会丢失。</li><li><code>QoS1</code> ,至少一次:保证至少收到一次该消息,但如果在通知发件人之前接收器崩溃,则可能发生重复。这意味着消息必须在必须再次发送的情况下持续下去。</li><li><code>QoS2</code> ,正好一次:这是最可靠的 <code>QoS</code> ; 它保证该消息只被接收一次。 这是以用于确认消息传递的更慢和更数据密集型机制为代价的。</li></ol><p><code>Redis</code> 的发布/订阅命令实现了一个设置和遗忘机制( <code>QoS0</code> )。但是,<code>Redis</code> 仍然可以用于使用其他命令的组合来实现持久订阅者(不直接依赖其发布/订阅实现)。</p><h4 id="Instroducing-AMQP-AMQP-介绍"><a href="#Instroducing-AMQP-AMQP-介绍" class="headerlink" title="Instroducing AMQP(AMQP 介绍)"></a>Instroducing AMQP(AMQP 介绍)</h4><p><code>AMQP</code> 是许多消息队列系统支持的开放标准协议。除了定义通用通信协议外,它还提供了描述路由,过滤,排队,可靠性和安全性的模型。在 <code>AMQP</code> 中,有三个基本组成部分:</p><ul><li><code>Queue</code>(队列):负责存储客户端消费的消息的数据结构。我们的应用程序推送消息到队列,供给一个或多个消费者。如果多个使用者连接到同一个队列,则这些消息会在它们之间进行负载平衡。 队列可以是以下之一:<ul><li><code>Durable</code>(持久队列) :这意味着如果代理重新启动,队列会自动重新创建。一个持久的队列并不意味着它的内容也被保留下来;实际上,只有标记为持久性的消息才会保存到磁盘,并在重新启动的情况下进行恢复。</li><li><code>Exclusive</code>(专有队列) :这意味着队列只能绑定到一个特定的用户连接。当连接关闭时,队列被销毁。</li><li><code>Auto-delete</code>(自动删除队列) :这会导致队列在最后一个用户断开连接时被删除。</li></ul></li><li><code>Exchange</code>(交换机) :这是发布消息的地方。交换机根据它实现的算法将消息路由到一个或多个队列:<ul><li><code>Direct exchange</code>(直接交换机) :通过匹配路由键(例如, <code>chat.msg</code> )整个消息来路由消息。</li><li><code>Topic exchange</code>(主题交换机) :它使用与路由密钥相匹配的类似 <code>glob</code> 的模式分发消息(例如, <code>chat.#</code> 匹配以 <code>chat</code> 开始的所有路由密钥)。</li><li><code>Fanout exchange</code>(扇出交换机) :它向所有连接的队列广播消息,忽略提供的任何路由密钥。</li></ul></li><li><code>Binding</code>(绑定) :这是交换机和队列之间的链接。它还定义了路由键或用于过滤从交换机到达的消息的模式。</li></ul><blockquote><p>可以在 <code>RabbitMQ</code> 网站上找到 <code>AMQP</code> 模型的详细介绍: <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a></p></blockquote><p>下图展示了组件如何组合：</p><p><img src="/assets/img/AMQP.png" alt="AMQP"></p><h4 id="Durable-subscribers-with-AMQP-and-RabbitMQ-使用-AMQP-和-RabbitMQ-实现持久订阅者"><a href="#Durable-subscribers-with-AMQP-and-RabbitMQ-使用-AMQP-和-RabbitMQ-实现持久订阅者" class="headerlink" title="Durable subscribers with AMQP and RabbitMQ(使用 AMQP 和 RabbitMQ 实现持久订阅者)"></a>Durable subscribers with AMQP and RabbitMQ(使用 AMQP 和 RabbitMQ 实现持久订阅者)</h4><p>现在让我们使用微服务方法扩展我们的小聊天应用程序。让我们添加一个历史记录服务,将我们的聊天消息保存在数据库中,这样当客户端连接时,我们可以查询服务并检索整个聊天记录。我们将使用 <code>RabbitMQ broker</code><br>和 <code>AMQP</code> 将历史记录服务器与聊天服务器相集成。</p><p>下图显示了我们的架构:</p><p><img src="/assets/img/RabbitMQ_broker.png" alt="RabbitMQ broker"></p><p>我们将使用熟悉的 <code>LevelUP</code> 作为历史记录服务的存储引擎,而我们将使用 <code>amqplib</code>,并通过 <code>AMQP</code> 协议连接到 <code>RabbitMQ</code>。现在让我们实施我们的历史记录服务器!我们将创建一个独立的应用程序(典型的微服务),它在模块 <code>historySvc.js</code> 中实现。该模块由两部分组成:向客户端展示聊天记录的 <code>HTTP</code> 服务器,以及负责捕获聊天消息并将其存储在本地数据库中的 <code>AMQP</code> 使用者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> level = <span class="built_in">require</span>(<span class="string">'level'</span>)</span><br><span class="line"><span class="keyword">const</span> timestamp = <span class="built_in">require</span>(<span class="string">'monotonic-timestamp'</span>)</span><br><span class="line"><span class="keyword">const</span> JSONStream = <span class="built_in">require</span>(<span class="string">'JSONStream'</span>)</span><br><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib'</span>)</span><br><span class="line"><span class="keyword">const</span> db = level(<span class="string">'./msgHistory'</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>)</span><br><span class="line">    db.createValueStream()</span><br><span class="line">      .pipe(JSONStream.stringify())</span><br><span class="line">      .pipe(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8090</span>)</span><br><span class="line"><span class="keyword">let</span> channel, queue</span><br><span class="line">amqp</span><br><span class="line">  .connect(<span class="string">'amqp://localhost'</span>) <span class="comment">// [1]</span></span><br><span class="line">  .then(<span class="function"><span class="params">conn</span> =&gt;</span> conn.createChannel())</span><br><span class="line">  .then(<span class="function"><span class="params">ch</span> =&gt;</span> &#123;</span><br><span class="line">    channel = ch</span><br><span class="line">    <span class="keyword">return</span> channel.assertExchange(<span class="string">'chat'</span>, <span class="string">'fanout'</span>) <span class="comment">// [2]</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> channel.assertQueue(<span class="string">'chat_history'</span>)) <span class="comment">// [3]</span></span><br><span class="line">  .then(<span class="function"><span class="params">q</span> =&gt;</span> &#123;</span><br><span class="line">    queue = q.queue</span><br><span class="line">    <span class="keyword">return</span> channel.bindQueue(queue, <span class="string">'chat'</span>) <span class="comment">// [4]</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> channel.consume(queue, msg =&gt; &#123;</span><br><span class="line">      <span class="comment">// [5]</span></span><br><span class="line">      <span class="keyword">const</span> content = msg.content.toString()</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Saving message: <span class="subst">$&#123;content&#125;</span>`</span>)</span><br><span class="line">      db.put(timestamp(), content, err =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!err) channel.ack(msg)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><ol><li>我们首先与 <code>AMQP</code> 代理建立连接,在我们的例子中是 <code>RabbitMQ</code>。然后,我们创建一个 <code>channel</code>,该 <code>channel</code> 类似于保持我们通信状态的会话。</li><li>接下来,我们建立了我们的会话,名为 <code>chat</code>。正如我们已经提到的那样,这是一种扇出交换机。<code>assertExchange()</code> 命令将确保代理中存在交换,否则它将创建它。</li><li>我们还创建了我们的队列,名为 <code>chat_history</code>。默认情况下,队列是持久的;不是排他性的,也不会自动删除,所以我们不需要传递任何额外的选项来支持持久订阅者。</li><li>接下来,我们将队列绑定到我们以前创建的交换机。在这里,我们不需要任何其他特殊选项,例如路由键或模式,因为交换机是扇出类型的交换机,所以它不执行任何过滤。</li><li>最后,我们可以开始监听来自我们刚创建的队列的消息。我们将使用时间戳记作为密钥(<a href="https://npmjs.org/package/monotonic-timestamp" target="_blank" rel="noopener">https://npmjs.org/package/monotonic-timestamp</a>)在 <code>LevelDB</code> 数据库中收到的每条消息保存,以保持消息按日期排序。看到我们使用 <code>channel.ack(msg)</code> 来确认每条消息,并且只有在消息成功保存到数据库后,也很有趣。如果代理没有收到 <code>ACK</code> (确认),则该消息将保留在队列中以供再次处理。这是 <code>AMQP</code> 将服务可靠性提升到全新水平的另一个重要特征。如果我们不想发送明确的确认,我们可以将选项 <code>{noAck:true}</code> 传递给 <code>channel.consume()</code> <code>API</code> 。</li></ol><p>然后更改我们的 <code>app.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server</span><br><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib'</span>)</span><br><span class="line"><span class="keyword">const</span> JSONStream = <span class="built_in">require</span>(<span class="string">'JSONStream'</span>)</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</span><br><span class="line"><span class="keyword">let</span> httpPort = process.argv[<span class="number">2</span>] || <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static file server</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'ecstatic'</span>)(&#123; <span class="attr">root</span>: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/www`</span> &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> channel, queue</span><br><span class="line">amqp</span><br><span class="line">  .connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">conn</span> =&gt;</span> conn.createChannel())</span><br><span class="line">  .then(<span class="function"><span class="params">ch</span> =&gt;</span> &#123;</span><br><span class="line">    channel = ch</span><br><span class="line">    <span class="keyword">return</span> channel.assertExchange(<span class="string">'chat'</span>, <span class="string">'fanout'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> channel.assertQueue(<span class="string">`chat_srv_<span class="subst">$&#123;httpPort&#125;</span>`</span>, &#123; <span class="attr">exclusive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">q</span> =&gt;</span> &#123;</span><br><span class="line">    queue = q.queue</span><br><span class="line">    <span class="keyword">return</span> channel.bindQueue(queue, <span class="string">'chat'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> channel.consume(</span><br><span class="line">      queue,</span><br><span class="line">      msg =&gt; &#123;</span><br><span class="line">        msg = msg.content.toString()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'From queue: '</span> + msg)</span><br><span class="line">        broadcast(msg)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">noAck</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; <span class="attr">server</span>: server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, ws =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">  <span class="comment">//query the history service</span></span><br><span class="line">  request(<span class="string">'http://localhost:8090'</span>)</span><br><span class="line">    .on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.log(err))</span><br><span class="line">    .pipe(JSONStream.parse(<span class="string">'*'</span>))</span><br><span class="line">    .on(<span class="string">'data'</span>, msg =&gt; ws.send(msg))</span><br><span class="line"></span><br><span class="line">  ws.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    channel.publish(<span class="string">'chat'</span>, <span class="string">''</span>, <span class="keyword">new</span> Buffer(msg))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  wss.clients.forEach(<span class="function"><span class="params">client</span> =&gt;</span> client.send(msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.listen(httpPort)</span><br></pre></td></tr></table></figure><p>正如我们所提到的,我们的聊天服务器不需要成为持久的订阅者。所以当我们创建我们的队列时,我们传递选项 <code>{exclusive:true}</code>,指示队列被限制到当前连接,因此一旦聊天服务器关闭,它就会被销毁。</p><p>启动应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node app 8080</span><br><span class="line">node app 8081</span><br><span class="line">node historySvc</span><br></pre></td></tr></table></figure><p>现在看看我们的系统,特别是历史服务如何在停机的情况下运行,这一点很有意思。如果我们停止历史记录服务器并继续使用聊天应用程序的 <code>Web UI</code> 发送消息,我们将会看到,当历史记录服务器重新启动时,它将立即收到所有错过的消息。</p><h2 id="Pipelines-and-task-distribution-patterns-管道和任务分配模式"><a href="#Pipelines-and-task-distribution-patterns-管道和任务分配模式" class="headerlink" title="Pipelines and task distribution patterns(管道和任务分配模式)"></a>Pipelines and task distribution patterns(管道和任务分配模式)</h2><p>有时候我们的需求并不是把消息传递给每一个消费者，例如 <code>Map/Reduce</code> 之类的架构，需要将 <code>Map</code> 的任务分配给不同的 <code>worker</code>，再将最终结果组合。那么继续使用“发布/订阅”模式就不行了，这里我们介绍管道和任务分配模式：</p><p><img src="/assets/img/pipelines_task_and_distribution_patterns.png" alt="Pipelines and task distribution patterns"></p><h3 id="The-OMQ-fanout-fanin-pattern-OMQ-扇出-扇出模式"><a href="#The-OMQ-fanout-fanin-pattern-OMQ-扇出-扇出模式" class="headerlink" title="The ØMQ fanout/fanin pattern (ØMQ 扇出/扇出模式)"></a>The ØMQ fanout/fanin pattern (ØMQ 扇出/扇出模式)</h3><p>我们已经发现了 <code>ØMQ</code> 在构建点对点分布式体系结构方面的一些优势。在前一节中,我们使用 <code>PUB</code> 和 <code>SUB</code> 套接字向多个消费者传播单个消息;现在我们将看到如何使用称为 <code>PUSH</code> 和 <code>PULL</code> 的另一对套接字来构建并行管道。</p><h4 id="PUSH-PULL-socket"><a href="#PUSH-PULL-socket" class="headerlink" title="PUSH/PULL socket"></a>PUSH/PULL socket</h4><p>直观地说,我们可以说 <code>PUSH</code> 套接字用于发送消息,而 <code>PULL</code> 套接字是用于接收的。这似乎是一个微不足道的组合;然而,它们有一些很好的特性,使它们成为构建单向通信系统的完美选择:</p><ul><li>两者都可以在 <code>connet</code> 模式或 <code>bind</code> 模式下工作。换句话说,我们可以构建一个 <code>PUSH</code> 套接字并将其绑定到本地端口,以监听来自 <code>PULL</code> 套接字的传入连接,反之亦然, <code>PULL</code> 套接字可以监听来自 <code>PUSH</code> 套接字的连接。消息总是以相同的方向传播,从 <code>PUSH</code> 到 <code>PULL</code>;它只是连接的发起者可能是不同的。绑定模式是耐用节点(例如任务生产者和接收器)的最佳解决方案,而连接模式对于瞬态节点(例如任务工作者)来说是完美的。这使得瞬时节点的数量可以任意变化,而不会影响其它正在使用的节点。</li><li>如果有多个 <code>PULL</code> 套接字连接到单个 <code>PUSH</code> 套接字,则消息均匀分布在所有的 <code>PULL</code> 套接字中;在实践中,它们是负载均衡的(点对点负载平衡!)。另一方面,从多个 <code>PUSH</code> 套接字接收消息的 <code>PULL</code> 套接字将使用公平排队系统处理消息,这意味着它们将从所有负载是均衡的。</li><li>通过没有任何连接 <code>PULL</code> 套接字的 <code>PUSH</code> 套接字发送的消息不会丢失;他们排队等待生产者,直到一个节点联机并开始提取消息。</li></ul><h4 id="Building-a-distributed-hashsum-cracker-with-OMQ-使用-OMQ-构建一个分布式的-hashsum-cracker"><a href="#Building-a-distributed-hashsum-cracker-with-OMQ-使用-OMQ-构建一个分布式的-hashsum-cracker" class="headerlink" title="Building a distributed hashsum cracker with ØMQ(使用 ØMQ 构建一个分布式的 hashsum cracker)"></a>Building a distributed hashsum cracker with ØMQ(使用 ØMQ 构建一个分布式的 hashsum cracker)</h4><p><code>hashsum cracker</code>,一个使用暴力破解技术来尝试将给定的 <code>hashsum</code>(<code>MD5</code>,<code>SHA1</code> 等) 与给定字母表中每个可能的字符变体进行匹配的系统。这个算法的负载量是很高的。</p><p>对于我们的应用程序,我们希望通过一个节点来实现典型的并行管道,以在多个 <code>worker</code> 之间创建和分配任务,以及一个节点来收集所有结果。我们刚刚描述的系统可以使用以下体系结构在 <code>ØMQ</code> 中实现:</p><p><img src="/assets/img/hashsum_cracker.png" alt="hashsum cracker"></p><p>在我们的体系结构中,我们有一个 <code>ventilator</code>,用于生成给定字母表中所有可能的字符变体,并将它们分发给一组 <code>worker</code>,然后计算每个给定变体的哈希函数并尝试将其与输入的哈希函数进行匹配。如果找到匹配项,则结果将发送到结果收集器节点(<code>sink</code>)。</p><p>重点是 <code>ventilator</code> 和 <code>sink</code>,而 <code>worker</code> 节点是随时在变化中的。这意味着每个 <code>worker</code> 将其 <code>PULL</code> 套接字连接到 <code>ventilator</code>,并将其 <code>PUSH</code> 套接字连接到 <code>ventilator</code>;通过这种方式,我们可以在不改变 <code>ventilator</code> 和 <code>sink</code> 中的任何参数的情况下,启动和停止我们想要的 <code>worker</code> 数量。</p><h5 id="Implementing-the-ventilator"><a href="#Implementing-the-ventilator" class="headerlink" title="Implementing the ventilator"></a>Implementing the ventilator</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmq = <span class="built_in">require</span>(<span class="string">'zmq'</span>)</span><br><span class="line"><span class="keyword">const</span> variationsStream = <span class="built_in">require</span>(<span class="string">'variations-stream'</span>)</span><br><span class="line"><span class="keyword">const</span> alphabet = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"><span class="keyword">const</span> batchSize = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> maxLength = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> searchHash = process.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ventilator = zmq.socket(<span class="string">'push'</span>) <span class="comment">// [1]</span></span><br><span class="line">ventilator.bindSync(<span class="string">'tcp://*:5016'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> batch = []</span><br><span class="line">variationsStream(alphabet, maxLength)</span><br><span class="line">  .on(<span class="string">'data'</span>, combination =&gt; &#123;</span><br><span class="line">    batch.push(combination)</span><br><span class="line">    <span class="keyword">if</span> (batch.length === batchSize) &#123;</span><br><span class="line">      <span class="comment">// [2]</span></span><br><span class="line">      <span class="keyword">const</span> msg = &#123; <span class="attr">searchHash</span>: searchHash, <span class="attr">variations</span>: batch &#125;</span><br><span class="line">      ventilator.send(<span class="built_in">JSON</span>.stringify(msg))</span><br><span class="line">      batch = []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//send remaining combinations</span></span><br><span class="line">    <span class="keyword">const</span> msg = &#123; <span class="attr">searchHash</span>: searchHash, <span class="attr">variations</span>: batch &#125;</span><br><span class="line">    ventilator.send(<span class="built_in">JSON</span>.stringify(msg))</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>如何给 <code>worker</code> 分配任务:</p><ol><li>我们首先创建一个 <code>PUSH</code> 套接字,并将其绑定到本地端口 5000 ;这是 <code>worker</code> 的 <code>PULL</code> 套接字将连接以接收任务的地方。</li><li>我们将每个批次生成的变体进行分组,然后制作一条消息,其中包含匹配的散列和要检查的一批单词。这实质上是 <code>worker</code> 将接受的任务对象。当我们通过 <code>ventilator</code> 套接字调用 <code>send()</code> 时,消息将按循环分配传递给下一个可用的 <code>worker</code>。</li></ol><h5 id="Implementing-worker"><a href="#Implementing-worker" class="headerlink" title="Implementing worker"></a>Implementing worker</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmq = <span class="built_in">require</span>(<span class="string">'zmq'</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"><span class="keyword">const</span> fromVentilator = zmq.socket(<span class="string">'pull'</span>)</span><br><span class="line"><span class="keyword">const</span> toSink = zmq.socket(<span class="string">'push'</span>)</span><br><span class="line"></span><br><span class="line">fromVentilator.connect(<span class="string">'tcp://localhost:5016'</span>)</span><br><span class="line">toSink.connect(<span class="string">'tcp://localhost:5017'</span>)</span><br><span class="line"></span><br><span class="line">fromVentilator.on(<span class="string">'message'</span>, buffer =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="built_in">JSON</span>.parse(buffer)</span><br><span class="line">  <span class="keyword">const</span> variations = msg.variations</span><br><span class="line">  variations.forEach(<span class="function"><span class="params">word</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Processing: <span class="subst">$&#123;word&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">const</span> shasum = crypto.createHash(<span class="string">'sha1'</span>)</span><br><span class="line">    shasum.update(word)</span><br><span class="line">    <span class="keyword">const</span> digest = shasum.digest(<span class="string">'hex'</span>)</span><br><span class="line">    <span class="keyword">if</span> (digest === msg.searchHash) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Found! =&gt; <span class="subst">$&#123;word&#125;</span>`</span>)</span><br><span class="line">      toSink.send(<span class="string">`Found! <span class="subst">$&#123;digest&#125;</span> =&gt; <span class="subst">$&#123;word&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正如我们所说的,我们的 <code>worker</code> 在我们的体系结构中代表了一个临时节点,因此,它的套接字应连接到远程节点,而不是侦听传入连接。这正是我们在 <code>worker</code> 中所做的,我们创建了两个套接字:</p><ul><li>连接到 <code>ventilator</code> 的 <code>PULL</code> 套接字</li><li>用于接收任务连接到接收器的 <code>PUSH</code> 套接字,用于传播结果</li></ul><p>除此之外,我们的 <code>worker</code> 完成的工作非常简单:对于收到的每条消息,我们迭代它包含的一批单词,然后对每个单词计算 <code>SHA1</code> 校验和,并尝试将其与针对消息传递的 <code>searchHash</code> 进行匹配。当找到匹配时,结果被转发到接收器。</p><h5 id="Implementing-sink"><a href="#Implementing-sink" class="headerlink" title="Implementing sink"></a>Implementing sink</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zmq = <span class="built_in">require</span>(<span class="string">'zmq'</span>)</span><br><span class="line"><span class="keyword">const</span> sink = zmq.socket(<span class="string">'pull'</span>)</span><br><span class="line">sink.bindSync(<span class="string">'tcp://*:5017'</span>)</span><br><span class="line"></span><br><span class="line">sink.on(<span class="string">'message'</span>, buffer =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Message from worker: '</span>, buffer.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们现在准备运行我们的应用程序;让我们开始几个 <code>worker</code> 和 <code>sink</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node worker</span><br><span class="line">node worker</span><br><span class="line">node sink</span><br></pre></td></tr></table></figure><p>然后启动 <code>ventilator</code> ,指定要生成的单词的最大长度以及我们希望匹配的 <code>SHA1</code> 校验和。以下是参数的示例列表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ventilator 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b</span><br></pre></td></tr></table></figure><p>当运行上述命令时,<code>ventilator</code> 将开始生成所有可能的单词,其长度至多为四个字符,并将它们分配给我们开始的工作人员,以及我们提供的校验和。计算结果(如果有的话)将显示在接收器应用程序的终端中。</p><h3 id="Pipelines-and-competing-consumers-in-AMQP-AMQP-中管道和竞争消费者"><a href="#Pipelines-and-competing-consumers-in-AMQP-AMQP-中管道和竞争消费者" class="headerlink" title="Pipelines and competing consumers in AMQP(AMQP 中管道和竞争消费者)"></a>Pipelines and competing consumers in AMQP(AMQP 中管道和竞争消费者)</h3><h4 id="Point-to-point-communications-and-competing-consumers-点对点通信和竞争消费者"><a href="#Point-to-point-communications-and-competing-consumers-点对点通信和竞争消费者" class="headerlink" title="Point-to-point communications and competing consumers(点对点通信和竞争消费者)"></a>Point-to-point communications and competing consumers(点对点通信和竞争消费者)</h4><p>在点对点的配置中，管道模式是非常容易理解的，但是如果使用消息代理，那么就很难去理解各个节点之间的关系了，我们并不知道另一边是谁在监听消息。如果我们想要使用 <code>AMQP</code> 来实现管道和任务分配模式，我们就必须确保每一个消息只能被一个消费者接收，但是这在交换机与多个队列绑定时是无法保证的。所以解决方案就是，将消息直接发给某一个队列，这样就能保证只有一个队列能接收到消息了。这样我们的目标就已经实现一半了。</p><h4 id="Implementing-the-hashsum-cracker-with-AMQP"><a href="#Implementing-the-hashsum-cracker-with-AMQP" class="headerlink" title="Implementing the hashsum cracker with AMQP"></a>Implementing the hashsum cracker with AMQP</h4><p><img src="/assets/img/AMQP_hashsum_cracker.png" alt="the hashsum cracker with AMQP"></p><h5 id="Implementing-the-producer"><a href="#Implementing-the-producer" class="headerlink" title="Implementing the producer"></a>Implementing the producer</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib'</span>)</span><br><span class="line"><span class="keyword">const</span> variationsStream = <span class="built_in">require</span>(<span class="string">'variations-stream'</span>)</span><br><span class="line"><span class="keyword">const</span> alphabet = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"><span class="keyword">const</span> batchSize = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> maxLength = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> searchHash = process.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> connection, channel</span><br><span class="line">amqp</span><br><span class="line">  .connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">conn</span> =&gt;</span> &#123;</span><br><span class="line">    connection = conn</span><br><span class="line">    <span class="keyword">return</span> conn.createChannel()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">ch</span> =&gt;</span> &#123;</span><br><span class="line">    channel = ch</span><br><span class="line">    produce()</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">produce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> batch = []</span><br><span class="line">  variationsStream(alphabet, maxLength)</span><br><span class="line">    .on(<span class="string">'data'</span>, combination =&gt; &#123;</span><br><span class="line">      batch.push(combination)</span><br><span class="line">      <span class="keyword">if</span> (batch.length === batchSize) &#123;</span><br><span class="line">        <span class="keyword">const</span> msg = &#123; <span class="attr">searchHash</span>: searchHash, <span class="attr">variations</span>: batch &#125;</span><br><span class="line">        <span class="comment">//只发送给 jobs_queue 队列，保证只有一个队列接收消息</span></span><br><span class="line">        channel.sendToQueue(<span class="string">'jobs_queue'</span>, <span class="keyword">new</span> Buffer(<span class="built_in">JSON</span>.stringify(msg)))</span><br><span class="line">        batch = []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">//send remaining combinations</span></span><br><span class="line">      <span class="keyword">const</span> msg = &#123; <span class="attr">searchHash</span>: searchHash, <span class="attr">variations</span>: batch &#125;</span><br><span class="line">      channel.sendToQueue(</span><br><span class="line">        <span class="string">'jobs_queue'</span>,</span><br><span class="line">        <span class="keyword">new</span> Buffer(<span class="built_in">JSON</span>.stringify(msg)),</span><br><span class="line">        <span class="comment">//when the last message is sent, close the connection</span></span><br><span class="line">        <span class="comment">//to allow the application to exit</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          channel.close()</span><br><span class="line">          connection.close()</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Implementing-the-worker"><a href="#Implementing-the-worker" class="headerlink" title="Implementing the worker"></a>Implementing the worker</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib'</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> channel, queue</span><br><span class="line">amqp</span><br><span class="line">  .connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">conn</span> =&gt;</span> conn.createChannel())</span><br><span class="line">  .then(<span class="function"><span class="params">ch</span> =&gt;</span> &#123;</span><br><span class="line">    channel = ch</span><br><span class="line">    <span class="comment">// 只从 jobs_queue 中消费</span></span><br><span class="line">    <span class="keyword">return</span> channel.assertQueue(<span class="string">'jobs_queue'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">q</span> =&gt;</span> &#123;</span><br><span class="line">    queue = q.queue</span><br><span class="line">    consume()</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err.stack))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consume</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  channel.consume(queue, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(msg.content.toString())</span><br><span class="line">    <span class="keyword">const</span> variations = data.variations</span><br><span class="line">    variations.forEach(<span class="function"><span class="params">word</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Processing: <span class="subst">$&#123;word&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">const</span> shasum = crypto.createHash(<span class="string">'sha1'</span>)</span><br><span class="line">      shasum.update(word)</span><br><span class="line">      <span class="keyword">const</span> digest = shasum.digest(<span class="string">'hex'</span>)</span><br><span class="line">      <span class="keyword">if</span> (digest === data.searchHash) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Found! =&gt; <span class="subst">$&#123;word&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">//结果发送给 results_queue，使用点对点通信</span></span><br><span class="line">        channel.sendToQueue(</span><br><span class="line">          <span class="string">'results_queue'</span>,</span><br><span class="line">          <span class="keyword">new</span> Buffer(<span class="string">`Found! <span class="subst">$&#123;digest&#125;</span> =&gt; <span class="subst">$&#123;word&#125;</span>`</span>)</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    channel.ack(msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Implementing-the-result-collector"><a href="#Implementing-the-result-collector" class="headerlink" title="Implementing the result collector"></a>Implementing the result collector</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> channel, queue</span><br><span class="line">amqp</span><br><span class="line">  .connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">conn</span> =&gt;</span> conn.createChannel())</span><br><span class="line">  .then(<span class="function"><span class="params">ch</span> =&gt;</span> &#123;</span><br><span class="line">    channel = ch</span><br><span class="line">    <span class="keyword">return</span> channel.assertQueue(<span class="string">'results_queue'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">q</span> =&gt;</span> &#123;</span><br><span class="line">    queue = q.queue</span><br><span class="line">    channel.consume(queue, msg =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Message from worker: '</span>, msg.content.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err.stack))</span><br></pre></td></tr></table></figure><h5 id="Running-the-application"><a href="#Running-the-application" class="headerlink" title="Running the application"></a>Running the application</h5><p>运行应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node worker</span><br><span class="line">node worker</span><br><span class="line"></span><br><span class="line">node collector</span><br><span class="line">node producer 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b</span><br></pre></td></tr></table></figure><h2 id="Request-reply-patterns"><a href="#Request-reply-patterns" class="headerlink" title="Request/reply patterns"></a>Request/reply patterns</h2><p>单向异步消息可以在并发行和效率上带来很大帮助，但有时候我们也需要一个“请求/回复”模式来帮助我们解决剩下的问题。</p><h3 id="Correlation-identifier-相关-ID"><a href="#Correlation-identifier-相关-ID" class="headerlink" title="Correlation identifier(相关 ID)"></a>Correlation identifier(相关 ID)</h3><p>该模式包括标记每个请求的标识符(<code>ID</code>),然后由接收方附加到响应中;通过这种方式,请求的发送者可以关联这两个消息并将响应返回给正确的处理程序。这优雅地解决了存在单向异步通道的问题,消息可以随时在任何方向传播:</p><p><img src="/assets/img/correlation_identifier.png" alt="correlation identifier"></p><h4 id="Implementing-a-request-reply-abstraction-using-correlation-identifier-使用关联-ID-实现-“请求-回复”-抽象"><a href="#Implementing-a-request-reply-abstraction-using-correlation-identifier-使用关联-ID-实现-“请求-回复”-抽象" class="headerlink" title="Implementing a request/reply abstraction using correlation identifier(使用关联 ID 实现 “请求/回复” 抽象)"></a>Implementing a request/reply abstraction using correlation identifier(使用关联 ID 实现 “请求/回复” 抽象)</h4><h5 id="Abstracting-request-抽象请求"><a href="#Abstracting-request-抽象请求" class="headerlink" title="Abstracting request(抽象请求)"></a>Abstracting request(抽象请求)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'node-uuid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">channel</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> idToCallbackMap = &#123;&#125; <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">  channel.on(<span class="string">'message'</span>, message =&gt; &#123;</span><br><span class="line">    <span class="comment">// [2]</span></span><br><span class="line">    <span class="keyword">const</span> handler = idToCallbackMap[message.inReplyTo]</span><br><span class="line">    <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">      handler(message.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">sendRequest</span>(<span class="params">req, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// [3]</span></span><br><span class="line">    <span class="keyword">const</span> correlationId = uuid.v4()</span><br><span class="line">    idToCallbackMap[correlationId] = callback</span><br><span class="line">    channel.send(&#123;</span><br><span class="line">      type: <span class="string">'request'</span>,</span><br><span class="line">      data: req,</span><br><span class="line">      id: correlationId</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>request</code> 函数创建一个闭包。该模式的神奇之处在于 <code>idToCallbackMap</code> 变量,它存储了传出请求与其回复处理程序之间的关联。</li><li>一旦工厂被调用,我们所做的第一件事就是开始监听收到的消息。如果消息的关联 <code>ID</code> (包含在 <code>inReplyTo</code> 属性中)与 <code>idToCallbackMap</code> 变量中包含的任何 <code>ID</code> 相匹配,我们知道我们刚收到一个回复,因此我们获得了对相关响应处理程序的引用,并且用 消息中包含的数据。</li><li>最后,我们返回我们将用来发送新请求的函数。 其工作是使用 <code>node-uuid</code> 生成关联 <code>ID</code>,然后将请求数据包装起来,并指定关联 <code>ID correlationId</code> 和消息类型 <code>type</code>。</li></ol><h5 id="Abstracting-reply-抽象回复"><a href="#Abstracting-reply-抽象回复" class="headerlink" title="Abstracting reply(抽象回复)"></a>Abstracting reply(抽象回复)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">channel</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">registerHandler</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    channel.on(<span class="string">'message'</span>, message =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (message.type !== <span class="string">'request'</span>) <span class="keyword">return</span></span><br><span class="line">      handler(message.data, reply =&gt; &#123;</span><br><span class="line">        channel.send(&#123;</span><br><span class="line">          type: <span class="string">'response'</span>,</span><br><span class="line">          data: reply,</span><br><span class="line">          inReplyTo: message.id</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Trying-the-full-request-reply-cycle-尝试完整的-“请求-回复”-环路"><a href="#Trying-the-full-request-reply-cycle-尝试完整的-“请求-回复”-环路" class="headerlink" title="Trying the full request/reply cycle(尝试完整的 “请求/回复” 环路)"></a>Trying the full request/reply cycle(尝试完整的 “请求/回复” 环路)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> replier = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/replier.js`</span>)</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>)(replier)</span><br><span class="line">request(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">delay</span>: <span class="number">500</span> &#125;, res =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1 + 2 = '</span>, res.sum)</span><br><span class="line">  <span class="comment">// 这应该是我们收到的最后一个回复,所以我们关闭了channel</span></span><br><span class="line">  replier.disconnect()</span><br><span class="line">&#125;)</span><br><span class="line">request(&#123; <span class="attr">a</span>: <span class="number">6</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">delay</span>: <span class="number">100</span> &#125;, res =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6 + 1 = '</span>, res.sum)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此我们的应用就完成了。</p><h3 id="Return-address-返回地址"><a href="#Return-address-返回地址" class="headerlink" title="Return address(返回地址)"></a>Return address(返回地址)</h3><p>关联 <code>ID</code> 是在单向信道之上创建 “请求/回复” 通信的基本模式;然而,当我们的消息架构拥有多个通道或队列,或者可能有多个请求者时,这还不够。在这些情况下,除了关联 <code>ID</code> 之外,我们还需要知道返回地址,这是允许回复者将回复发送回请求的原始发件人的一条信息。</p><h4 id="Implementing-the-return-address-with-AMQP"><a href="#Implementing-the-return-address-with-AMQP" class="headerlink" title="Implementing the return address with AMQP"></a>Implementing the return address with AMQP</h4><p><img src="/assets/img/AMQP_return_address.png" alt="the return address with AMQP"></p><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// amqpRequest.js</span></span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'node-uuid'</span>)</span><br><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMQPRequest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.idToCallbackMap = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  initialize() &#123;</span><br><span class="line">    <span class="keyword">return</span> amqp</span><br><span class="line">      .connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">conn</span> =&gt;</span> conn.createChannel())</span><br><span class="line">      .then(<span class="function"><span class="params">channel</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel</span><br><span class="line">        <span class="comment">// 没有指定名字，当连接关闭时销毁队列</span></span><br><span class="line">        <span class="comment">// 没有绑定交换机，因为我们只有一个队列</span></span><br><span class="line">        <span class="keyword">return</span> channel.assertQueue(<span class="string">''</span>, &#123; <span class="attr">exclusive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">q</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 监听回复，使用 channel.consume，replyQueue 指定回复的队列，q.queue 是随机生成的名字，因为 assertQueue 参数为空</span></span><br><span class="line">        <span class="keyword">this</span>.replyQueue = q.queue</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._listenForResponses()</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _listenForResponses() &#123;</span><br><span class="line">    <span class="comment">// 收到回复后，调用回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.channel.consume(</span><br><span class="line">      <span class="keyword">this</span>.replyQueue,</span><br><span class="line">      msg =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> correlationId = msg.properties.correlationId</span><br><span class="line">        <span class="keyword">const</span> handler = <span class="keyword">this</span>.idToCallbackMap[correlationId]</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">          handler(<span class="built_in">JSON</span>.parse(msg.content.toString()))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">noAck</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  request(queue, message, callback) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = uuid.v4()</span><br><span class="line">    <span class="comment">// 设置对应关联 ID 的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.idToCallbackMap[id] = callback</span><br><span class="line">    <span class="comment">// 使用 sendToQueue 而不是 publish，因为我们希望是点对点直接传输</span></span><br><span class="line">    <span class="keyword">this</span>.channel.sendToQueue(queue, <span class="keyword">new</span> Buffer(<span class="built_in">JSON</span>.stringify(message)), &#123;</span><br><span class="line">      correlationId: id,</span><br><span class="line">      replyTo: <span class="keyword">this</span>.replyQueue</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> AMQPRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// amqpReply.js</span></span><br><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMQPReply</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(qName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.qName = qName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  initialize() &#123;</span><br><span class="line">    <span class="keyword">return</span> amqp</span><br><span class="line">      .connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">conn</span> =&gt;</span> conn.createChannel())</span><br><span class="line">      .then(<span class="function"><span class="params">channel</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.channel.assertQueue(<span class="keyword">this</span>.qName)</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">q</span> =&gt;</span> (<span class="keyword">this</span>.queue = q.queue))</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err.stack))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleRequest(handler) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.channel.consume(<span class="keyword">this</span>.queue, msg =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> content = <span class="built_in">JSON</span>.parse(msg.content.toString())</span><br><span class="line">      handler(content, reply =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.channel.sendToQueue(</span><br><span class="line">          msg.properties.replyTo, <span class="comment">//消息中带了要求回复的队列名字和关联 ID</span></span><br><span class="line">          <span class="keyword">new</span> Buffer(<span class="built_in">JSON</span>.stringify(reply)),</span><br><span class="line">          &#123; <span class="attr">correlationId</span>: msg.properties.correlationId &#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">this</span>.channel.ack(msg)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">excName, qName, pattern</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AMQPReply(excName, qName, pattern)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requestor.js</span></span><br><span class="line"><span class="keyword">const</span> req = <span class="built_in">require</span>(<span class="string">'./amqpRequest'</span>)()</span><br><span class="line"></span><br><span class="line">req.initialize().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 随机发送 100 个 请求到 requests_queue 队列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">100</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    sendRandomRequest()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendRandomRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">const</span> b = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">100</span>)</span><br><span class="line">  req.request(<span class="string">'requests_queue'</span>, &#123; <span class="attr">a</span>: a, <span class="attr">b</span>: b &#125;, res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;res.sum&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// replier.js</span></span><br><span class="line"><span class="keyword">const</span> Reply = <span class="built_in">require</span>(<span class="string">'./amqpReply'</span>)</span><br><span class="line"><span class="keyword">const</span> reply = Reply(<span class="string">'requests_queue'</span>) <span class="comment">//监听 requests_queue 队列</span></span><br><span class="line"></span><br><span class="line">reply.initialize().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  reply.handleRequest(<span class="function">(<span class="params">req, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request received'</span>, req)</span><br><span class="line">    cb(&#123; <span class="attr">sum</span>: req.a + req.b &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Messaging-and-Integration-Patterns-消息传递和相应集成模式&quot;&gt;&lt;a href=&quot;#Messaging-and-Integration-Patterns-消息传递和相应集成模式&quot; class=&quot;headerlink&quot; title=&quot;Messaging and Integration Patterns(消息传递和相应集成模式)&quot;&gt;&lt;/a&gt;Messaging and Integration Patterns(消息传递和相应集成模式)&lt;/h1&gt;&lt;h2 id=&quot;Fundamentals-of-a-messaging-system-一个消息系统的基础&quot;&gt;&lt;a href=&quot;#Fundamentals-of-a-messaging-system-一个消息系统的基础&quot; class=&quot;headerlink&quot; title=&quot;Fundamentals of a messaging system(一个消息系统的基础)&quot;&gt;&lt;/a&gt;Fundamentals of a messaging system(一个消息系统的基础)&lt;/h2&gt;&lt;p&gt;一般来说消息系统有以下 4 个基础：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息传递的方向，是单向的还是“请求/响应”的方向。&lt;/li&gt;
&lt;li&gt;消息的目的，这也决定了消息的内容&lt;/li&gt;
&lt;li&gt;消息的时间性，是同步还是异步&lt;/li&gt;
&lt;li&gt;消息的分发，是直接发送还是通过代理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第十章</title>
    <link href="http://1016990109.github.io/2018/10/24/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/10/24/Node-js-设计模式读书笔记-第十章/</id>
    <published>2018-10-24T09:05:29.000Z</published>
    <updated>2018-10-28T15:03:01.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scalability-an-Architectural-Patterns-可扩展性和架构模式"><a href="#Scalability-an-Architectural-Patterns-可扩展性和架构模式" class="headerlink" title="Scalability an Architectural Patterns(可扩展性和架构模式)"></a>Scalability an Architectural Patterns(可扩展性和架构模式)</h1><h2 id="An-introduction-to-application-scaling-应用扩展介绍"><a href="#An-introduction-to-application-scaling-应用扩展介绍" class="headerlink" title="An introduction to application scaling(应用扩展介绍)"></a>An introduction to application scaling(应用扩展介绍)</h2><h3 id="Scaling-Node-js-applications-扩展-Node-js-应用"><a href="#Scaling-Node-js-applications-扩展-Node-js-应用" class="headerlink" title="Scaling Node.js applications(扩展 Node.js 应用)"></a>Scaling Node.js applications(扩展 Node.js 应用)</h3><p>我们知道 <code>Node.js</code> 是单线程的，得益于事件循环，我们可以使用单线程来处理成千上万的请求。假如我们的设备够好的话，那么单线程将成为性能瓶颈，尽管服务可以更强大。因此我们想要使用 <code>Node.js</code> 来开发高负载的应用程序，唯一的方法就是通过多进程、多设备来扩展。</p><a id="more"></a><h3 id="The-three-dimensions-of-scalability-可扩展性的三方面"><a href="#The-three-dimensions-of-scalability-可扩展性的三方面" class="headerlink" title="The three dimensions of scalability(可扩展性的三方面)"></a>The three dimensions of scalability(可扩展性的三方面)</h3><p>谈到可扩展性，第一个原则就是负载分布，就是将服务分散在多个地方。《The Art of Scalability》一书中提到了 3 个维度：</p><ul><li>x 轴：克隆</li><li>y 轴：按 服务/功能 分解</li><li>z 轴：按数据分区分割</li></ul><p><img src="/assets/img/the_art_of_scalability.png" alt="Scale Cube"></p><p>立方体的左下角代表那些所有服务都在一个地方的应用，并且只有一个实例。这是只有轻量负载应用的常用方案。</p><p>单例应用最直观的发展就是沿 <code>x</code> 轴向右平移，这是最简单，而且多数时候是廉价的(开发时间成本)，而且高效。这个技术背后的原则是非常简单的，就是克隆实例 <code>n</code> 次，然后每个实例负责 <code>1/n</code> 的工作。</p><p>向 <code>y</code> 轴方向扩展意味着基于功能、服务和用例分解应用。在这种情况下，分解意味着创建不同的应用，它们有着自己的代码，甚至是数据库、UI。<strong>微服务</strong>就是在 <code>y</code> 轴上的扩展。</p><p>最后一个扩展维度是 <code>z</code> 轴，即每个实例只负责整个数据的一部分。这种主要应用于数据库，也就是水平分割或分片。</p><h2 id="Cloning-and-load-balancing-克隆和负载均衡"><a href="#Cloning-and-load-balancing-克隆和负载均衡" class="headerlink" title="Cloning and load balancing(克隆和负载均衡)"></a>Cloning and load balancing(克隆和负载均衡)</h2><p>传统的多线程 <code>Web</code> 服务器通常在分配给一台机器的资源不能再升级或者这样升级的代价要高于简单地启动另一台机器的时候进行扩展。使用多线程，传统的 <code>Web</code> 服务器能利用一个服务器的所有处理能力，比如说所有的处理器和内存。然而，一个单线程的 <code>Node.js</code> 应用是很难做到的，因为单线程在 64 位操作系统最多分配 1.7GB 的内存，这就意味着 <code>Node.js</code> 应用要比传统的服务要更快地去扩展，使得即使在单个机器的情况下也能利用所有的资源。</p><p>不要误认为这是一个缺点，相反在应用的其他质量属性上有很多优点，尤其是可靠性和容错性。</p><h3 id="The-cluster-module-集群模块"><a href="#The-cluster-module-集群模块" class="headerlink" title="The cluster module(集群模块)"></a>The cluster module(集群模块)</h3><p>在 <code>Node.js</code> 中，分发负载的最简单的模式就是通过核心库的 <code>cluster</code> 模块在一台机器上运行多个实例。<code>cluster</code> 模块简化了拷贝相同应用实例并且自动分发来到的连接。</p><p><img src="/assets/img/cluster.png" alt="cluster"></p><p>主进程负责产生若干个 <code>workers</code>，每一个 <code>worker</code> 都是我们想要扩展的应用的一个实例。每个来到的连接被分发到相应的 <code>worker</code>。</p><h4 id="Notes-on-the-behavior-of-the-cluster-module-cluster-模块的行为"><a href="#Notes-on-the-behavior-of-the-cluster-module-cluster-模块的行为" class="headerlink" title="Notes on the behavior of the cluster module(cluster 模块的行为)"></a>Notes on the behavior of the cluster module(cluster 模块的行为)</h4><p>在 <code>Node.js</code> 0.8 和 0.10 中， <code>cluster</code> 模块在多个 <code>worker</code> 中共享相同的服务套接字，留给操作系统在可用的 <code>worker</code> 中对来到的连接负载均衡的任务。但是这种模式有个问题，操作系统在 <code>workers</code> 之间分配负载并不意味着网络请求的负载均衡，更像是调度进程的执行。但是在 0.12 版本以后就不同了，在主进程中有一个明确的循环负载均衡算法，使得请求在 <code>workers</code> 之间平均分布。新的负载均衡算法默认在除 <code>Windows</code> 外的其他平台外使用，并且可以通过设置变量 <code>cluster.schedulingPolicy</code>，常量 <code>cluster.SCHED_RR</code> 或 <code>cluster.SCHED_NON</code> 来修改。</p><h4 id="Building-a-simple-HTTP-server-建立一个简单的-HTTP-服务"><a href="#Building-a-simple-HTTP-server-建立一个简单的-HTTP-服务" class="headerlink" title="Building a simple HTTP server(建立一个简单的 HTTP 服务)"></a>Building a simple HTTP server(建立一个简单的 HTTP 服务)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> pid = process.pid</span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1e7</span>; i &gt; <span class="number">0</span>; i--) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Handling request from <span class="subst">$&#123;pid&#125;</span>`</span>)</span><br><span class="line">    res.end(<span class="string">`Hello from <span class="subst">$&#123;pid&#125;</span>\n`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Started <span class="subst">$&#123;pid&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>我们可以测量服务器在一个进程的情况下每秒最多处理多少请求，比如使用网络基准测试工具像 <a href="http://www.joedog.org/siege-home" target="_blank" rel="noopener">siege</a> 或 <a href="http://httpd.apache.org/docs/2.4/programs/ab.html" target="_blank" rel="noopener">Apache ab</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># siege</span></span><br><span class="line">siege -c200 -t10s http://localhost:8080</span><br><span class="line"><span class="comment"># ab</span></span><br><span class="line">ab -c200 -t10s http://localhost:8080</span><br></pre></td></tr></table></figure><p>上面的命令代表 200 个并发连接在 10s 内请求服务器。作为参考，一个有 4 个处理器的系统结果是每秒 90 个事务，<code>CPU</code> 的利用率仅仅为 20%。</p><h4 id="Scaling-with-the-cluster-module-使用-cluster-模块来扩展应用"><a href="#Scaling-with-the-cluster-module-使用-cluster-模块来扩展应用" class="headerlink" title="Scaling with the cluster module(使用 cluster 模块来扩展应用)"></a>Scaling with the cluster module(使用 cluster 模块来扩展应用)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//clusterApp.js</span></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>)</span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="keyword">const</span> cpus = os.cpus().length</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Clustering to <span class="subst">$&#123;cpus&#125;</span> CPUs`</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpus; i++) &#123;</span><br><span class="line">    cluster.fork()</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// [1]</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./app'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现非常简单，当启动 <code>clusterApp</code> 时，运行主进程，并根据 <code>CPU</code> 数量使用 <code>cluster.fork()</code> 创建子进程。当进入子进程时，主模块再次运行，但是 <code>cluster.isMaster</code> 为 <code>false</code>，所以不会再次启动子进程。</p><blockquote><p>每个 <code>worker</code> 都是单独的进程，有着独立的存储空间和事件循环。</p></blockquote><p>总结来说，可以统一成下面的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="comment">//fork</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//do work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在底层，<code>cluster</code> 模块使用了 <code>child_process.fork()</code> 的 <code>API</code>，因此在 <code>master</code> 与 <code>worker</code> 之间可以有一个可用的通信通道，<code>worker</code> 的实例可以通过 <code>cluster.workers</code> 来访问，向所有 <code>worker</code> 发送消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(cluster.workers).forEach(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  cluster.workers[id].send(<span class="string">'Hello from the master'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在此运行度量命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sieg -c200 -t10s http://localhost:8080</span><br></pre></td></tr></table></figure><blockquote><p>作为参考：有着 4 个处理器的 <code>Linux</code> 系统中使用 <code>Node.js</code> 6 在 <code>CPU</code> 平均负载为 90% 的情况下，性能提升了 3 倍。</p></blockquote><h4 id="Resiliency-and-availability-with-the-cluster-module-cluster-模块的弹性和可用性"><a href="#Resiliency-and-availability-with-the-cluster-module-cluster-模块的弹性和可用性" class="headerlink" title="Resiliency and availability with the cluster module(cluster 模块的弹性和可用性)"></a>Resiliency and availability with the cluster module(cluster 模块的弹性和可用性)</h4><p>当只有一个实例时，如果服务器宕机就会有一段时间不可用。而集群模式则可以避免这种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (code != <span class="number">0</span> &amp;&amp; !worker.suicide) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Worker crashed. Starting a new worker'</span>)</span><br><span class="line">      cluster.fork()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./app'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的代码在一个 <code>worker</code> 实例出现错误而崩溃时，会重新启动一个新的 <code>worker</code>。</p><h4 id="Zero-downtime-restart-零宕机时间重启"><a href="#Zero-downtime-restart-零宕机时间重启" class="headerlink" title="Zero-downtime restart(零宕机时间重启)"></a>Zero-downtime restart(零宕机时间重启)</h4><p>当代码需要更新时，<code>Node.js</code> 应用程序也要重启，所以这种情况下，多实例可以帮助维护应用程序的可用性。</p><p>当我们不得不更新时，应用程序会在更新的这段时间里不可用，而解决方案就是在更新代码事零宕机时间重启来维护应用程序的可用性。<code>cluster</code> 模块可以只重启一个 <code>worker</code>，而其他 <code>worker</code> 继续工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  process.on(<span class="string">'SIGUSR2'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//[1]</span></span><br><span class="line">    <span class="keyword">const</span> workers = <span class="built_in">Object</span>.keys(cluster.workers)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">restartWorker</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//[2]</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= workers.length) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">const</span> worker = cluster.workers[workers[i]]</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Stopping worker: <span class="subst">$&#123;worker.process.pid&#125;</span>`</span>)</span><br><span class="line">      worker.disconnect() <span class="comment">//[3]</span></span><br><span class="line">      worker.on(<span class="string">'exit'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!worker.suicide) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const</span> newWorker = cluster.fork() <span class="comment">//[4]</span></span><br><span class="line">        newWorker.on(<span class="string">'listening'</span>, () =&gt; &#123;</span><br><span class="line">          restartWorker(i + <span class="number">1</span>) <span class="comment">//[5]</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    restartWorker(<span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./app'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作原理就是：</p><ol><li>收到 <code>SIGUSR2</code> 信号时开始迭代重启 <code>worker</code>，只有当前面一个 <code>woker</code> 重新监听后才开始下一个 <code>worker</code> 重启。</li><li><code>restartWorker</code> 第一个任务就是通过 <code>worker.diconnect()</code> 来优雅地停止 <code>worker</code>。接着在终止的进程结束时启动一个新的 <code>worker</code>。</li></ol><blockquote><p>我们的程序使用的是 <code>UNIX</code> 信号，所以在 <code>Windows</code> 系统上是不能正常运行的。信号是实现我们解决方案的最简单的方法，但也不是唯一的，比如还可以使用 <code>socker</code>、管道等等。</p></blockquote><p>其实零宕机时间重启 <a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener">pm2</a> 已经能帮我们做了，具体的使用方法可以移步 <a href="/2018/06/09/Node-服务部署/">Node 服务部署</a>。</p><h3 id="Dealing-with-stateful-communications-处理有状态通信"><a href="#Dealing-with-stateful-communications-处理有状态通信" class="headerlink" title="Dealing with stateful communications(处理有状态通信)"></a>Dealing with stateful communications(处理有状态通信)</h3><p><code>cluster</code> 模块是不适用于有状态通信的应用的，在不同的实例间状态不是共享的。这是因为属于同一个状态的会话发出的请求可能会被不同的应用实例处理，这不仅仅是 <code>cluster</code> 模块的问题，通常来说也是无状态负载均衡算法的问题。</p><h4 id="Sharing-the-state-across-multiple-instances-在多实例见共享状态"><a href="#Sharing-the-state-across-multiple-instances-在多实例见共享状态" class="headerlink" title="Sharing the state across multiple instances(在多实例见共享状态)"></a>Sharing the state across multiple instances(在多实例见共享状态)</h4><p>要实现这个目的必须使用有状态通信来扩展应用程序，比如可以通过共享数据存储轻松地实现，像 <code>PostgreSQL</code>、<code>MongoDB</code>、<code>CouchDB</code>，或者是内存存储 <code>Redis</code>、<code>Memcached</code>。就像下面图中所示：</p><p>![Sharing status](/assets/img/sharing_status.png</p><p>唯一的缺点就是使用共享存储来实现有状态通信并不不容易，例如我们可能有现成的库去实现内存中的状态通信，但也需要更改应用程序的代码。</p><h4 id="Sticky-load-balancing-粘性负载均衡"><a href="#Sticky-load-balancing-粘性负载均衡" class="headerlink" title="Sticky load balancing(粘性负载均衡)"></a>Sticky load balancing(粘性负载均衡)</h4><p>支持有状态通信的另外一种方式就是将同一个会话的请求总是分发到同一个实例上。这种技术被称为粘性负载均衡。</p><p><img src="/assets/img/sticky_load_balancing.png" alt="Sticky load balancing"></p><p>可以看到当接收到与会话相关的请求时，会创建一个由负载均衡算法选择的实例映射表。当下次负载均衡器接收到同一个会话请求时就会将该请求分发到同一个实例。这个技术相关的就是请求的 <code>sessionID</code>(通常在应用的 <code>cookie</code> 中)。</p><p>而更简单的办法就是通过 <code>IP</code> 地址来映射请求与处理的实例，这种技术的优点就是不需要负载均衡器记住关联，只需要通过 <code>hash</code> 就可以知道应该把请求分发到哪一个实例。但是对于会频繁更换 <code>IP</code> 的设备来说就是去了作用。</p><blockquote><p>cluster 模块默认是不支持粘性负载均衡的，但是可以通过引入 <a href="https://www.npmjs.org/package/sticky-session" target="_blank" rel="noopener">sticky-session</a> 来添加这个功能。</p></blockquote><p>粘性负载均的一个大问题就是会使得冗余系统的一些优势不复存在，因为原来每个实例都是相同的，可以互相替代的(在一个宕机后另一个可以处理相同的请求)，但是使用粘性负载均衡后就不行了。所以要尽量避免粘性负载均衡的使用，更多情况还是希望将会话状态存储在一个共享存储中或者根本不需要有状态通信。</p><h3 id="Scaling-with-a-reverse-proxy-使用反向代理扩展"><a href="#Scaling-with-a-reverse-proxy-使用反向代理扩展" class="headerlink" title="Scaling with a reverse proxy(使用反向代理扩展)"></a>Scaling with a reverse proxy(使用反向代理扩展)</h3><p><code>cluster</code> 不是扩展 <code>Node.js</code> 应用的唯一选择，还有很多传统的技术是首选，因为它们在生产环境中更容易使用。</p><p>替代 <code>cluster</code> 的另一种方法是在不同的端口启动同一个应用程序的多个独立实例，然后使用反向代理(或网关)提供对这些实例的访问权限，从而将流量分配到这些实例。</p><p><img src="/assets/img/reverse_proxy_load_balance.png" alt="reverse proxy load balance"></p><p>选择反向代理的原因有很多：</p><ul><li>反向代理不仅仅可以将负载分布到多个进程，也可以分布到多个机器。</li><li>市场上最流行的反向代理支持粘性负载均衡。</li><li>反向代理可以任意路由，不管编程语言和平台。</li><li>可以选择更强大的负载均衡算法</li><li>许多反向代理还提供其他服务，如 <code>URL</code> 重写、缓存甚至是完全成熟的 <code>Web</code> 服务器功能，例如为静态文件提供服务。</li></ul><p>也就是说，如果需要，<code>cluster</code> 模块也可以结合反向代理使用：使用 <code>cluster</code> 在单个机器内垂直扩展，而使用反向代理在不同节点之间水平扩展。</p><p>使用反向代理实现负载均衡有很多种选择，其中比较流行的有：</p><ul><li><a href="http://nginx.org" target="_blank" rel="noopener">Nginx</a>，一个基于非阻塞 <code>I/O</code> 的 <code>Webp</code> 服务器、反向代理、负载均衡器。</li><li><a href="http://www.haproxy.org" target="_blank" rel="noopener">HAProxy</a>，一个用于 <code>TCP/HTTP</code> 流量的快速负载均衡器。</li><li>基于 <code>Node.js</code> 的代理。</li><li>基于云的代理服务器。</li></ul><h4 id="Load-balancing-with-Nginx-使用-Nginx-进行负载均衡"><a href="#Load-balancing-with-Nginx-使用-Nginx-进行负载均衡" class="headerlink" title="Load balancing with Nginx(使用 Nginx 进行负载均衡)"></a>Load balancing with Nginx(使用 Nginx 进行负载均衡)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> pid = process.pid</span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1e7</span>; i &gt; <span class="number">0</span>; i--) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Handling request from <span class="subst">$&#123;pid&#125;</span>`</span>)</span><br><span class="line">    res.end(<span class="string">`Hello from <span class="subst">$&#123;pid&#125;</span>\n`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(process.env.PORT || process.argv[<span class="number">2</span>] || <span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Started <span class="subst">$&#123;pid&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>使用 <a href="https://www.npmjs.com/package/pm2" target="_blank" rel="noopener">pm2</a> 来启动多个应用实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js 8081</span><br><span class="line">pm2 start app.js 8082</span><br><span class="line">pm2 start app.js 8083</span><br><span class="line">pm2 start app.js 8084</span><br></pre></td></tr></table></figure><p>接着配置 <code>Nginx</code> 负载均衡，找到 <code>nginx.conf</code>(一般在 <code>/usr/local/etc/nginx</code>)，并配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  # [...]</span><br><span class="line">  upstream nodejs_design_patterns_app &#123;</span><br><span class="line">    server 127.0.0.1:8081;</span><br><span class="line">    server 127.0.0.1:8082;</span><br><span class="line">    server 127.0.0.1:8083;</span><br><span class="line">    server 127.0.0.1:8084;</span><br><span class="line">  &#125;</span><br><span class="line">  # [...]</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://nodejs_design_patterns_app;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>upstream nodejs_design_patterns_app</code> 中定了用于处理网络请求的后端服务器列表，在 <code>server</code> 部分中指定了 <code>proxy_pass</code>，告诉 <code>Nginx</code> 将任何而请求转发给我们之前定义的服务器组。然后重新加载 <code>Nginx</code> 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="Using-a-service-registry-使用服务注册"><a href="#Using-a-service-registry-使用服务注册" class="headerlink" title="Using a service registry(使用服务注册)"></a>Using a service registry(使用服务注册)</h3><p>基于云的基础架构的一个重要优势就是能够基于当前的运行情况，预测的流量动态调整应用的容量。该机制要求负载均衡器随时了解当前的网络拓扑结构，随时了解哪台服务器处于运行状态。解决此问题的常见模式就是使用成为服务注册中心的中央存储库，该中心存储库跟踪正在运行的服务器及其提供的服务。</p><p><img src="/assets/img/service_registry.png" alt="service registry"></p><p>上述架构假定存在两个服务 <code>API</code> 和 <code>WebApp</code>，负载均衡器将到达 <code>/api</code> 节点的请求分发给实现 <code>API</code> 服务的所有服务器，而其于请求分布在实现 <code>WebApp</code> 服务的服务器上。<strong>这点和微服务架构是一样的</strong>，同样的也是需要将自己注册到服务中心，在停止时取消注册，这样负载均衡器可以使用拥有最新的服务器视图和网络上可用的服务。</p><h4 id="Implementing-a-dynamic-load-balancer-with-http-proxy-and-Consul-使用-http-proxy-和-Consul-来实现动态负载均衡器"><a href="#Implementing-a-dynamic-load-balancer-with-http-proxy-and-Consul-使用-http-proxy-和-Consul-来实现动态负载均衡器" class="headerlink" title="Implementing a dynamic load balancer with http-proxy and Consul(使用 http-proxy 和 Consul 来实现动态负载均衡器)"></a>Implementing a dynamic load balancer with http-proxy and Consul(使用 http-proxy 和 Consul 来实现动态负载均衡器)</h4><p>为了支持动态网络，我们可以使用诸如 <code>Nginx</code> 或 <code>HAProxy</code> 的方向代理，我们要做的只是使用自动服务更新它们的配置，然后强制负载均衡器使用新配置。对 <code>Nginx</code> 来说，可以 <code>nginx -s reload</code> 即可。</p><p>这个例子使用 <a href="https://www.consul.io" target="_blank" rel="noopener">Consul</a> 来作为服务注册。并使用下面 3 个 <code>npm</code> 包：</p><ul><li><a href="https://npmjs.org/package/http-proxy" target="_blank" rel="noopener">http-proxy</a>，一个简化代理和负载均衡的库。</li><li><a href="https://npmjs.org/package/portfindder" target="_blank" rel="noopener">portfinder</a>，一个发现系统空闲端口的库。</li><li><a href="https://npmjs.org/package/consul" target="_blank" rel="noopener">consul</a>，一个允许服务注册的库。</li></ul><p>服务注册的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> pid = process.pid</span><br><span class="line"><span class="keyword">const</span> consul = <span class="built_in">require</span>(<span class="string">'consul'</span>)()</span><br><span class="line"><span class="keyword">const</span> portfinder = <span class="built_in">require</span>(<span class="string">'portfinder'</span>)</span><br><span class="line"><span class="keyword">const</span> serviceType = process.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">portfinder.getPort(<span class="function">(<span class="params">err, port</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> serviceId = serviceType + port</span><br><span class="line">  consul.agent.service.register(</span><br><span class="line">    &#123;</span><br><span class="line">      id: serviceId,</span><br><span class="line">      name: serviceType,</span><br><span class="line">      address: <span class="string">'localhost'</span>,</span><br><span class="line">      port: port,</span><br><span class="line">      tags: [serviceType]</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> unregisterService = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        consul.agent.service.deregister(serviceId, () =&gt; &#123;</span><br><span class="line">          process.exit(err ? <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      process.on(<span class="string">'exit'</span>, unregisterService) <span class="comment">// [4]</span></span><br><span class="line">      process.on(<span class="string">'SIGINT'</span>, unregisterService)</span><br><span class="line">      process.on(<span class="string">'uncaughtException'</span>, unregisterService)</span><br><span class="line"></span><br><span class="line">      http</span><br><span class="line">        .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// [5]</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1e7</span>; i &gt; <span class="number">0</span>; i--) &#123;&#125;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`Handling request from <span class="subst">$&#123;pid&#125;</span>`</span>)</span><br><span class="line">          res.end(<span class="string">`<span class="subst">$&#123;serviceType&#125;</span> response from <span class="subst">$&#123;pid&#125;</span>\n`</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .listen(port, () =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`Started <span class="subst">$&#123;serviceType&#125;</span> (<span class="subst">$&#123;pid&#125;</span>) on port <span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码的逻辑：</p><ol><li>首先使用 <code>portfinder.getPort</code> 找到可用的端口(默认从 8000 端口开始查找)。</li><li>然后使用 <code>Consul</code> 库在注册表中注册一项新服务。服务定义需要几个属性，<code>id</code>(服务的唯一名称)，<code>name</code>(标识服务的通用名称)，<code>address</code> 和 <code>port</code>(用于标识如何访问服务)，<code>tags</code>(一个可选的标签列表，可以用来过滤和组合服务)，<code>serviceType</code>(作为命令行参数制定服务名称并添加标签，这将允许我们识别集群中可用的相同类型的所有服务)。</li><li>定义了 <code>unregisterService</code> 函数，它移除我们刚刚在 <code>Consul</code> 中注册的服务。</li><li>使用 <code>unregisterService</code> 作为一个清理函数，所以当程序关闭时(人为或意外)，服务会从 <code>Consul</code> 中移除。</li><li>最后在我们发现的端口上启动 <code>HTTP</code> 服务。</li></ol><p>现在可以去实现负载均衡器了，定义一个路由表将 <code>URL</code> 映射到对应的服务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadBalancer.js</span></span><br><span class="line"><span class="keyword">const</span> routing = &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/api'</span>,</span><br><span class="line">    service: <span class="string">'api-service'</span>,</span><br><span class="line">    index: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    service: <span class="string">'webapp-service'</span>,</span><br><span class="line">    index: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来实现 <code>loadbalancer.js</code> 的第二部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> httpProxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>)</span><br><span class="line"><span class="keyword">const</span> consul = <span class="built_in">require</span>(<span class="string">'consul'</span>)()</span><br><span class="line"><span class="keyword">const</span> proxy = httpProxy.createProxyServer(&#123;&#125;)</span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> route</span><br><span class="line">    routing.some(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">      route = entry</span><br><span class="line">      <span class="comment">//Starts with the route path</span></span><br><span class="line">      <span class="keyword">return</span> req.url.indexOf(route.path) === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    consul.agent.service.list(<span class="function">(<span class="params">err, services</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> servers = []</span><br><span class="line">      <span class="built_in">Object</span>.keys(services).filter(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (services[id].Tags.indexOf(route.service) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">          servers.push(<span class="string">`http://<span class="subst">$&#123;services[id].Address&#125;</span>:<span class="subst">$&#123;services[id].Port&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">if</span> (!servers.length) &#123;</span><br><span class="line">        res.writeHead(<span class="number">502</span>)</span><br><span class="line">        <span class="keyword">return</span> res.end(<span class="string">'Bad gateway'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      route.index = (route.index + <span class="number">1</span>) % servers.length</span><br><span class="line">      proxy.web(req, res, &#123; <span class="attr">target</span>: servers[route.index] &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8080</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Load balancer started on port 8080'</span>))</span><br></pre></td></tr></table></figure><ol><li>首先引入 <code>consul</code> 库，以便可以访问注册表。接着初始化 <code>http-proxy</code>，并启动一个普通的 <code>Web</code> 服务器。</li><li>服务器处理请求的第一件事就是找到在路由表里匹配 <code>URL</code> 的服务，将结果(包含服务的描述)赋值给 <code>route</code> 以供后续使用。</li><li>从 <code>consul</code> 中拿到实现了需要服务的列表。如果列表为空，返回网关错误；否则使用 <code>Tag</code> 属性来过滤可用的服务，并且找到实现了当前服务类型的服务的地址。</li><li>最后，将请求路由到它的目的地。我们根据循环算法更新 <code>route.index</code> 以指向列表的下一个服务器，以实现负载均衡，然后将它与请求(req)和响应(res)对象一起传递给 <code>proxy.web()</code>。这将简单地将请求转发到我们选择的服务器。</li></ol><p>启动服务并注册到 <code>consul</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在上面可以看到第二个参数为服务的名称</span></span><br><span class="line">pm2 start app.js api-service</span><br><span class="line">pm2 start app.js api-service</span><br><span class="line">pm2 start app.js webapp-service</span><br></pre></td></tr></table></figure><p>这样就完成了动态负载均衡了，<strong>真的很像微服务了（只不过是横向的，扩展实例而不是扩展功能）</strong>。</p><h3 id="Peer-to-peer-balancing-点对点负载均衡"><a href="#Peer-to-peer-balancing-点对点负载均衡" class="headerlink" title="Peer-to-peer balancing(点对点负载均衡)"></a>Peer-to-peer balancing(点对点负载均衡)</h3><p>当我们想要讲一个复杂的内部网络架构暴露给公共网络时，使用反向代理是必须的。它有助于隐藏复杂性，提供外部应用程序可轻松使用和依赖的单一访问点。但是如果我们需要扩展仅供内部使用的服务器，则我们可以拥有更多的灵活性和控制力。</p><p>假设服务 A 依靠服务 B 来实现其功能，服务 B 在多台机器上有扩展，并且只能在内部网络中使用。服务 A 可以使用反向代理连接到服务 B。但是还有一种选择，就是删除反向代理，并直接从客户端(服务 A)分发请求，直接使用客户端实现负载均衡，这样来基本实现点对点负载均衡(<code>peer-to-peer balancing</code>)。</p><p><img src="/assets/img/peer-to-peer_balancing.png" alt="peer-to-peer balancing"></p><p>这是一种非常简单而有效地模式，来真正实现分布式通信，而不会出现瓶颈或者单点故障，除此之外还有以下几个优点：</p><ul><li>通过删除网络节点来降低基础设施的复杂性。</li><li>更快的通信，因为消息经过更少的节点。</li><li>扩展性更好，因为性能不受负载均衡器可以处理的限制。</li></ul><p>另一个方面，通过删除反向代理，我们实际上暴露了其底层基础架构的复杂性。此外，通过实施负载均衡算法，每个客户端都变得更加智能，并且也是保证基础架构是最新的一种方式。</p><blockquote><p>点对点负载均衡是 <a href="http://zeromq.org" target="_blank" rel="noopener">ØMQ</a> 库中广泛使用的一种模式。</p></blockquote><h4 id="Implementing-an-HTTP-client-that-can-balance-requests-across-multiple-servers-实现可跨多台服务器平衡请求的-HTTP-客户端"><a href="#Implementing-an-HTTP-client-that-can-balance-requests-across-multiple-servers-实现可跨多台服务器平衡请求的-HTTP-客户端" class="headerlink" title="Implementing an HTTP client that can balance requests across multiple servers(实现可跨多台服务器平衡请求的 HTTP 客户端)"></a>Implementing an HTTP client that can balance requests across multiple servers(实现可跨多台服务器平衡请求的 HTTP 客户端)</h4><p>我们已经知道了怎么仅仅使用 <code>Node.js</code> 来实现一个负载均衡器并且给可用的服务分发请求了，所以在客户端实现相同的机制并没有什么不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// balancedRequest.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> servers = [</span><br><span class="line">  &#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">port</span>: <span class="string">'8081'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">port</span>: <span class="string">'8082'</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">options, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  i = (i + <span class="number">1</span>) % servers.length</span><br><span class="line">  options.hostname = servers[i].host</span><br><span class="line">  options.port = servers[i].port</span><br><span class="line">  <span class="keyword">return</span> http.request(options, callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到非常简单，只要将即将发出的请求用一个简单的循环算法分发就可以了。</p><blockquote><p>同样的，也可以在客户端集成一个服务注册中心，然后动态地获得可用服务列表。</p></blockquote><h2 id="Decomposing-complex-applications-分解复杂应用"><a href="#Decomposing-complex-applications-分解复杂应用" class="headerlink" title="Decomposing complex applications(分解复杂应用)"></a>Decomposing complex applications(分解复杂应用)</h2><p>前面都是说的在 <code>x</code> 轴上的扩展，现在谈谈 <code>y</code> 轴上的扩展，应用根据功能、服务来分解。</p><h3 id="Monolithic-architecture-单体架构"><a href="#Monolithic-architecture-单体架构" class="headerlink" title="Monolithic architecture(单体架构)"></a>Monolithic architecture(单体架构)</h3><p>单体架构就是所有的服务都集中在一起，但是内部也可以有着高度模块化的划分。像 <code>Linux</code> 操作系统的内核一样，就是单体架构的一类，它有着成百上千的可以在系统运行时装载和卸载服务和模块。然而他们都是在内核模式下运行的，意味着任何一个模块挂掉都会导致整个系统崩溃。这个和微内核架构是相反的，微内核架构就是仅仅核心的服务是在内核模式下运行，其他的是在用户模式下运行的，这种模式的好处就是一个服务的问题不会影响整个系统的稳定性。</p><p>值得注意的是，这些设计模式虽然有着 30 年的历史，但是如今仍被应用着。现代化单体应用和单体内核差不多，比如 <code>Node.js</code>，所有的服务都是基于相同的代码并在单进程中运行(没有克隆的时候)。</p><p><img src="/assets/img/monolithic_architecture.png" alt="monolithic architecture"></p><p>上图展示了一个电子商务的架构，它的结构是模块的，有两个不同的前端，一个是主商店使用，一个是管理员使用。所以这种情况下任何一个模块出了问题，整个系统都会瘫痪。</p><p>除此之外，高度耦合也是这种架构的一个问题，维护任何一个模块都会变得十分困难，可能修改一个模块会导致其他模块也需要修改，浪费大量时间，增加了系统的复杂度。</p><h3 id="The-microservice-architecture-微服务架构"><a href="#The-microservice-architecture-微服务架构" class="headerlink" title="The microservice architecture(微服务架构)"></a>The microservice architecture(微服务架构)</h3><p>现在我们要揭露在 <code>Node.js</code> 中编写大型应用最重要的模式了：阻止大应用。毋庸置疑这将降低系统的复杂度和提高系统的承受能力。这个模式的想法就是将系统按照功能、服务分解成独立的应用程序。和单体架构是完全相反的，这很好地适用 <code>Unix</code> 生态和开头的 <code>Node.js</code> 原则——“让每个程序做好一件事”。</p><p><strong>微服务架构</strong>在今天应该是最好的这种模式的参考了，实现了高内聚、低耦合并整合了复杂性。</p><p>微服务的一个例子：</p><p><img src="/assets/img/microservice_architecture.png" alt="microservice architecture"></p><p>可以看到每个模块都单独地作为一个服务，有着自己的上下文和数据库。实际上，它们就是独立的应用程序，并暴露了相关的服务而已。</p><p>可以看到数据的拥有者是微服务架构的一大特点，虽然多个服务共享一个唯一的数据库会更容易让服务协同合作，但是却损失了多应用的一些优点。而使用不同的数据库又要考虑到数据的一致性。</p><h4 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h4><h5 id="Every-service-is-expandable-每个服务都是可扩展的"><a href="#Every-service-is-expandable-每个服务都是可扩展的" class="headerlink" title="Every service is expandable(每个服务都是可扩展的)"></a>Every service is expandable(每个服务都是可扩展的)</h5><p>最主要的优点就是每个服务都是在自己的上下文中运行，所以崩溃、bug、意外中断都不会影响整个系统。这个目标就是去构建更小的、更容易更改的独立服务。</p><h5 id="Reuability-across-platforms-and-languages-扩平台、语言的可复用性"><a href="#Reuability-across-platforms-and-languages-扩平台、语言的可复用性" class="headerlink" title="Reuability across platforms and languages(扩平台、语言的可复用性)"></a>Reuability across platforms and languages(扩平台、语言的可复用性)</h5><p>将大系统分解成小服务以创建独立的单元使得复用变得更容易了。<code>Elasticsearch</code> 就是一个非常好的重用搜索服务的例子。</p><h5 id="A-way-to-scale-the-application-扩展应用的一个方式"><a href="#A-way-to-scale-the-application-扩展应用的一个方式" class="headerlink" title="A way to scale the application(扩展应用的一个方式)"></a>A way to scale the application(扩展应用的一个方式)</h5><p>根据扩展立方体可以看到微服务就是在 <code>y</code> 轴上扩展了应用。同时我们也可以结合其他两个方向上的扩展，例如可以在不同的机器上部署相同的服务。</p><h5 id="The-challenges-of-microservices-微服务的挑战"><a href="#The-challenges-of-microservices-微服务的挑战" class="headerlink" title="The challenges of microservices(微服务的挑战)"></a>The challenges of microservices(微服务的挑战)</h5><p>虽然看起来微服务解决了我们所有的问题，但是远远不是这样的。实际上，还有很多我们需要解决的问题。比如我们怎么让服务互相交流？怎么部署？怎么扩展？怎么监视一个巨大数量的应用？怎么在服务之间共享和复用代码？幸运的是，云服务和现代化的 <code>DevOps</code> 可以解决上面的一些问题，并且 <code>Node.js</code> 也可以帮助很多。模块化系统就可以很好地帮助我们在不同项目中共享代码。</p><h3 id="Integration-patterns-in-a-microservice-architecture-在微服务架构中的集成模式"><a href="#Integration-patterns-in-a-microservice-architecture-在微服务架构中的集成模式" class="headerlink" title="Integration patterns in a microservice architecture(在微服务架构中的集成模式)"></a>Integration patterns in a microservice architecture(在微服务架构中的集成模式)</h3><h4 id="The-API-proxy-API-代理"><a href="#The-API-proxy-API-代理" class="headerlink" title="The API proxy(API 代理)"></a>The API proxy(API 代理)</h4><p>第一个我们要展示的模式就是利用 <code>API</code> 网关了，一个代理客户端和一系列远程 <code>API</code> 之间交流的服务。可以提供负载均衡、缓存、认证、流量控制等等功能。</p><p><img src="/assets/img/api_gateway.png" alt="api gateway"></p><h4 id="API-orchestration-API-编排"><a href="#API-orchestration-API-编排" class="headerlink" title="API orchestration(API 编排)"></a>API orchestration(API 编排)</h4><p>下面要说的模式是最常见、最准确的集成和组合服务的方式，被称为 <code>API orchestration</code>(<code>API</code> 编排)。详情查看 <a href="http://thenextweb.com/dd/2013/12/17/future-api-design-orchestration-layer" target="_blank" rel="noopener">The future of API design: The orchestration layer</a>。</p><p><img src="/assets/img/api_orchestration.png" alt="api orchestration"></p><p>上面的图展示了商店前端应用是怎么使用一个编排层来通过组合和编排已经有的服务去构建更负责、确切的功能。假设 <code>completeCheckout()</code> 服务会在消费者在检查完后按下 <code>Pay</code> 这个按钮后触发，这张图展示了 <code>completeCheckout()</code> 是一个三个步骤组成的操作：</p><ol><li>第一步，调用 <code>checkoutService/pay</code> 来完成事务。</li><li>第二步，当已经成功付款后，我们需要告诉购物车服务那些商品已经被购买了，需要从购物车中移除，通过调用 <code>cartService/delete</code> 来完成。</li><li>同时，当付款完成后，我们需要更新商品的可购买数量，使用 <code>productService/update</code> 来完成。</li></ol><p>可以看到我们通过组合了一系列操作来构建另一个新的 <code>API</code>，来在一个一致性的状态下通过协同各个服务来维护整个系统。可以单独地为 <code>API 编排</code> 创建一个层，来解耦客户端程序，降低微服务架构的复杂度，这个和 <code>API 网关</code> 很像，但是它不仅仅是一个简单的代理，通常还暴露了与基本服务提供的 <code>API</code> 不同的 <code>API</code>。</p><h4 id="Integration-with-a-message-broker-集成一个消息代理"><a href="#Integration-with-a-message-broker-集成一个消息代理" class="headerlink" title="Integration with a message broker(集成一个消息代理)"></a>Integration with a message broker(集成一个消息代理)</h4><p>编排模式概率我们一个已特定方式组合若干个服务的机制。它有它的优点，也有缺点。它容易设计、容易调试、容易扩展，但是又需要对整个架构有个清楚地认识，对每个服务怎么工作要了解。可以发现，<code>orchestration</code> 层知道了且做了太多东西了，导致了高耦合、低内聚、高复杂度。</p><p>接下来我们要讲的模式就解决了 <code>API 编排</code> 带来的问题，可以不用知道各个服务的细节就能同步系统的信息，解决方案就是使用一个消息代理，实现一个中心化的 “发布/订阅” 模式。</p><p><img src="/assets/img/message_broker.png" alt="message broker"></p><p>可以发现，现在 <code>Checkout</code> 服务只用管自己的事情了(检查清单并从消费者取走钱)，其他集成的工作都是在后台做了：</p><ol><li>商店前端通过 <code>Checkout</code> 服务调用 <code>checkoutService/pay</code> 操作。</li><li>当操作完成时，<code>Checkout</code> 服务生成了一个包含了该操作细节的事件，<code>cartId</code> 和购买的商品列表。这个事件被发布到消息代理中，<code>Checkout</code> 服务并不知道谁会收到这条消息。</li><li><code>Cart</code> 服务向消息代理订阅了这类事件，所以它会受到 <code>Checkout</code> 服务发出的购买事件，然后根据携带的 <code>cartId</code> 和商品列表清空购物车。</li><li>同样的，<code>Products</code> 服务也订阅了该类事件，然后收到消息，更新商品的库存。</li></ol><p>可以看到这种模式大大降低了系统的耦合度，并且能完成消息的同步，同时也降低了复杂度。消息代理也可以提供其他有意思的功能，例如持久的消息队列，保证消息到来的顺序等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Scalability-an-Architectural-Patterns-可扩展性和架构模式&quot;&gt;&lt;a href=&quot;#Scalability-an-Architectural-Patterns-可扩展性和架构模式&quot; class=&quot;headerlink&quot; title=&quot;Scalability an Architectural Patterns(可扩展性和架构模式)&quot;&gt;&lt;/a&gt;Scalability an Architectural Patterns(可扩展性和架构模式)&lt;/h1&gt;&lt;h2 id=&quot;An-introduction-to-application-scaling-应用扩展介绍&quot;&gt;&lt;a href=&quot;#An-introduction-to-application-scaling-应用扩展介绍&quot; class=&quot;headerlink&quot; title=&quot;An introduction to application scaling(应用扩展介绍)&quot;&gt;&lt;/a&gt;An introduction to application scaling(应用扩展介绍)&lt;/h2&gt;&lt;h3 id=&quot;Scaling-Node-js-applications-扩展-Node-js-应用&quot;&gt;&lt;a href=&quot;#Scaling-Node-js-applications-扩展-Node-js-应用&quot; class=&quot;headerlink&quot; title=&quot;Scaling Node.js applications(扩展 Node.js 应用)&quot;&gt;&lt;/a&gt;Scaling Node.js applications(扩展 Node.js 应用)&lt;/h3&gt;&lt;p&gt;我们知道 &lt;code&gt;Node.js&lt;/code&gt; 是单线程的，得益于事件循环，我们可以使用单线程来处理成千上万的请求。假如我们的设备够好的话，那么单线程将成为性能瓶颈，尽管服务可以更强大。因此我们想要使用 &lt;code&gt;Node.js&lt;/code&gt; 来开发高负载的应用程序，唯一的方法就是通过多进程、多设备来扩展。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第九章</title>
    <link href="http://1016990109.github.io/2018/10/03/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/10/03/Node-js-设计模式读书笔记-第九章/</id>
    <published>2018-10-03T01:07:37.000Z</published>
    <updated>2018-10-06T11:39:05.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Advanced-Asynchronous-Recipes-高级异步方法"><a href="#Advanced-Asynchronous-Recipes-高级异步方法" class="headerlink" title="Advanced Asynchronous Recipes(高级异步方法)"></a>Advanced Asynchronous Recipes(高级异步方法)</h1><h2 id="Requiring-aysnchronously-initialized-modules-引入异步初始化的模块"><a href="#Requiring-aysnchronously-initialized-modules-引入异步初始化的模块" class="headerlink" title="Requiring aysnchronously initialized modules(引入异步初始化的模块)"></a>Requiring aysnchronously initialized modules(引入异步初始化的模块)</h2><p>第二章中我们了解到，<code>require</code> 是同步的，是不能异步更改 <code>module.exports</code> 的，所以很多核心模块都包含了同步的 <code>API</code>。但是有时候同步不一定有条件，例如在初始化的过程中需要请求网络获取某些参数，很多数据库、中间件(例如消息队列)等就是这种。</p><a id="more"></a><h3 id="Canonical-solutions-权威方案"><a href="#Canonical-solutions-权威方案" class="headerlink" title="Canonical solutions(权威方案)"></a>Canonical solutions(权威方案)</h3><p>我们举一个例子：一个名为 <code>db</code> 的模块，它将会连接到远程数据库。只有在连接和与服务器的握手完成之后，<code>db</code> 模块才能够接受请求。在这种情况下，我们通常有两种选择：</p><ul><li>在开始使用之前确保模块已经初始化，否则则等待其初始化。每当我们想要在异步模块上调用一个操作时，都必须完成这个过程：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'aDb'</span>) <span class="comment">//The async module</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">findAll</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (db.connected) &#123;</span><br><span class="line">    <span class="comment">//is it initialized?</span></span><br><span class="line">    runFind()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    db.once(<span class="string">'connected'</span>, runFind)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">runFind</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    db.findAll(type, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另外一种就是<strong>依赖注入</strong>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块app.js</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'aDb'</span>) <span class="comment">// aDb是一个异步模块</span></span><br><span class="line"><span class="keyword">const</span> findAllFactory = <span class="built_in">require</span>(<span class="string">'./findAll'</span>)</span><br><span class="line">db.on(<span class="string">'connected'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> findAll = findAllFactory(db)</span><br><span class="line">  <span class="comment">// 之后再执行异步操作</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块findAll.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//db 在这里被初始化</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">findAll</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">    db.findAll(type, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种依赖数量过多时不适用，而第二种会变得比较复杂。</p><h3 id="Preinitialization-queue-预初始化队列"><a href="#Preinitialization-queue-预初始化队列" class="headerlink" title="Preinitialization queue(预初始化队列)"></a>Preinitialization queue(预初始化队列)</h3><p>将模块与依赖项的初始化状态分离的简单模式涉及到使用队列和命令模式。这个想法是保存一个模块在尚未初始化的时候接收到的所有操作，然后在所有初始化步骤完成后立即执行这些操作。</p><h4 id="Implementing-a-module-that-initializes-asynchronously-实现一个异步初始化的模块"><a href="#Implementing-a-module-that-initializes-asynchronously-实现一个异步初始化的模块" class="headerlink" title="Implementing a module that initializes asynchronously(实现一个异步初始化的模块)"></a>Implementing a module that initializes asynchronously(实现一个异步初始化的模块)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncModule = <span class="built_in">module</span>.exports</span><br><span class="line"></span><br><span class="line">asyncModule.initialized = <span class="literal">false</span></span><br><span class="line">asyncModule.initialize = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    asyncModule.initialized = <span class="literal">true</span></span><br><span class="line">    callback()</span><br><span class="line">  &#125;, <span class="number">10000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncModule.tellMeSomething = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!asyncModule.initialized) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"I don't have anything to say right now"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    callback(<span class="literal">null</span>, <span class="string">'Current time is: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法时检查是否已经初始化(根据 <code>initialized</code> 变量判断)，未初始化则抛出异常。</p><h4 id="Wrapping-the-module-with-preinitialization-queues-使用预初始化序列包装模块"><a href="#Wrapping-the-module-with-preinitialization-queues-使用预初始化序列包装模块" class="headerlink" title="Wrapping the module with preinitialization queues(使用预初始化序列包装模块)"></a>Wrapping the module with preinitialization queues(使用预初始化序列包装模块)</h4><p>为了维护服务器的鲁棒性，我们现在要通过使用我们在本节开头描述的模式来进行异步模块加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asyncModuleWrapper.js</span></span><br><span class="line"><span class="keyword">const</span> asyncModule = <span class="built_in">require</span>(<span class="string">'./asyncModule'</span>)</span><br><span class="line"><span class="keyword">const</span> asyncModuleWrapper = <span class="built_in">module</span>.exports</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储执行队列，待初始化完成后执行</span></span><br><span class="line"><span class="keyword">let</span> pending = []</span><br><span class="line"><span class="comment">//初始化完成后替换为原模块，不需要再放到执行队列中了，也就是 pending 中</span></span><br><span class="line"><span class="keyword">let</span> initializedState = asyncModule</span><br><span class="line"><span class="comment">//真正的执行体</span></span><br><span class="line"><span class="keyword">let</span> activeState = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当模块没有被初始化时的状态</span></span><br><span class="line"><span class="keyword">let</span> notInitializedState = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    asyncModule.initialize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      asyncModuleWrapper.initalized = <span class="literal">true</span></span><br><span class="line">      activeState = initializedState</span><br><span class="line"></span><br><span class="line">      pending.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">        asyncModule[req.method].apply(<span class="literal">null</span>, req.args)</span><br><span class="line">      &#125;)</span><br><span class="line">      pending = []</span><br><span class="line"></span><br><span class="line">      callback()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  tellMeSomething: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pending.push(&#123;</span><br><span class="line">      method: <span class="string">'tellMeSomething'</span>,</span><br><span class="line">      args: <span class="built_in">arguments</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">activeState = notInitializedState</span><br><span class="line"></span><br><span class="line">asyncModuleWrapper.initialized = <span class="literal">false</span></span><br><span class="line">asyncModuleWrapper.initialize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  activeState.initialize.apply(activeState, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">asyncModuleWrapper.tellMeSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  activeState.tellMeSomething.apply(activeState, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="In-the-wild-其他场景"><a href="#In-the-wild-其他场景" class="headerlink" title="In the wild(其他场景)"></a>In the wild(其他场景)</h4><p>我们刚刚介绍的模式被许多数据库驱动程序和 <code>ORM</code> 库所使用。最值得注意的是 <code>Mongoose</code>，它是 <code>MongoDB</code> 的 <code>ORM</code>。使用 <code>Mongoose</code>，不必等待数据库连接打开，以便能够发送查询，因为每个操作都排队，稍后与数据库的连接完全建立时执行。这显然提高了其 <code>API</code> 的可用性。详情可看 <a href="https://github.com/Automattic/mongoose/blob/21f16c62e2f3230fe616745a40f22b4385a11b11/lib/drivers/node-mongodb-native/collection.js#L103-138" target="_blank" rel="noopener">Mongoose 源码</a>。</p><h2 id="Asynchronous-batching-and-caching-异步批处理和缓存"><a href="#Asynchronous-batching-and-caching-异步批处理和缓存" class="headerlink" title="Asynchronous batching and caching(异步批处理和缓存)"></a>Asynchronous batching and caching(异步批处理和缓存)</h2><h3 id="Implementing-a-server-with-no-caching-or-batching-实现一个没有批处理和缓存的服务器"><a href="#Implementing-a-server-with-no-caching-or-batching-实现一个没有批处理和缓存的服务器" class="headerlink" title="Implementing a server with no caching or batching(实现一个没有批处理和缓存的服务器)"></a>Implementing a server with no caching or batching(实现一个没有批处理和缓存的服务器)</h3><p>考虑一个管理电子商务公司销售的 <code>web</code> 服务器，特别是对于查询我们的服务器所有特定类型的商品交易的总和的情况。为此，考虑到 <code>LevelUP</code> 的简单性和灵活性，我们将再次使用 <code>LevelUP</code>。我们要使用的数据模型是存储在 <code>sales</code> 这一个 <code>sublevel</code> 中的简单事务列表，它是以下的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transactionId &#123;amount, item&#125;</span><br></pre></td></tr></table></figure><p><code>key</code> 由 <code>transactionId</code> 表示，<code>value</code> 则是一个 <code>JSON</code> 对象，它包含 <code>amount</code>，表示销售金额和 <code>item</code>，表示项目类型。要处理的数据是非常基本的，所以让我们立即在名为的 <code>totalSales.js</code> 文件中实现 <code>API</code>，将如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> level = <span class="built_in">require</span>(<span class="string">'level'</span>)</span><br><span class="line"><span class="keyword">const</span> sublevel = <span class="built_in">require</span>(<span class="string">'level-sublevel'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = sublevel(level(<span class="string">'example-db'</span>, &#123; <span class="attr">valueEncoding</span>: <span class="string">'json'</span> &#125;))</span><br><span class="line"><span class="keyword">const</span> salesDb = db.sublevel(<span class="string">'sales'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">totalSales</span>(<span class="params">item, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'totalSales() invoked'</span>)</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  salesDb</span><br><span class="line">    .createValueStream() <span class="comment">// [1]</span></span><br><span class="line">    .on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!item || data.item === item) &#123;</span><br><span class="line">        <span class="comment">// [2]</span></span><br><span class="line">        sum += data.amount</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">      callback(<span class="literal">null</span>, sum) <span class="comment">// [3]</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了完成总销售应用程序，我们只需要从 <code>HTTP</code> 服务器公开 <code>totalSales</code> 的 <code>API</code>；所以，下一步是构建一个（<code>app.js</code> 文件）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">const</span> totalSales = <span class="built_in">require</span>(<span class="string">'./totalSales'</span>)</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> query = url.parse(req.url, <span class="literal">true</span>).query</span><br><span class="line">    totalSales(query.item, (err, sum) =&gt; &#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>)</span><br><span class="line">      res.end(<span class="string">`Total sales for item <span class="subst">$&#123;query.item&#125;</span> is <span class="subst">$&#123;sum&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Started'</span>))</span><br></pre></td></tr></table></figure><h4 id="Asynchronous-request-batching-批量异步处理"><a href="#Asynchronous-request-batching-批量异步处理" class="headerlink" title="Asynchronous request batching(批量异步处理)"></a>Asynchronous request batching(批量异步处理)</h4><p>如果请求相同的异步 <code>API</code> 并且输入相同，那么可以考虑批处理。如果我们在调用异步函数的同时还有另一个正在处理的相同请求，我们可以将这次的回调函数附加到已经运行的操作(也就是异步操作))上，而不是创建一个全新的请求。看下面这张图：</p><p><img src="/assets/img/asynchronous_request_batching.png" alt="asynchronous request batching"></p><p>对两个请求执行到相同的操作。通过这样做，当操作完成时，两个客户端将同时被通知。这代表了一种简单而又非常强大的方式来降低应用程序的负载，而不必处理更复杂的缓存机制，这通常需要适当的内存管理和缓存失效策略。</p><h4 id="Batching-requests-in-the-total-sales-web-server-在销售总量-web-服务器中批量处理请求"><a href="#Batching-requests-in-the-total-sales-web-server-在销售总量-web-服务器中批量处理请求" class="headerlink" title="Batching requests in the total sales web server(在销售总量 web 服务器中批量处理请求)"></a>Batching requests in the total sales web server(在销售总量 web 服务器中批量处理请求)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> totalSales = <span class="built_in">require</span>(<span class="string">'./totalSales'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queues = &#123;&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">totalSalesBatch</span>(<span class="params">item, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queues[item]) &#123;</span><br><span class="line">    <span class="comment">// [1]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Batching operation'</span>)</span><br><span class="line">    <span class="keyword">return</span> queues[item].push(callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queues[item] = [callback] <span class="comment">// [2]</span></span><br><span class="line">  totalSales(item, (err, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = queues[item] <span class="comment">// [3]</span></span><br><span class="line">    queues[item] = <span class="literal">null</span></span><br><span class="line">    queue.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(err, res))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果请求的 <code>item</code> 已经存在队列中，则意味着该特定 <code>item</code> 的请求已经在服务器任务队列中。在这种情况下，我们所要做的只是将回调 <code>push</code> 到现有队列，并立即从调用中返回。不进行后续操作。</li><li>如果请求的 <code>item</code> 没有在队列中，这意味着我们必须创建一个新的请求。为此，我们为该特定 <code>item</code> 的请求创建一个新队列，并使用当前回调函数对其进行初始化。接下来，我们调用原始的 <code>totalSales()</code> <code>API</code>。</li><li>当原始的 <code>totalSales()</code> 请求完成时，则执行我们的回调函数，我们遍历队列中为该特定请求的 <code>item</code> 添加的所有回调，并分别调用这些回调函数。</li></ol><h3 id="Asynchronous-request-caching-异步请求缓存"><a href="#Asynchronous-request-caching-异步请求缓存" class="headerlink" title="Asynchronous request caching(异步请求缓存)"></a>Asynchronous request caching(异步请求缓存)</h3><p>对于一个有经验的开发人员来说，缓存不应该是多么新的技术，但是异步编程中这种模式的不同之处在于它应该与批处理结合在一起，以达到最佳效果。原因是因为多个请求可能并发运行，而没有设置缓存，并且当这些请求完成时，缓存将会被设置多次，这样做则会造成缓存资源的浪费。</p><p>基于这些假设，异步请求缓存模式的最终结构如下图所示：</p><p><img src="/assets/img/asynchronous_request_caching.png" alt="asynchronous request caching"></p><p>上图给出了最佳异步缓存算法的两个步骤：</p><ol><li>与批处理模式完全相同，与在未设置高速缓存时接收到的任何请求将一起批处理。这些请求完成时，缓存将会被设置一次。</li><li>当缓存最终被设置时，任何后续的请求都将直接从缓存中提供。</li></ol><h4 id="Caching-requests-in-the-total-sales-web-server-在销售总量-web-服务器中缓存请求"><a href="#Caching-requests-in-the-total-sales-web-server-在销售总量-web-服务器中缓存请求" class="headerlink" title="Caching requests in the total sales web server(在销售总量 web 服务器中缓存请求)"></a>Caching requests in the total sales web server(在销售总量 web 服务器中缓存请求)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//totalSalesCache.js</span></span><br><span class="line"><span class="keyword">const</span> totalSales = <span class="built_in">require</span>(<span class="string">'./totalSales'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queues = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">totalSalesBatch</span>(<span class="params">item, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cached = cache[item]</span><br><span class="line">  <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Cache hit'</span>)</span><br><span class="line">    <span class="comment">//注意还是需要异步返回，缓存可能是异步设定的，这样保证一定能取到缓存</span></span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback.bind(<span class="literal">null</span>, <span class="literal">null</span>, cached))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queues[item]) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Batching operation'</span>)</span><br><span class="line">    <span class="keyword">return</span> queues[item].push(callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queues[item] = [callback]</span><br><span class="line">  totalSales(item, (err, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">      cache[item] = res</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> cache[item]</span><br><span class="line">      &#125;, <span class="number">30</span> * <span class="number">1000</span>) <span class="comment">//30 seconds expiry</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = queues[item]</span><br><span class="line">    queues[item] = <span class="literal">null</span></span><br><span class="line">    queue.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(err, res))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Notes-about-implementing-caching-mechanisms-有关缓存实现机制的说明"><a href="#Notes-about-implementing-caching-mechanisms-有关缓存实现机制的说明" class="headerlink" title="Notes about implementing caching mechanisms(有关缓存实现机制的说明)"></a>Notes about implementing caching mechanisms(有关缓存实现机制的说明)</h4><p>我们必须记住，在实际应用中，我们可能想要使用更先进的失效技术和存储机制。 这可能是必要的，原因如下：</p><ol><li>大量的缓存值可能会消耗大量内存。 在这种情况下，可以应用 <code>Least Recently Used</code>（<code>LRU</code>）算法来保持恒定的存储器利用率。</li><li>当应用程序分布在多个进程中时，对缓存使用简单变量可能会导致每个服务器实例返回不同的结果。如果这对于我们正在实现的特定应用程序来说是不希望的，那么解决方案就是使用共享存储来存储缓存。 常用的解决方案是 <code>Redis</code>(<a href="http://redis.io" target="_blank" rel="noopener">http://redis.io</a>) 和 <code>Memcached</code>(<a href="http://memcached.org" target="_blank" rel="noopener">http://memcached.org</a>)。</li><li>与定时淘汰缓存相比，手动淘汰高速缓存可使得高速缓存使用寿命更长，同时提供更新的数据，但当然，管理起缓存来要复杂得多。</li></ol><h3 id="Batching-and-caching-with-promises-使用-Promise-来批处理和缓存"><a href="#Batching-and-caching-with-promises-使用-Promise-来批处理和缓存" class="headerlink" title="Batching and caching with promises(使用 Promise 来批处理和缓存)"></a>Batching and caching with promises(使用 Promise 来批处理和缓存)</h3><p>利用 <code>Promise</code> 进行异步批处理和缓存策略，有如下两个优点：</p><ul><li>多个 <code>then()</code> 监听器可以附加到相同的 <code>Promise</code> 实例。</li><li><code>then()</code> 监听器最多保证被调用一次，即使在 <code>Promise</code> 已经被 <code>resolve</code> 了之后，<code>then()</code> 也能正常工作。此外，<code>then()</code> 总是会被保证其是异步调用的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pify = <span class="built_in">require</span>(<span class="string">'pify'</span>)</span><br><span class="line"><span class="keyword">const</span> totalSales = pify(<span class="built_in">require</span>(<span class="string">'./totalSales'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">totalSalesPromises</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[item]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[item]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cache[item] = totalSales(item)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> cache[item]</span><br><span class="line">      &#125;, <span class="number">30</span> * <span class="number">1000</span>) <span class="comment">//30 seconds expiry</span></span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> cache[item]</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> cache[item]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Running-CPU-bound-tasks-运行-CPU-密集型任务"><a href="#Running-CPU-bound-tasks-运行-CPU-密集型任务" class="headerlink" title="Running CPU-bound tasks(运行 CPU 密集型任务)"></a>Running CPU-bound tasks(运行 CPU 密集型任务)</h2><p>当我们运行一个长时间的同步任务时，<code>Node.js</code> 会一直处于阻塞的状态，控制权不会还给事件循环，那么就无法处理多个请求了。</p><h3 id="使用-setIntermediate"><a href="#使用-setIntermediate" class="headerlink" title="使用 setIntermediate"></a>使用 setIntermediate</h3><p>通常，<code>CPU-bound</code> 算法是建立在一定规则之上的。它可以是一组递归调用，一个循环，或者基于这些的任何变化/组合。所以，对于我们的问题，一个简单的解决方案就是在这些步骤完成后（或者在一定数量的步骤之后），将控制权交还给事件循环。这样，任何待处理的 <code>I/O</code> 仍然可以在事件循环在长时间运行的算法产生 <code>CPU</code> 的时间间隔中处理。对于这个问题而言，解决这一问题的方式是把算法的下一步在任何可能导致挂起的 <code>I/O</code> 请求之后运行。</p><p>最简单的方法就是使用 <code>setIntermediate</code> 来将控制权还给事件循环。</p><p><strong>交错模式</strong></p><p>正如我们所看到的，在保持应用程序的响应性的同时运行一个 <code>CPU-bound</code> 的任务并不复杂，只需要使用 <code>setImmediate()</code> 把同步执行的代码变为异步执行即可。但是，这不是效率最好的模式；实际上，延迟执行一个任务会额外带来一个小的开销，在这样的算法中，积少成多，则会产生重大的影响。这通常是我们在运行 <code>CPU</code> 限制任务时所需要的最后一件事情，特别是如果我们必须将结果直接返回给用户，这应该在合理的时间内进行响应。缓解这个问题的一个可能的解决方案是只有在一定数量的步骤之后使用 <code>setImmediate()</code>，而不是在每一步中使用它。但是这仍然不能解决问题的根源。</p><p>记住，这并不是说一旦我们想要通过异步的模式来执行 <code>CPU-bound</code> 的任务，我们就应该不惜一切代价来避免这样的额外开销，事实上，从更广阔的角度来看，同步任务并不一定非常漫长和复杂，以至于造成麻烦。在繁忙的服务器中，即使是阻塞事件循环 200 毫秒的任务也会产生不希望的延迟。在那些并发量并不高的服务器来说，即使产生一定短时的阻塞，也不会影响性能，使用交错执行 <code>setImmediate()</code> 可能是避免阻塞事件循环的最简单也是最有效的方法。</p><blockquote><p><code>process.nextTick()</code> 不能用于交错长时间运行的任务。nextTick()会在任何未返回的 <code>I/O</code> 之前调度，并且在重复调用 <code>process.nextTick()</code> 最终会导致 <code>I/O</code> 饥饿。</p></blockquote><h3 id="使用多进程"><a href="#使用多进程" class="headerlink" title="使用多进程"></a>使用多进程</h3><p>防止事件循环阻塞的另一种模式是使用子进程。</p><p><code>Node.js</code> 有一个充足的 <code>API</code> 库带来与外部进程交互。我们可以在 <code>child_process</code> 模块中找到我们需要的所有东西。而且，当外部进程只是另一个 <code>Node.js</code> 程序时，将它连接到主应用程序是非常容易的，我们甚至不觉得我们在本地应用程序外部运行任何东西。这得益于 <code>child_process.fork()</code> 函数，该函数创建一个新的子 <code>Node.js</code> 进程，并自动创建一个通信管道，使我们能够使用与 <code>EventEmitter</code> 非常相似的接口交换信息。</p><p>关于多进程的使用及如何通信和查看 <a href="https://nodejs.org/dist/latest-v10.x/docs/api/child_process.html" target="_blank" rel="noopener">Child Processes</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Advanced-Asynchronous-Recipes-高级异步方法&quot;&gt;&lt;a href=&quot;#Advanced-Asynchronous-Recipes-高级异步方法&quot; class=&quot;headerlink&quot; title=&quot;Advanced Asynchronous Recipes(高级异步方法)&quot;&gt;&lt;/a&gt;Advanced Asynchronous Recipes(高级异步方法)&lt;/h1&gt;&lt;h2 id=&quot;Requiring-aysnchronously-initialized-modules-引入异步初始化的模块&quot;&gt;&lt;a href=&quot;#Requiring-aysnchronously-initialized-modules-引入异步初始化的模块&quot; class=&quot;headerlink&quot; title=&quot;Requiring aysnchronously initialized modules(引入异步初始化的模块)&quot;&gt;&lt;/a&gt;Requiring aysnchronously initialized modules(引入异步初始化的模块)&lt;/h2&gt;&lt;p&gt;第二章中我们了解到，&lt;code&gt;require&lt;/code&gt; 是同步的，是不能异步更改 &lt;code&gt;module.exports&lt;/code&gt; 的，所以很多核心模块都包含了同步的 &lt;code&gt;API&lt;/code&gt;。但是有时候同步不一定有条件，例如在初始化的过程中需要请求网络获取某些参数，很多数据库、中间件(例如消息队列)等就是这种。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Node.js 设计模式》读书笔记 第八章</title>
    <link href="http://1016990109.github.io/2018/09/25/Node-js-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://1016990109.github.io/2018/09/25/Node-js-设计模式读书笔记-第八章/</id>
    <published>2018-09-25T03:54:47.000Z</published>
    <updated>2018-10-03T07:54:28.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Universal-JavaScript-for-Web-Applications-Web-应用的通用-JavaScript"><a href="#Universal-JavaScript-for-Web-Applications-Web-应用的通用-JavaScript" class="headerlink" title="Universal JavaScript for Web Applications(Web 应用的通用 JavaScript)"></a>Universal JavaScript for Web Applications(Web 应用的通用 JavaScript)</h1><h2 id="Sharing-code-with-browser-和浏览器共享代码"><a href="#Sharing-code-with-browser-和浏览器共享代码" class="headerlink" title="Sharing code with browser(和浏览器共享代码)"></a>Sharing code with browser(和浏览器共享代码)</h2><h3 id="Universal-Module-Definition-UMD"><a href="#Universal-Module-Definition-UMD" class="headerlink" title="Universal Module Definition(UMD)"></a>Universal Module Definition(UMD)</h3><p>一般来说需要同时满足浏览器和服务端要求，最常用的就是使用 <code>UMD</code> 规范了，<code>umd</code> 是 <code>AMD</code> 和 <code>CommonJS</code> 的糅合。先判断是否支持 <code>AMD</code>（通过判断 <code>define</code> 是否存在），存在则使用 <code>AMD</code> 方式加载模块。再判断是否支持 <code>Node.js</code> 的模块（<code>exports</code>）是否存在，存在则使用 <code>Node.js</code> 模块模式。如果两个都不存在，那么可能就使用全局变量来定义了(一般根据传入的 <code>root</code>，可能是执行的 <code>this</code>)。</p><a id="more"></a><p>给个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define([<span class="string">'mustache'</span>], factory)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> mustache = <span class="built_in">require</span>(<span class="string">'mustache'</span>)</span><br><span class="line">    <span class="built_in">module</span>.exports = factory(mustache)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.UmdModule = factory(root.Mustache)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">mustache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> template = <span class="string">'&lt;h1&gt;Hello &lt;i&gt;&#123;&#123;name&#125;&#125;&lt;/i&gt;&lt;/h1&gt;'</span></span><br><span class="line">  mustache.parse(template)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">toWhom</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mustache.render(template, &#123; <span class="attr">name</span>: toWhom &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="ES2015-Modules"><a href="#ES2015-Modules" class="headerlink" title="ES2015 Modules"></a>ES2015 Modules</h3><p><code>ES2015</code> 模块充分利用了 <code>AMD</code> 和 <code>CommonJS</code> 的优点：</p><ul><li>像 <code>CommonJS</code> 一样，<code>ES2015</code> 模块提供了简洁的语法，单独使用 <code>export</code> 导出模块而不用 <code>module.export = ...</code>，并且支持循环依赖。</li><li>像 <code>AMD</code> 一样，<code>ES2015</code> 模块直接就支持异步模块加载和可配置模块加载。</li></ul><h2 id="Introducing-Webpack-Webpack-介绍"><a href="#Introducing-Webpack-Webpack-介绍" class="headerlink" title="Introducing Webpack(Webpack 介绍)"></a>Introducing Webpack(Webpack 介绍)</h2><p><code>Webpack</code> 帮助我们将用 <code>Node.js</code> 模块规范些的代码编译成能在浏览器上运行的代码，解决了 <code>require</code> 在浏览器中的问题(浏览器是没有 <code>require</code> 函数的)。</p><p>上面的 <code>UMD</code> 代码变得更简洁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mustache = <span class="built_in">require</span>(<span class="string">'mustache'</span>)</span><br><span class="line"><span class="keyword">var</span> template = <span class="string">'&lt;h1&gt;Hello &lt;i&gt;&#123;&#123;name&#125;&#125;&lt;/i&gt;&lt;/h1&gt;'</span></span><br><span class="line">mustache.parse(template)</span><br><span class="line"><span class="built_in">module</span>.exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">toWhom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustache.render(template, &#123; <span class="attr">name</span>: toWhom &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>自动提供 <code>Node.js</code> 核心模块的浏览器兼容，如 <code>http</code>、<code>assert</code>、<code>events</code> 等等。<code>fs</code> 模块是不支持的。</li><li>如果不自动支持，可以手动引入兼容包，也就是 <code>polyfill</code> 这类的。</li><li>能从不同模块生成 <code>bundles</code>。</li><li>对源文件可做额外的操作，利用 <code>loaders</code> 和 <code>plugins</code> 来完成。</li><li>可以非常容易地通过任务执行管理器(例如 <code>Gulp</code> 或 <code>Grunt</code>)来执行 <code>Webpack</code>。</li><li>可以管理除 <code>JS</code> 文件外的文件预处理，如样式表文件、图片、字体、模板等等。</li><li>配置 <code>Webpack</code> 来分离依赖，组织代码为多个 <code>chunk</code>，做到动态加载，等需要的时候再加载。</li></ol><h3 id="Using-ES2015-with-Webpack-在-Webpack-中使用-ES2015"><a href="#Using-ES2015-with-Webpack-在-Webpack-中使用-ES2015" class="headerlink" title="Using ES2015 with Webpack(在 Webpack 中使用 ES2015)"></a>Using ES2015 with Webpack(在 Webpack 中使用 ES2015)</h3><p>前面有说到利用 <code>loaders</code> 和 <code>plugins</code> 来做额外的做操作，这里就利用 <code>babel-loader</code> 来将 <code>ES6</code> 的语法转为 <code>ES5</code>，只需要在 <code>webpack.config.js</code> 中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'src'</span>, <span class="string">'main.js'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: path.join(__dirname, <span class="string">'src'</span>),</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fundamentals-of-cross-platform-development-跨平台开发基础"><a href="#Fundamentals-of-cross-platform-development-跨平台开发基础" class="headerlink" title="Fundamentals of cross-platform development(跨平台开发基础)"></a>Fundamentals of cross-platform development(跨平台开发基础)</h2><p>为不同平台开发最主要的一个问题就是如何共享一个组件的公共部分(除去平台特定的部分)。</p><h3 id="Runtime-code-branching-运行时代码分支"><a href="#Runtime-code-branching-运行时代码分支" class="headerlink" title="Runtime code branching(运行时代码分支)"></a>Runtime code branching(运行时代码分支)</h3><p>当需要对平台定制化代码时，很容易就想到要根据当前的环境来加载不同的模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.document) &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'clientModule'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'serverModule'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这有个问题就是，所有的模块都会被打包进去，会导致最终代码的大小太大。</p><h3 id="Build-time-code-branching-编译时代码分支"><a href="#Build-time-code-branching-编译时代码分支" class="headerlink" title="Build-time code branching(编译时代码分支)"></a>Build-time code branching(编译时代码分支)</h3><p>使用 <code>Webpack</code> 可以在编译时就将代码进行分割，只讲需要用的代码打包进最终包。</p><p>为了完成编译时代码分支，我们使用了两个内置的插件 <code>DefinePlugin</code> 和 <code>UglifyJsPlugin</code> 连接的管道。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> __BROWSER__ !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hey browser!'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hey Node.js!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> definePlugin = <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">  <span class="string">"__BROWSER__"</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uglifyJsPlugin = <span class="keyword">new</span> webpack.UglifyJsPlugin(&#123;</span><br><span class="line">  beautify: <span class="literal">true</span>,</span><br><span class="line">  dead_code: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'src'</span>, <span class="string">'main.js'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [definePlugin, uglifyJsPlugin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefinePlugin</code> 用来定义一个在源代码中能访问的一个全局变量，<code>UglifyJsPlugin</code> 用来减少最终生成的代码体积(因为去除了<strong>无用代码</strong>，这是在运行时代码分支里存在的问题，当然同时会去除掉一些空格之类的空白字符以及替换变量名等等)。</p><blockquote><p>需要注意的是，<code>DefinePlugin</code> 其实是在编译的时候找到源码中所有的 <code>__BROWSER__</code> 变量，然后将其替换为 <code>true</code>，和普通地声明一个全局变量不同。</p></blockquote><h3 id="Module-swapping-模块交换"><a href="#Module-swapping-模块交换" class="headerlink" title="Module swapping(模块交换)"></a>Module swapping(模块交换)</h3><p>有点时候我们会已知某些模块是不需要的，需要用其他模块来代替，这个时候再构建过程中去替换。</p><p><code>Webpack</code> 使用 <code>NormalModuleReplacementPlugin</code> 来完成这件事，匹配对应的正则表达式，然后用定义的模块替换掉匹配的模块。</p><p>这样有时候就很容易地将 <code>Node.js</code> 环境下运行的代码转换成浏览器运行的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Universal-JavaScript-for-Web-Applications-Web-应用的通用-JavaScript&quot;&gt;&lt;a href=&quot;#Universal-JavaScript-for-Web-Applications-Web-应用的通用-JavaScript&quot; class=&quot;headerlink&quot; title=&quot;Universal JavaScript for Web Applications(Web 应用的通用 JavaScript)&quot;&gt;&lt;/a&gt;Universal JavaScript for Web Applications(Web 应用的通用 JavaScript)&lt;/h1&gt;&lt;h2 id=&quot;Sharing-code-with-browser-和浏览器共享代码&quot;&gt;&lt;a href=&quot;#Sharing-code-with-browser-和浏览器共享代码&quot; class=&quot;headerlink&quot; title=&quot;Sharing code with browser(和浏览器共享代码)&quot;&gt;&lt;/a&gt;Sharing code with browser(和浏览器共享代码)&lt;/h2&gt;&lt;h3 id=&quot;Universal-Module-Definition-UMD&quot;&gt;&lt;a href=&quot;#Universal-Module-Definition-UMD&quot; class=&quot;headerlink&quot; title=&quot;Universal Module Definition(UMD)&quot;&gt;&lt;/a&gt;Universal Module Definition(UMD)&lt;/h3&gt;&lt;p&gt;一般来说需要同时满足浏览器和服务端要求，最常用的就是使用 &lt;code&gt;UMD&lt;/code&gt; 规范了，&lt;code&gt;umd&lt;/code&gt; 是 &lt;code&gt;AMD&lt;/code&gt; 和 &lt;code&gt;CommonJS&lt;/code&gt; 的糅合。先判断是否支持 &lt;code&gt;AMD&lt;/code&gt;（通过判断 &lt;code&gt;define&lt;/code&gt; 是否存在），存在则使用 &lt;code&gt;AMD&lt;/code&gt; 方式加载模块。再判断是否支持 &lt;code&gt;Node.js&lt;/code&gt; 的模块（&lt;code&gt;exports&lt;/code&gt;）是否存在，存在则使用 &lt;code&gt;Node.js&lt;/code&gt; 模块模式。如果两个都不存在，那么可能就使用全局变量来定义了(一般根据传入的 &lt;code&gt;root&lt;/code&gt;，可能是执行的 &lt;code&gt;this&lt;/code&gt;)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://1016990109.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS内存管理</title>
    <link href="http://1016990109.github.io/2018/09/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://1016990109.github.io/2018/09/13/前端基础之JS内存管理/</id>
    <published>2018-09-13T09:31:54.000Z</published>
    <updated>2018-09-13T09:43:18.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放\归还</li></ol><a id="more"></a><h3 id="JavaScript-的内存分配"><a href="#JavaScript-的内存分配" class="headerlink" title="JavaScript 的内存分配"></a>JavaScript 的内存分配</h3><ul><li>值的初始化</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span> <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'azerty'</span> <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125; <span class="comment">// 给对象及其包含的值分配内存</span></span><br></pre></td></tr></table></figure><ul><li>函数调用分配内存</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 分配一个 Date 对象</span></span><br></pre></td></tr></table></figure><h3 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h3><p>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>老的浏览器使用这种方式，比如 <code>IE 6</code>，<code>IE 7</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span> <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.a</span><br><span class="line"><span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">'yo'</span></span><br><span class="line"><span class="comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line"><span class="comment">// 他可以被垃圾回收了</span></span><br><span class="line"><span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span></span><br><span class="line"><span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line"><span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><blockquote><p>限制，当有<strong>循环引用</strong>时，则无法进行垃圾回收。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;</span><br><span class="line">  o.a = o2 <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o <span class="comment">// o2 引用 o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'azerty'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>这个算法假定设置一个叫做根（<code>root</code>）的对象（在 <code>Javascript</code> 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p><p>从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 <code>JavaScript</code> 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存生命周期&quot;&gt;&lt;a href=&quot;#内存生命周期&quot; class=&quot;headerlink&quot; title=&quot;内存生命周期&quot;&gt;&lt;/a&gt;内存生命周期&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;分配你所需要的内存&lt;/li&gt;
&lt;li&gt;使用分配到的内存（读、写）&lt;/li&gt;
&lt;li&gt;不需要时将其释放\归还&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://1016990109.github.io/tags/JS/"/>
    
      <category term="内存管理" scheme="http://1016990109.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS基本类型和引用类型</title>
    <link href="http://1016990109.github.io/2018/09/12/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://1016990109.github.io/2018/09/12/前端基础之JS基本类型和引用类型/</id>
    <published>2018-09-12T01:24:47.000Z</published>
    <updated>2018-09-12T06:48:33.640Z</updated>
    
    <content type="html"><![CDATA[<p><code>JS</code> 中一个变量可以存放两种类型的值：基本类型和引用类型。</p><a id="more"></a><p><code>JS</code> 数据类型有 7 种(<code>ES6</code> 新增一种 <code>Symbol</code>):</p><p>基本类型(原始类型)：</p><ul><li><code>Boolean</code></li><li><code>Null</code></li><li><code>Undefined</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Symbol</code> (<code>ECMAScript</code> 6 新定义)，符号类型是唯一的并且是不可修改的</li></ul><p>引用类型(复杂类型)：</p><ul><li><code>Object</code></li></ul><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型的值是按值访问</p><h3 id="基本类型的值是不可变的"><a href="#基本类型的值是不可变的" class="headerlink" title="基本类型的值是不可变的"></a>基本类型的值是不可变的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'123hello321'</span></span><br><span class="line">str.toUpperCase() <span class="comment">// 123HELLO321</span></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// 123hello321</span></span><br></pre></td></tr></table></figure><h3 id="基本类型的比较是它们的值的比较"><a href="#基本类型的比较是它们的值的比较" class="headerlink" title="基本类型的比较是它们的值的比较"></a>基本类型的比较是它们的值的比较</h3><p>不同类型之间也可以比较，因为做了隐式转换。涉及隐式转换最多的两个运算符 <code>+</code> 和 <code>==</code>。</p><p>隐式转换中主要涉及到三种转换：</p><ol><li>将值转为原始值，<code>ToPrimitive()</code>。</li><li>将值转为数字，<code>ToNumber()</code>。</li><li>将值转为字符串，<code>ToString()</code>。</li></ol><p><strong>通过 ToPrimitive 将值转换为原始值</strong></p><p><code>ToPrimitive(input, PreferredType?)</code></p><p><code>input</code> 是要转换的值，<code>PreferredType</code> 是可选参数，可以是 <code>Number</code> 或 <code>String</code> 类型。他只是一个转换标志，转化后的结果并不一定是这个参数所值的类型，但是转换结果一定是一个原始值（或者报错）。</p><p>如果 <code>PreferredType</code> 被标记为 <code>Number</code>，那么先是调用 <code>valueOf</code> 方法，如果返回值是原始值则结束；否则重新调用 <code>toString</code> 方法，如果是原始值则结束，不然就会抛出 <code>TypeError</code> 异常。<br>如果 <code>PreferredType</code> 被标记为 <code>String</code>，那么先是调用 <code>toString</code> 方法，如果返回值是原始值则结束；否则重新调用 <code>valueOf</code> 方法，如果是原始值则结束，不然就会抛出 <code>TypeError</code> 异常。(两者相反)</p><blockquote><p><code>valueOf()</code>：返回最适合该对象类型的原始值；<br><code>toString()</code>: 将该对象的原始值以字符串形式返回。</p></blockquote><blockquote><p>没有 <code>PrefferedType</code> 时，按照下面规则：如果该对象为 <code>Date</code> 类型，则 <code>PreferredType</code> 被设置为 <code>String</code>；否则，<code>PreferredType</code> 被设置为 <code>Number</code>。</p></blockquote><p><strong>通过 ToNumber 将值转换为数字</strong></p><table><thead><tr><th>参数</th><th>结果</th></tr></thead><tbody><tr><td>undefined</td><td>NaN</td></tr><tr><td>null</td><td>+0</td></tr><tr><td>布尔值</td><td>true 转为 1，false 转为</td></tr><tr><td>字符串</td><td>能解析则变为数字，否则 NaN</td></tr><tr><td>对象</td><td>先 ToPrimitive(input, Number)，再 ToNumber</td></tr></tbody></table><p><strong>通过 ToString 将值转换为字符串</strong></p><table><thead><tr><th>参数</th><th>结果</th></tr></thead><tbody><tr><td>undefined</td><td>‘undefined’</td></tr><tr><td>null</td><td>‘null’</td></tr><tr><td>布尔值</td><td>true 转为 ‘true’，false 转为 ‘false’</td></tr><tr><td>数字</td><td>直接转，NaN 变为 ‘NaN’</td></tr><tr><td>对象</td><td>先 ToPrimitive(input, String)，再 ToString</td></tr></tbody></table><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125; + &#123;&#125;) <span class="comment">//"[object Object][object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要转换为原始类型，且没有指定 PrefferedType，所以优先 ToNumber</span></span><br><span class="line"><span class="comment">//&#123;&#125;.valueOf() 结果还是 &#123;&#125;</span></span><br><span class="line"><span class="comment">//继续用ToString，&#123;&#125;.toString() 结果为 "[object Object]"</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * &#123;&#125;) <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//* 只能在 number 上运算，所以 PerfferedType 为 Number，ToPrimitive(&#123;&#125;, Number)</span></span><br><span class="line"><span class="comment">//&#123;&#125;.valueOf() 结果还是 &#123;&#125;，继续 ToString</span></span><br><span class="line"><span class="comment">//&#123;&#125;.toString() 结果为 "[object Object]"</span></span><br><span class="line"><span class="comment">//再将 "[object Object]" 转为 Number，结果为 NaN</span></span><br><span class="line"><span class="comment">//最后 2*NaN 结果还是 NaN</span></span><br></pre></td></tr></table></figure><p><strong><code>==</code> 运算符时隐式转换规则</strong></p><ol><li>x,y 为 <code>null</code>、<code>undefined</code> 两者中一个 // 返回 true</li><li>x、y 为 <code>Number</code> 和 <code>String</code> 类型时，则转换为 <code>Number</code> 类型比较。</li><li>有 <code>Boolean</code> 类型时，<code>Boolean</code> 转化为 <code>Number</code> 类型比较。</li><li>一个 <code>Object</code> 类型，一个 <code>String</code> 或 <code>Number</code> 类型，将 <code>Object</code> 类型进行原始转换后，按上面流程进行原始值比较。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  i: <span class="number">1</span>,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">//会打印</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本类型的变量是存放在栈内存（Stack）里的"><a href="#基本类型的变量是存放在栈内存（Stack）里的" class="headerlink" title="基本类型的变量是存放在栈内存（Stack）里的"></a>基本类型的变量是存放在栈内存（Stack）里的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b</span><br><span class="line">a = <span class="string">'zyj'</span></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// zyj</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// zyj</span></span><br><span class="line">a = <span class="string">'呵呵'</span> <span class="comment">// 改变 a 的值，并不影响 b 的值</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 呵呵</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// zyj</span></span><br></pre></td></tr></table></figure><p><strong>栈内存中包括了变量的标识符和变量的值。</strong></p><p><img src="/assets/img/js_primitive_type_stack.png" alt="js_primitive_type_stack"></p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>除了 6 种基本数据类型外，还要剩下的引用类型，即 <code>Object</code> 类型。细分的话，有：<code>Object 类型</code>、<code>Array 类型</code>、<code>Date 类型</code>、<code>RegExp 类型</code>、<code>Function 类型</code> 等。</p><p>引用类型的值是按引用访问的。</p><ul><li>引用类型的值是可变的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'zyj'</span> &#125; <span class="comment">// 创建一个对象</span></span><br><span class="line">obj.name = <span class="string">'percy'</span> <span class="comment">// 改变 name 属性的值</span></span><br><span class="line">obj.age = <span class="number">21</span> <span class="comment">// 添加 age 属性</span></span><br><span class="line">obj.giveMeAll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">' : '</span> + <span class="keyword">this</span>.age</span><br><span class="line">&#125; <span class="comment">// 添加 giveMeAll 方法</span></span><br><span class="line">obj.giveMeAll()</span><br></pre></td></tr></table></figure><ul><li>引用类型的比较是引用的比较</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125; <span class="comment">// 新建一个空对象 obj1</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125; <span class="comment">// 新建一个空对象 obj2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 == obj2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>引用类型的值是保存在堆内存（<code>Heap</code>）中的对象（<code>Object</code>）</li></ul><p>与其他编程语言不同，<code>JavaScript</code> 不能直接操作对象的内存空间（堆内存）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">'percy'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line">b = a</span><br><span class="line">a.name = <span class="string">'zyj'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.name) <span class="comment">// zyj</span></span><br><span class="line">b.age = <span class="number">22</span></span><br><span class="line"><span class="built_in">console</span>.log(a.age) <span class="comment">// 22</span></span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  name: <span class="string">'zyj'</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;JS&lt;/code&gt; 中一个变量可以存放两种类型的值：基本类型和引用类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基本数据类型" scheme="http://1016990109.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>客户端渲染 vs 服务端渲染</title>
    <link href="http://1016990109.github.io/2018/09/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <id>http://1016990109.github.io/2018/09/10/服务端渲染-客户端渲染/</id>
    <published>2018-09-10T12:03:36.000Z</published>
    <updated>2018-09-12T02:04:12.525Z</updated>
    
    <content type="html"><![CDATA[<p>在前端页面的渲染这块，近几年来感觉经历了从服务端渲染(多页面)=&gt;客户端渲染(<code>SPA</code>)=&gt;同构渲染的演变。</p><a id="more"></a><h2 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h2><p>在浏览器中通过 <code>JS</code> 直接进行页面的渲染路由跳转等操作，与后端的交互主要为 <code>API</code> 微服务接口的数据调用。得到数据后在前端进行分析处理和界面生成展现。比较代表性的为 <code>React</code>,<code>Vue</code>,<code>Angular</code> 三大前端框架的 <code>SPA(Single Page Application)</code> 应用。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>天然的浏览器分布式环境</li><li>组件复用度高，还可以通过懒加载等进行性能的进一步优化</li><li>除首屏外性能响应快速</li><li><code>WEB/MOBILE</code> 多端渲染</li><li>前后端分离开发</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>首屏性能差：由于页面渲染、三方包等逻辑都置于一个 <code>JS</code> 文件中，首屏加载会导致一定时间的白屏现象。</li><li>浏览器 <code>SEO</code>：由于现阶段大多搜索引擎采用的爬虫算法是直接抓取页面代码分析，而 <code>SPA</code> 应用只有一个入口文件而没实质内容，<code>SEO</code> 性能差。</li></ol><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>后端不仅仅进行数据的获取处理操作，同时也负责页面的生成，最终传到客户端(浏览器)的是生成的包含数据的页面。客户端所需要做的仅仅是 <code>html</code> 页面的展现和之后的 <code>DOM</code> 事件处理。代表为传统的 <code>JSP</code>,<code>PHP</code>,<code>ASP</code> 应用。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>优秀的 SEO</li><li>首屏加载快</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>负载大：由于渲染任务都交由服务端进行，在高并发的情况下，对于服务端负载压力大，同时丧失了浏览器端作为一个天然分布式系统的优势。</li><li>复用性能差：因为返回的是整个页面，对于每个路由都要重新进行页面刷新，复用性能 上不友好。</li><li>前后端耦合严重，前端开发依赖于后端，开发形式上不友好</li></ol><h2 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h2><p>前后端共用一套 <code>JS</code> 代码，采用不同的构建方式。通过 <code>Node</code> 服务器进行页面的首屏生成。在我的理解上，有点中间件的意思。</p><p><img src="/assets/img/isomorphic.jpg" alt="isomorphic"></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>兼顾客户端渲染和服务端渲染优点。</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol><li>对服务器有一定负载。</li><li>需要一定的开发成本。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前来看，客户端渲染和同构已经成为主流。</p><h3 id="首屏渲染"><a href="#首屏渲染" class="headerlink" title="首屏渲染"></a>首屏渲染</h3><p>因为开始渲染时，浏览器需要下载所有的资源才能正常显示页面，故而造成一段时间的空白页面。一般有两种方式解决：</p><ol><li>代码分割。首屏所需要的东西有限，可以将首页需要的东西分割，单独下载，之后的资源再去动态请求。</li><li>预展示。可以在加载资源的过程中弄一些 <code>Loading</code> 界面，告诉用户界面正在加载，达到良好的用户体验。</li></ol><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p>客户端渲染如果要考虑 <code>SEO</code>，目前有两种方案：</p><ol><li>通过 <code>meta</code> 的元属性进行关键字的 <code>SEO</code></li><li>提供一套静态 <code>HTML</code> 模版供浏览器抓取用以 <code>SEO</code>（比如 <a href="https://prerender.io" target="_blank" rel="noopener">prerender.io</a>）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端页面的渲染这块，近几年来感觉经历了从服务端渲染(多页面)=&amp;gt;客户端渲染(&lt;code&gt;SPA&lt;/code&gt;)=&amp;gt;同构渲染的演变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SSR" scheme="http://1016990109.github.io/tags/SSR/"/>
    
      <category term="服务端渲染" scheme="http://1016990109.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS</title>
    <link href="http://1016990109.github.io/2018/09/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS/"/>
    <id>http://1016990109.github.io/2018/09/08/前端基础之JS/</id>
    <published>2018-09-08T01:44:06.000Z</published>
    <updated>2019-01-01T05:50:26.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-中的-this"><a href="#JavaScript-中的-this" class="headerlink" title="JavaScript 中的 this"></a>JavaScript 中的 this</h2><p><code>JS</code> 中的 <code>this</code> 是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了 <code>this</code> 的值。<code>this</code> 取值符合以下规则：</p><a id="more"></a><ol><li>在调用函数时使用 <code>new</code> 关键字，函数内的 <code>this</code> 是一个全新的对象。</li><li>如果 <code>apply</code>、<code>call</code> 或 <code>bind</code> 方法用于调用、创建一个函数，函数内的 <code>this</code> 就是作为参数传入这些方法的对象。</li><li>当函数作为对象里的方法被调用时，函数内的 <code>this</code> 是调用该函数的对象。比如当 <code>obj.method()</code> 被调用时，函数内的 <code>this</code> 将绑定到 <code>obj</code> 对象。</li><li>如果调用函数不符合上述规则，那么 <code>this</code> 的值指向全局对象（<code>global object</code>）。浏览器环境下 <code>this</code> 的值指向 <code>window</code> 对象，但是在严格模式下(<code>&#39;use strict&#39;</code>)，<code>this</code> 的值为 <code>undefined</code>。</li><li>如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定 <code>this</code> 的值。</li><li>如果该函数是 <code>ES2015</code> 中的箭头函数，将忽略上面的所有规则，<code>this</code> 被设置为它被创建时的上下文。具体查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this</a>。</li></ol><h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><p><code>IIFE</code>(Immediately Invoked Function Expressions)代表立即执行函数。 <code>JavaScript</code> 解析器将 <code>function foo(){ }();</code> 解析成 <code>function foo(){ }</code> 和 <code>();</code>。其中，前者是函数声明；后者（一对括号）是试图调用一个函数，却没有指定名称，因此它会抛出 <code>Uncaught SyntaxError: Unexpected token</code> 的错误。修改方法：</p><p><code>(function foo(){ })()</code> 和 <code>(function foo(){ }())</code>。</p><p>可能会用到 <code>void</code> 操作符：<code>void function foo(){ }();</code>，但是返回值是 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't add JS syntax to this code block to prevent Prettier from formatting it.</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">void</span> (<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'foo'</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="null、undefined-和未声明变量"><a href="#null、undefined-和未声明变量" class="headerlink" title="null、undefined 和未声明变量"></a>null、undefined 和未声明变量</h2><p>当你没有提前使用 <code>var</code>、<code>let</code> 或 <code>const</code> 声明变量，就为一个变量赋值时，该变量是未声明变量（<code>undeclared variables</code>）。未声明变量会脱离当前作用域，成为全局作用域下定义的变量。在严格模式下，给未声明的变量赋值，会抛出 <code>ReferenceError</code> 错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">1</span> <span class="comment">// 在严格模式下，抛出 ReferenceError 错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>null == undefined</code>，但是 <code>null !== undefined</code>。</p></blockquote><h2 id="宿主对象（host-objects）和原生对象（native-objects）"><a href="#宿主对象（host-objects）和原生对象（native-objects）" class="headerlink" title="宿主对象（host objects）和原生对象（native objects）"></a>宿主对象（host objects）和原生对象（native objects）</h2><p>原生对象是由 <code>ECMAScript</code> 规范定义的 <code>JavaScript</code> 内置对象，比如 <code>String</code>、<code>Math</code>、<code>RegExp</code>、<code>Object</code>、<code>Function</code> 等等。</p><p>宿主对象是由运行时环境（浏览器或 <code>Node</code>）提供，比如 <code>window</code>、<code>XMLHTTPRequest</code> 等等。</p><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><p>一般有以下一种方式：</p><ul><li><code>typeof</code>，返回对象的基础数据类型(除了 <code>null</code>，因为是 <code>Object</code> 类型；<strong>多加一个 <code>function</code></strong>)(<code>boolean</code>,<code>number</code>,<code>string</code>,<code>object</code>,<code>undefined</code>,<code>function</code>, <code>es6</code> 的 <code>symbol</code>)是何种，小写。</li><li><code>instanceof</code>，一般用来判断引用类型，不是所有浏览器都支持这个语法。</li><li><code>Object.prototype.toString.call(object)</code>，<strong>通用的方法</strong>，返回 <code>[object + 类型]</code>，这里的类型首字母大写，如 <code>Object</code>。</li></ul><blockquote><p>注意 <code>NaN</code> 是 <code>number</code> 类型，<code>null</code> 是 <code>Object</code> 类型。判断数组可以 <code>Array.isArray(arr)</code>，判断 <code>NaN</code> 可以 <code>isNaN(num)</code>。</p></blockquote><h2 id="document-write"><a href="#document-write" class="headerlink" title="document.write"></a>document.write</h2><p><code>document.write()</code> 接收一个字符串作为参数，将该字符串写入文档流中。一旦文档流已经关闭（<code>document.close()</code>），那么 <code>document.write</code> 就会重新利用 <code>document.open()</code> 打开新的文档流并写入，此时原来的文档流会被清空，已渲染好的页面就会被清除，浏览器将重新构建 <code>DOM</code> 并渲染新的页面。</p><blockquote><p>实际生产中，要尽量避免使用 <code>document.write</code>。</p></blockquote><h2 id="功能检测（feature-detection）、功能推断（feature-inference）和-UA-字符串"><a href="#功能检测（feature-detection）、功能推断（feature-inference）和-UA-字符串" class="headerlink" title="功能检测（feature detection）、功能推断（feature inference）和 UA 字符串"></a>功能检测（feature detection）、功能推断（feature inference）和 UA 字符串</h2><h3 id="功能检测"><a href="#功能检测" class="headerlink" title="功能检测"></a>功能检测</h3><p>功能检测包括确定浏览器是否支持某段代码，以及是否运行不同的代码（取决于它是否执行），以便浏览器始终能够正常运行代码功能，而不会在某些浏览器中出现崩溃和错误。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'geolocation'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="comment">// 可以使用 navigator.geolocation</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 处理 navigator.geolocation 功能缺失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="功能推断"><a href="#功能推断" class="headerlink" title="功能推断"></a>功能推断</h3><p>功能推断与功能检测一样，会对功能可用性进行检查，但是在判断通过后，还会使用其他功能，因为它假设其他功能也可用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.getElementsByTagName) &#123;</span><br><span class="line">  element = <span class="built_in">document</span>.getElementById(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常不推荐这种方式。功能检测更能保证万无一失。</p><h3 id="UA-字符串"><a href="#UA-字符串" class="headerlink" title="UA 字符串"></a>UA 字符串</h3><p>这是一个浏览器报告的字符串，它允许网络协议对等方（<code>network protocol peers</code>）识别请求用户代理的应用类型、操作系统、应用供应商和应用版本。它可以通过 <code>navigator.userAgent</code> 访问。 然而，这个字符串很难解析并且很可能存在欺骗性。例如，<code>Chrome</code> 会同时作为 <code>Chrome</code> 和 <code>Safari</code> 进行报告。因此，要检测 <code>Safari</code>，除了检查 <code>Safari</code> 字符串，还要检查是否存在 <code>Chrome</code> 字符串。不要使用这种方式。</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>变量提升（<code>hoisting</code>）是用于解释代码中变量声明行为的术语。<strong>使用 <code>var</code>(<code>let</code> 是没用的) 关键字声明或初始化的变量</strong>，会将声明语句“提升”到当前作用域的顶部。 但是，<strong>只有声明</strong>才会触发提升，赋值语句（如果有的话）将保持原样。我们用几个例子来解释一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 var 声明得到提升</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 let/const 声明不会提升</span></span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// ReferenceError: bar is not defined</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// [Function: foo]</span></span><br><span class="line">foo() <span class="comment">// 'FOOOOO'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'FOOOOO'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// [Function: foo]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// undefined</span></span><br><span class="line">bar() <span class="comment">// Uncaught TypeError: bar is not a function</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'BARRRR'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// [Function: bar]</span></span><br></pre></td></tr></table></figure><h2 id="attribute-和-property"><a href="#attribute-和-property" class="headerlink" title="attribute 和 property"></a>attribute 和 property</h2><p><code>Attribute</code> 是在 <code>HTML</code> 中定义的，而 <code>property</code> 是在 <code>DOM</code> 上定义的。为了说明区别，假设我们在 <code>HTML</code> 中有一个文本框：<code>&lt;input type=&quot;text&quot; value=&quot;Hello&quot;&gt;</code>。<strong><code>Attribute</code> 只有通过初始 <code>HTML</code> 中设置或者 <code>setAttribute</code> 方法设置才能改变</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(input.getAttribute(<span class="string">'value'</span>)) <span class="comment">// Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(input.value) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>但是在文本框中键入 “ World!”后:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(input.getAttribute(<span class="string">'value'</span>)) <span class="comment">// Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(input.value) <span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，除了 <code>value property</code> 外(<code>setAttribute(&#39;value&#39;, [value])</code> 会影响 <code>input.value</code>，但是 <code>input.value = [value]</code> 并不会更改 <code>attribute</code>)，其他的 <code>attribute</code> 或 <code>property</code> 更改的时候会同时改变另外一个。</p></blockquote><h2 id="load-事件和-DOMContentLoaded-事件"><a href="#load-事件和-DOMContentLoaded-事件" class="headerlink" title="load 事件和 DOMContentLoaded 事件"></a>load 事件和 DOMContentLoaded 事件</h2><p>当初始的 <code>HTML</code> 文档被完全加载和解析完成之后，<code>DOMContentLoaded</code> 事件被触发，而无需等待样式表、图像和子框架的完成加载。</p><p><code>window</code> 的 <code>load</code> 事件仅在 <code>DOM</code> 和所有相关资源全部完成加载后才会触发。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>在文件、脚本、函数的开头加上 <code>&#39;use strict&#39;</code> 来启用严格模式。</p><p>严格模式特点：</p><ol><li>全局变量需要显示声明，直接 <code>x = 1</code> 会报错。</li><li>禁止使用 <code>with</code> 语句，创建 <code>eval</code> 的作用域。</li><li>禁止 <code>this</code> 指向全局对象。</li><li>禁止在函数内部遍历调用栈，<code>fn.caller</code>、<code>fn.arguments</code> 都会报错，注意直接使用 <code>arguments</code> 是不会报错的。</li><li>禁止删除变量，除非 <code>configurable</code> 属性为 <code>true</code>。</li><li>对象不能有重名属性，函数不能有重名参数。</li><li>显示报错，比如删除不可删除变量、对只读属性赋值都会显示报错。</li><li>禁止八进制表示法。</li><li>不允许对 <code>arguments</code> 赋值，不跟踪 <code>arguments</code> 的变化，禁止使用 <code>arguments.callee</code>。</li><li>函数必须声明在顶层，也就是说不能在非函数的代码块中声明函数。</li><li>新增保留字，和 <code>ES6</code> 接轨，如 <code>implements</code>,<code>let</code>,<code>static</code> 等等。</li></ol><h2 id="柯里化-curry"><a href="#柯里化-curry" class="headerlink" title="柯里化(curry)"></a>柯里化(curry)</h2><p>柯里化（<code>currying</code>）是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//保留参数合并结果</span></span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> curried = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args.push(...arguments)</span><br><span class="line">      <span class="keyword">return</span> curried</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addCurry = curry(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    sum += <span class="built_in">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addCurry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)()) <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h2 id="页面的生命周期"><a href="#页面的生命周期" class="headerlink" title="页面的生命周期"></a>页面的生命周期</h2><ul><li><code>DOMContentLoaded</code>:所有 <code>HTML</code> 已经加载完，<code>DOM</code> 树也构建完，但是额外的资源还没有加载完，如 <code>CSS</code> 和图片。</li><li><code>load</code>(<code>window.onload</code>):所有资源都加载完了</li><li><code>beforeunload</code>/<code>unload</code>:用户离开页面</li></ul><p>例外：</p><p><code>script</code> 有 <code>src</code> 且有 <code>defer</code> 或者 <code>async</code> 属性的不一样。</p><table><thead><tr><th></th><th>async</th><th>defer</th></tr></thead><tbody><tr><td>执行顺序</td><td>不阻塞渲染，一旦下载完立即执行，和在 <code>DOM</code> 中的顺序无关。</td><td>等待 <code>DOM</code> 解析完才执行，且执行顺序和 <code>DOM</code> 中顺序相同。</td></tr><tr><td>DOMContentLoaded</td><td>可能发生在 <code>DOMContentLoaded</code> 之前，前提是文档够长，且脚本够小执行快。</td><td>要等到 <code>DOMContentLoaded</code> 结束才会执行。</td></tr></tbody></table><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托就是将子元素的监听事件移动到父元素，这样只用添加一个监听，在子元素非常多的时候有用。</p><p><strong>事件委托是发生在冒泡阶段的，不然捕获阶段是从外到内过程，这个时候拿不到子元素。</strong></p><p>且监听的事件是存储在堆中的，<strong>记得手动移除</strong>！而内联的事件不用移除，因为节点移除之后绑定在上面的监听事件就没有引用持有了，垃圾回收时会将其回收。</p><h2 id="箭头函数与普通函数的不同"><a href="#箭头函数与普通函数的不同" class="headerlink" title="箭头函数与普通函数的不同"></a>箭头函数与普通函数的不同</h2><ul><li><code>this</code> 的指向为创建时上下文</li><li>没有 <code>arguments</code></li><li><code>call</code> 和 <code>apply</code> 绑定 <code>this</code> 没有用</li><li>不能使用 <code>new</code> 操作符</li><li>没有 <code>prototype</code></li><li>不能作为构造函数</li></ul><h2 id="禁用鼠标点击事件"><a href="#禁用鼠标点击事件" class="headerlink" title="禁用鼠标点击事件"></a>禁用鼠标点击事件</h2><ul><li><code>CSS</code> 方法(<strong>最常用</strong>)<br><code>pointer-events: none</code></li><li><code>HTML</code><br><code>disabled</code> 设置为 <code>true</code>，一般只对按钮有作用。</li><li><code>JS</code><br>取消所有的监听事件，或者在监听事件中判断是否需要禁用点击事件再 <code>event.preventDefault();event.stopPropagation()</code>。</li></ul><h2 id="CommonJS-AMD-CMD-UMD-规范"><a href="#CommonJS-AMD-CMD-UMD-规范" class="headerlink" title="CommonJS AMD CMD UMD 规范"></a>CommonJS AMD CMD UMD 规范</h2><ul><li>CommonJS<br>根据 <code>CommonJS</code> 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。<br><code>CommonJS</code> 是同步的，而 <code>AMD</code> 和 <code>CMD</code> 是异步的。</li><li>AMD(Asynchromous Module Definition)<br><code>AMD</code> 是 <code>RequireJS</code> 在推广过程中对模块定义的规范化产出。<br><code>AMD</code> 异步加载模块。它的模块支持对象、函数、构造器、字符串、<code>JSON</code> 等各种类型的模块。<br>适用 <code>AMD</code> 规范适用 <code>define</code> 方法定义模块。<br><code>AMD</code> 运行时核心思想是「Early Executing」，也就是提前执行依赖。</li><li>CMD(Common Module Definition)<br><code>CMD</code> 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</li><li>UMD(Universal Module Definition)<br><code>umd</code> 是 <code>AMD</code> 和 <code>CommonJS</code> 的糅合。<br>先判断是否支持 <code>AMD</code>（通过判断 <code>define</code> 是否存在），存在则使用 <code>AMD</code> 方式加载模块。再判断是否支持 <code>Node.js</code> 的模块（<code>exports</code>）是否存在，存在则使用 <code>Node.js</code> 模块模式。如果两个都不存在，那么可能就使用全局变量来定义了(一般根据传入的 <code>root</code>，可能是执行的 <code>this</code>)。</li></ul><h2 id="Babel-升级"><a href="#Babel-升级" class="headerlink" title="Babel 升级"></a>Babel 升级</h2><p>建议使用 <code>npx babel-upgrade</code> 来升级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript-中的-this&quot;&gt;&lt;a href=&quot;#JavaScript-中的-this&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的 this&quot;&gt;&lt;/a&gt;JavaScript 中的 this&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JS&lt;/code&gt; 中的 &lt;code&gt;this&lt;/code&gt; 是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了 &lt;code&gt;this&lt;/code&gt; 的值。&lt;code&gt;this&lt;/code&gt; 取值符合以下规则：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://1016990109.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS原型链</title>
    <link href="http://1016990109.github.io/2018/09/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://1016990109.github.io/2018/09/07/前端基础之JS原型链/</id>
    <published>2018-09-07T07:41:08.000Z</published>
    <updated>2018-09-07T08:03:55.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型链简介"><a href="#原型链简介" class="headerlink" title="原型链简介"></a>原型链简介</h2><p>关于 <code>JS</code> 中的原型链，以及 <code>__proto__</code> 与 <code>prototype</code> 之间的关系，直接看一张图：</p><a id="more"></a><p><img src="/assets/img/prototype.jpg" alt="prototype"></p><p>举个例子来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>一个对象的 <code>__proto__</code> 指向它构造函数的 <code>prototype</code>(有特殊情况)。</li><li><code>__proto__</code> 的末尾是 <code>Object.prototype.__proto__</code>，指向 <code>null</code>。</li><li>原型的构造函数就是对象的构造函数。</li></ol><blockquote><p>特殊情况：对象由 <code>Object.create</code> 函数创建：</p></blockquote><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'person1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1)</span><br><span class="line"><span class="built_in">console</span>.log(person2.__proto__ === person1) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></code></pre><h2 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h2><p>当我们读取一个属性的时候，如果在实例属性上找到了，就读取它，不会管原型属性上是否还有相同的属性，这其实就是属性屏蔽。</p><p>但是如果在实例属性上没有找到的话，就会在实例的原型上去找，如果原型上还没有，就继续到原型的原型上去找，直到尽头(<code>Object.prototype</code>)。</p><p>如何检测一个属性存在于实例中，还是原型中？</p><p>使用方法 <code>hasOwnProperty</code>,属性只有存在于实例中才会返回 <code>true</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.prototypeName = <span class="string">'prototype name'</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// 实例属性</span></span><br><span class="line">person1.name = <span class="string">'J'</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">'prototypeName'</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>而 <code>in</code> 操作符和 <code>Object.keys()</code> 都会返回所有属性，包括原型链上的属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型链简介&quot;&gt;&lt;a href=&quot;#原型链简介&quot; class=&quot;headerlink&quot; title=&quot;原型链简介&quot;&gt;&lt;/a&gt;原型链简介&lt;/h2&gt;&lt;p&gt;关于 &lt;code&gt;JS&lt;/code&gt; 中的原型链，以及 &lt;code&gt;__proto__&lt;/code&gt; 与 &lt;code&gt;prototype&lt;/code&gt; 之间的关系，直接看一张图：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="原型链" scheme="http://1016990109.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之CSS</title>
    <link href="http://1016990109.github.io/2018/09/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BCSS/"/>
    <id>http://1016990109.github.io/2018/09/04/前端基础之CSS/</id>
    <published>2018-09-04T13:43:53.000Z</published>
    <updated>2018-09-22T02:10:47.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-选择器的优先级"><a href="#CSS-选择器的优先级" class="headerlink" title="CSS 选择器的优先级"></a>CSS 选择器的优先级</h2><p>内联样式 &gt; <code>ID</code> 选择器 &gt; 类选择器、属性选择器和伪类选择器(<code>:hover</code>,<code>:first-child</code>，<code>:after</code> 之类) &gt; 标签（类型）选择器和伪元素选择器(<code>::after</code>,<code>::first-letter</code>,<code>::selection</code>等等)</p><blockquote><p><code>CSS2</code> 用的是 <code>:after</code>，而 <code>CSS3</code> 用的是 <code>::after</code>。</p></blockquote><p>相同则比较数量每一级的数量总和。</p><a id="more"></a><p>当出现优先级相等的情况时，最晚出现的样式规则会被采纳。</p><h2 id="重置（resetting）CSS-和-标准化（normalizing）CSS-的区别"><a href="#重置（resetting）CSS-和-标准化（normalizing）CSS-的区别" class="headerlink" title="重置（resetting）CSS 和 标准化（normalizing）CSS 的区别"></a>重置（resetting）CSS 和 标准化（normalizing）CSS 的区别</h2><ul><li><strong>重置（Resetting）</strong>： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像 <code>margin</code>、<code>padding</code>、<code>font-size</code> 这些样式全部置成一样。你将必须重新定义各种元素的样式。</li><li><strong>标准化（Normalizing）</strong>： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。</li></ul><h2 id="Float-定位"><a href="#Float-定位" class="headerlink" title="Float 定位"></a>Float 定位</h2><p>浮动（<code>float</code>）是 <code>CSS</code> 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（<strong>比如文字会围绕着浮动元素</strong>）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。</p><blockquote><p>文字所在的行框并不会忽略已经脱离文档流的 <code>float</code> 元素，甚至会调整自己的行框宽度，给其让出空间，表现形式就是文字充满 <code>float</code> 元素的周围</p></blockquote><p><code>CSS</code> 的 <code>clear</code> 属性通过使用 <code>left</code>、<code>right</code>、<code>both</code>，让该元素向下移动（清除浮动）到浮动元素下面。</p><p>如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（<code>clear</code>）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。一般方法是给父元素一个 <code>clearfix</code> 的类，内容如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，把父元素属性设置为 <code>overflow: auto</code> 或 <code>overflow: hidden</code>，会使其内部的<strong>子元素</strong>形成块格式化上下文（<code>Block Formatting Context</code>），并且父元素会扩张自己，使其能够包围它的子元素。</p><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p><code>CSS</code> 中的 <code>z-index</code> 属性控制重叠元素的垂直叠加顺序。<strong><code>z-index</code> 只能影响 <code>position</code> 值不是 <code>static</code> 的元素</strong>。</p><p>没有定义 <code>z-index</code> 的值时，元素按照它们出现在 <code>DOM</code> 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（<code>static</code>）的元素，而不管 <code>HTML</code> 层次结构如何。</p><p>层叠上下文元素有如下特性：</p><ul><li>层叠上下文的层叠水平要比普通元素高；</li><li>层叠上下文可以阻断元素的混合模式；</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li><li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ul><p><strong>普通元素的层叠水平优先由层叠上下文决定</strong>，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。</p><p>层叠顺序：</p><p><img src="/assets/img/stacked_order.png" alt="stacked order"></p><p>层叠上下文的创建：</p><ul><li>页面根元素</li><li>对于包含有 <code>position:relative</code> / <code>position:absolute</code> / <code>position:fixed</code> / <code>position:sticky</code> 的定位元素，且 <code>z-index</code> 不是 <code>auto</code></li><li><code>z-index</code> 值不为 <code>auto</code> 的 <code>flex</code> 项(父元素 <code>display:flex|inline-flex</code>)，是 <code>flex</code> 布局的<strong>子元素</strong></li><li>元素的 <code>opacity</code> 值不是 1</li><li>元素的 <code>transform</code> 值不是 <code>none</code></li><li>元素 <code>mix-blend-mode</code> 值不是 <code>normal</code></li><li>元素的 <code>filter</code> 值不是 <code>none</code></li><li>元素的 <code>isolation</code> 值是 <code>isolate</code></li><li><code>will-change</code> 指定的属性值为上面任意一个</li><li>元素的 <code>-webkit-overflow-scrolling</code> 设为 <code>touch</code></li></ul><p>具体的一些比较可查看 <a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">深入理解 CSS 中的层叠上下文和层叠顺序</a></p><h2 id="格式化上下文-Block-Formatting-Context"><a href="#格式化上下文-Block-Formatting-Context" class="headerlink" title="格式化上下文(Block Formatting Context)"></a>格式化上下文(Block Formatting Context)</h2><p>一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文：</p><ul><li><code>float</code> 的值不是 <code>none</code>.</li><li><code>position</code> 的值不是 <code>static</code> 或 <code>relative</code>.</li><li><code>display</code> 的值是 <code>table-cell</code>、<code>table-caption</code>、<code>inline-block</code>、<code>flex</code>、或 <code>inline-flex</code>。</li><li><code>overflow</code> 的值不是 <code>visible</code>。</li></ul><h3 id="BFC-特性："><a href="#BFC-特性：" class="headerlink" title="BFC 特性："></a><code>BFC</code> 特性：</h3><ol><li>内部的 <code>Box</code> 会在垂直方向，从顶部开始一个接一个地放置。</li><li><code>Box</code> 垂直方向的距离由 <code>margin</code> 决定。属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生叠加。(用来解决边距叠加问题，给会重叠的元素加一个 <code>BFC</code> 的父元素，那么这个 <code>BFC</code> 块就不会和下一个元素的边距重叠了，<strong>水平方向的 <code>margin</code> 是不会叠加的</strong>)</li><li>每个元素的 <code>margin box</code> 的左边， 与包含块 <code>border box</code> 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li><code>BFC</code> 的区域不会与 <code>float box</code> 叠加，<strong>就算这个 <code>float box</code> 不是和它同级的</strong>。(解决布局问题，一个块元素与浮动块重叠了的问题)</li><li><code>BFC</code> 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</li><li>计算 <code>BFC</code> 的高度时，浮动元素也参与计算。(经常用来解决浮动元素导致父元素坍塌的问题)</li></ol><h2 id="不同浏览器的样式兼容性问题"><a href="#不同浏览器的样式兼容性问题" class="headerlink" title="不同浏览器的样式兼容性问题"></a>不同浏览器的样式兼容性问题</h2><ol><li>在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。</li><li>使用已经处理好此类问题的库，比如 <code>Bootstrap</code>。</li><li>使用 <code>autoprefixer</code> 自动生成 <code>CSS</code> 属性前缀。(<code>webpack</code> 打包工具可使用 <code>postcss</code> 来完成)</li><li>使用 <code>Reset.css</code> 或 <code>Normalize.css</code>。</li></ol><h2 id="如何为功能受限的浏览器提供页面"><a href="#如何为功能受限的浏览器提供页面" class="headerlink" title="如何为功能受限的浏览器提供页面"></a>如何为功能受限的浏览器提供页面</h2><ul><li>优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。</li><li>渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。</li><li>利用 <a href="https://caniuse.com" target="_blank" rel="noopener">caniuse.com</a> 检查特性支持。</li><li>使用 <code>autoprefixer</code> 自动生成 <code>CSS</code> 属性前缀。</li><li>使用 <a href="https://modernizr.com" target="_blank" rel="noopener">Modernizr</a> 进行特性检测。</li></ul><h2 id="用-CSS-隐藏页面元素"><a href="#用-CSS-隐藏页面元素" class="headerlink" title="用 CSS 隐藏页面元素"></a>用 CSS 隐藏页面元素</h2><ol><li><code>opacity</code> 设为 0。</li><li><code>visibility</code> 设为 <code>hidden</code>。</li><li><code>display</code> 设为 <code>none</code>。</li><li><code>position</code> 设为 <code>absolute</code>，然后移动到不可见区域，<code>left: -99999px</code>。</li><li><code>width: 0; height: 0; overflow: hidden</code>：使元素不占用屏幕上的任何空间，导致不显示它。</li><li><code>text-indent: -9999px</code>：这只适用于 <code>block</code> 元素中的文本。</li><li><code>clip(clip-path):rect()/inset()/polygon()</code>，注意只对 <code>position</code> 值为 <code>absolute</code> 或 <code>fixed</code> 的元素有效。</li><li><code>transform: scale(0,0)</code>。</li><li>利用 <code>z-index</code> 来隐藏。</li></ol><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- link元素中的CSS媒体查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"only screen and (max-width: 800px)"</span> <span class="attr">href</span>=<span class="string">"example.css"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 样式表中的CSS媒体查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">@<span class="keyword">media</span> only screen and (max-width: <span class="number">600px</span>) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.facet_sidebar</span> &#123;</span></span><br><span class="line"><span class="undefined">    display: none;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>and</code> 关键字用于合并多个媒体属性或合并媒体属性与媒体类型。</p><p>媒体查询中使用逗号分隔效果等同于 <code>or</code> 逻辑操作符。</p><p><code>not</code> 关键字应用于整个媒体查询，在媒体查询为假时返回真</p><p>更多的设置查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries" target="_blank" rel="noopener">CSS 媒体查询</a></p><h2 id="解释浏览器如何确定哪些元素与-CSS-选择器匹配"><a href="#解释浏览器如何确定哪些元素与-CSS-选择器匹配" class="headerlink" title="解释浏览器如何确定哪些元素与 CSS 选择器匹配"></a>解释浏览器如何确定哪些元素与 CSS 选择器匹配</h2><p>浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 <code>DOM</code> 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。</p><p>例如，对于形如 <code>p span</code> 的选择器，浏览器首先找到所有 <code>&lt;span&gt;</code> 元素，并遍历它的父元素直到根元素以找到 <code>&lt;p&gt;</code> 元素。对于特定的 <code>&lt;span&gt;</code>，只要找到一个 <code>&lt;p&gt;</code>，就知道已经匹配并停止继续匹配</p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>改变计算元素 <code>height</code> 与 <code>width</code> 的方法。</p><p>元素默认应用了 <code>box-sizing: content-box</code>，元素的宽高只会决定内容（<code>content</code>）的大小。</p><p><code>box-sizing: border-box</code> 改变计算元素 <code>width</code> 和 <code>height</code> 的方式，<code>border</code> 和 <code>padding</code> 的大小也将计算在内。</p><h2 id="block、inline-与-inline-block-区别"><a href="#block、inline-与-inline-block-区别" class="headerlink" title="block、inline 与 inline-block 区别"></a>block、inline 与 inline-block 区别</h2><table><thead><tr><th></th><th>block</th><th>inline-block</th><th>inline</th></tr></thead><tbody><tr><td>大小</td><td>填充其父容器的宽度。</td><td>取决于内容。</td><td>取决于内容。</td></tr><tr><td>定位</td><td>从新的一行开始，并且不允许旁边有 <code>HTML</code> 元素（除非是<code>float</code>）</td><td>与其他内容一起流动，并允许旁边有其他元素。</td><td>与其他内容一起流动，并允许旁边有其他元素。</td></tr><tr><td>能否设置 <code>width</code> 和 <code>height</code></td><td>能</td><td>能</td><td>不能。设置会被忽略。</td></tr><tr><td>可以使用 <code>vertical-align</code> 对齐</td><td>不可以</td><td>可以</td><td>可以</td></tr><tr><td>边距（<code>margin</code>）和填充（<code>padding</code>）</td><td>各个方向都存在</td><td>各个方向都存在</td><td>只有水平方向存在。垂直方向会被忽略。 尽管 border 和 padding 在 content 周围，但垂直方向上的空间取决于’line-height’</td></tr><tr><td>浮动（<code>float</code>）</td><td>-</td><td>-</td><td>就像一个 <code>block</code> 元素，可以设置垂直边距和填充。</td></tr></tbody></table><h2 id="relative、fixed、absolute-和-static"><a href="#relative、fixed、absolute-和-static" class="headerlink" title="relative、fixed、absolute 和 static"></a>relative、fixed、absolute 和 static</h2><p>经过定位的元素，其 <code>position</code> 属性值必然是 <code>relative</code>、<code>absolute</code>、<code>fixed</code> 或 <code>sticky</code>。</p><ul><li><code>static</code>：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code> 属性无效。</li><li><code>relative</code>：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。</li><li><code>absolute</code>：不为元素预留空间，通过指定元素相对于最近的非 <code>static</code> 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（<code>margins</code>），且不会与其他边距合并。</li><li><code>fixed</code>：不为元素预留空间，而是通过指定元素相对于屏幕视口（<code>viewport</code>）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。<strong>当元素祖先的 <code>transform</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</strong></li><li><code>sticky</code>：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 <code>flow root</code>（<code>BFC</code>）和 <code>containing block</code>（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table</code> 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code> 对 <code>table</code> 元素的效果与 <code>position: relative</code> 相同。须指定 <code>top</code>, <code>right</code>, <code>bottom</code> 或 <code>left</code> 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li></ul><p>详情以及例子可查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">position</a>。</p><h2 id="响应式设计与自适应设计不同"><a href="#响应式设计与自适应设计不同" class="headerlink" title="响应式设计与自适应设计不同"></a>响应式设计与自适应设计不同</h2><p>用一张图片来描述更合适：</p><p><em>上面是响应式设计，下面是自适应设计</em> <img src="/assets/img/rwd-vs-adapt-example.gif" alt="rwd-vs-adapt-example"></p><p>响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。</p><p>响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。</p><p>自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。</p><h2 id="视网膜分辨率处理"><a href="#视网膜分辨率处理" class="headerlink" title="视网膜分辨率处理"></a>视网膜分辨率处理</h2><p>使用媒体查询，像 <code>@media only screen and (min-device-pixel-ratio: 2) { ... }</code>，然后改变 <code>background-image</code>。</p><p>对于图标类的图形，尽可能使用 <code>svg</code> 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。</p><p>还有一种方法是，在检查了 <code>window.devicePixelRatio</code> 的值后，利用 <code>JavaScript</code> 将 <code>&lt;img&gt;</code> 的 <code>src</code> 属性修改，用更高分辨率的版本进行替换。<strong>注意：<code>IE</code> 和 <code>FireFox</code> 是不支持 <code>devicePixelRatio</code> 属性的。</strong></p><h2 id="translate-vs-postion-absolute"><a href="#translate-vs-postion-absolute" class="headerlink" title="translate vs postion absolute"></a>translate vs postion absolute</h2><p><code>translate(x, y)</code> 是 <code>transform</code> 的一个值。改变 <code>transform</code> 或 <code>opacity</code> 不会触发浏览器重新布局（<code>reflow</code>）或重绘（<code>repaint</code>），只会触发组合（<code>composite</code>）。而改变绝对定位会触发重新布局，进而触发重绘和复合。因此 <code>translate()</code> 更高效，可以缩短平滑动画的绘制时间。</p><p>当使用 <code>translate()</code> 时，元素仍然占据其原始空间（有点像 <code>position：relative</code>），这与改变绝对定位不同。</p><h2 id="translate3d-vs-translate"><a href="#translate3d-vs-translate" class="headerlink" title="translate3d vs translate"></a>translate3d vs translate</h2><p>只有 <code>Z</code> 轴上的变化才会产生新的合成层，<code>Z</code> 轴上设置 0 也是可以的，同时也会启用 <code>GPU</code> 加速，使用 <code>GPU</code> 来渲染该层。</p><p>也就是说 <code>translate3d</code> 才会触发 <code>GPU</code> 加速，二维的 <code>translate</code> 是不会的。同理，<code>rotate3d</code> 与 <code>rotate</code>，<code>scale3d</code> 与 <code>scale</code> 等等也都是一样的，<code>3d</code> 会启用 <code>GPU</code> 加速。</p><p><strong>但是需要注意的是，虽然 <code>2d</code> 不会触发 <code>GUP</code> 硬件加速也就是增加新的合成层，但是它和 <code>3d</code> 一样能跳过浏览器渲染的 <code>Layout</code> 和 <code>Paint</code> 步骤，而直接到 <code>Composite</code>(合成) 步骤，实际上是新增了一层渲染层，所以一定程度上渲染性能也有提升</strong>。渲染步骤：<code>JS</code> -&gt; <code>Style</code> -&gt; <code>Layout</code> -&gt; <code>Paint</code> -&gt; <code>Composite</code>，关于 <code>CSS</code> 属性会触发哪个步骤可以查看 <a href="https://csstriggers.com" target="_blank" rel="noopener">CSS Triggers</a>。</p><p>先有的渲染层才有合成层。</p><p>关于合成层与渲染层、<code>GPU</code> 硬件加速可以看 <a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noopener">无线性能优化：Composite</a>。</p><blockquote><p><code>GPU</code> 是使用浮点数运算的，故而如果对文字加速可能会导致文字模糊，故而慎用！启动 <code>GPU</code> 加速自然也会加大电能的消耗，所以只在必要的时候再启用。</p></blockquote><blockquote><p>如何查看是否多了一层合成层(<strong>注意不是渲染层</strong>)，可以使用 <code>Chrome</code> 的 <code>Devtools</code> 来查看，选中更多种的 <code>Rendering</code> 选项，下面就有几个属性了：</p><ul><li><code>Paint flashing</code>:需要重绘的部分会高亮显示。</li><li><code>Layer borders</code>:显示层的边界，可以用来查看是否启用了 <code>GPU</code> 加速。</li><li><code>FPS meter</code>:启用 <code>FPS</code> 计量，可以在右上角看到当前页面的刷新帧率。</li><li><code>Scrolling performance issues</code>:会高亮可能影响滚动性能的元素。</li><li><code>Emulate CSS media</code>:强制使用打印或普通屏效果。<br>更加详细的信息可以通过 <code>Layers</code> 来查看，还会告诉你产生合成层的原因。以前的 <code>Chrome</code> 版本还可以在 <code>Timeline</code> 中看到每一帧的合成层情况，现在被移动到 <code>Performance</code> 中了，需要点击到某一个具体帧，再 <code>show layers</code> 才能出现 <code>Layers</code> 的选项卡。</li></ul></blockquote><h2 id="垂直水平居中"><a href="#垂直水平居中" class="headerlink" title="垂直水平居中"></a>垂直水平居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ol><li>行内元素居中<br>行内元素居中是只针对行内元素的，比如文本（<code>text</code>）、图片（<code>img</code>）、按钮等行内元素，可通过给父元素设置 <code>text-align:center</code> 来实现。</li><li>块状元素居中<br>定宽块状元素居中:设置“左右 margin”值为“auto”来实现居中。<br>不定宽块状元素居中:a. <code>dispaly:table</code> 再设置“左右 margin”为”auto”。b. <code>position: relative; left: 50%; transform: tranlateX(-50%)</code>。</li><li>通用：<code>flex</code> 布局。</li></ol><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ol><li>父元素高度确定，且子元素只有单行文本<br>设置子元素的 <code>line-height</code> 等于父元素的 <code>height</code> 值。</li><li>父元素高度确定，子元素有多行<br>设置父元素 <code>dispaly:table-cell</code>，再设置父元素的 <code>vertical-align:middle</code>。</li><li>绝对定位 + <code>translate</code>：<code>position: absolute; top: 50%; transform: translateY(-50%)</code>。</li><li>绝对定位 + <code>margin: auto</code>:子元素设置 <code>position: absolute</code>，把要垂直居中的元素相对于父元素绝对定位，<code>top</code> 和 <code>bottom</code> 设为相等的值，再设置 <code>margin: 0 auto</code>。</li><li><code>padding</code>: 父元素没有高度，且只有一个子元素，那么设置父元素上下 <code>padding</code> 相等就可以了。</li><li><code>flex</code> 布局。</li><li><code>vertical-align</code>: 让行内元素在块级元素中垂直居中可以使用 <code>vertical-align:middle</code> 来近似居中，如果需要绝对居中同时需要设置父元素的 <code>font-size</code> 为 0。</li></ol><blockquote><p><code>vertical-align</code> 注意事项：默认情况图片是与父元素的基线对齐的，基线可以认为是英文 4 行线的第 3 行线，解决图片下方空白问题可以设置对齐方式除 <code>baseline</code> 之外的值，或者设置 <code>line-height</code> 或 <code>font-size</code> 为 0。字符有下沉特性(字符的中心比块的绝对中心稍微下移)，进行居中对齐时需要注意，居中元素的中线会与文字中线对齐，所以会稍微下移。</p></blockquote><blockquote><p>一个没有内容的 <code>inline-block</code> 元素的基线是 <code>margin</code> 边的下边缘(是包含了 <code>margin</code> 空间的)。</p></blockquote><p>直接使用 <code>vertical-align:middle</code> 来居中(父元素不设置行高或者字体大小)的问题可以看下面这张图：</p><p><img src="/assets/img/vertical-align.jpg" alt="vertical-align"></p><blockquote><p><code>vertical-align</code> 的值查看 <a href="https://www.zhangxinxu.com/wordpress/2010/05/我对css-vertical-align的一些理解与认识（一）/" target="_blank" rel="noopener">我对 css-vertical-align 的一些理解与认识（一）</a></p></blockquote><h2 id="长宽比固定"><a href="#长宽比固定" class="headerlink" title="长宽比固定"></a>长宽比固定</h2><ul><li>垂直方向的 <code>padding</code><br>高度设置为 0，然后 <code>padding-top</code> 或者 <code>padding-bottom</code> 设置百分比(这个百分比是宽度的百分比)来达到长宽比固定的效果，不过子元素需要绝对定位，不然会被 <code>padding</code> 挤出容器外。</li><li>视窗单位<br><code>CSS</code> 新特性中提供了一种新的单位 <code>vw</code>。了解过这个单位的同学都知道，浏览器 <code>100vw</code> 表示的就是浏览器的视窗宽度(Viewport)。那么只要宽高设置好比例的 <code>vw</code> 就可以了。</li><li><code>grid</code> 布局<br>不常用。</li></ul><h2 id="强制同步布局"><a href="#强制同步布局" class="headerlink" title="强制同步布局"></a>强制同步布局</h2><p>将一帧送到屏幕会采用如下顺序：</p><p><code>JavaScript</code> -&gt; <code>Style</code> -&gt; <code>Layout</code> -&gt; <code>Paint</code> -&gt; <code>Composite</code></p><p>首先 <code>JavaScript</code> 运行，然后计算样式，然后布局。但是，可以使用 <code>JavaScript</code> 强制浏览器提前执行布局。这被称为<strong>强制同步布局</strong>。</p><p>典型的情况就是，在读操作之前进行了写操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  box.classList.add(<span class="string">'super-big'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gets the height of the box in pixels</span></span><br><span class="line">  <span class="comment">// and logs it out.</span></span><br><span class="line">  <span class="built_in">console</span>.log(box.offsetHeight)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里只要用上一帧的 offsetHeight 就可以了，取完值再对页面进行更新或者所谓的动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了回答高度问题，浏览器必须先应用样式更改（由于增加了 <code>super-big</code> 类），然后运行布局。这时它才能返回正确的高度。这是不必要的，并且可能是开销很大的工作。</p><p>这里有个强制同步布局的例子：<a href="https://googlesamples.github.io/web-fundamentals/tools/chrome-devtools/rendering-tools/forcedsync.html" target="_blank" rel="noopener">演示</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animation loop</span></span><br><span class="line"><span class="comment">/* // [START forcedsync] */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> m = <span class="number">0</span>; m &lt; movers.length; m++) &#123;</span><br><span class="line">    movers[m].style.left =</span><br><span class="line">      (<span class="built_in">Math</span>.sin(movers[m].offsetTop + timestamp / <span class="number">1000</span>) + <span class="number">1</span>) * <span class="number">500</span> + <span class="string">'px'</span></span><br><span class="line">    <span class="comment">// movers[m].style.left = ((Math.sin(m + timestamp/1000)+1) * 500) + 'px';</span></span><br><span class="line">  &#125;</span><br><span class="line">  raf = <span class="built_in">window</span>.requestAnimationFrame(update)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，在 <code>requestAnimationFrame</code> 的回调函数中，每个 <code>mover</code> 都触发了一次强制同步布局，所以本该在一帧内只布局一次，却在上面代码中布局了 <code>movers.length</code> 次，造成了卡顿。</p><blockquote><p>在 <code>Chrome DevTools</code> 中还可以诊断 <strong>强制同步布局</strong>。打开 <code>Performance</code> 面板(老版本是 <code>Timeline</code> 面板)，开始记录，结束之后可以查看 <code>FPS</code> 较低的帧，看问题在哪，可以看到在调用栈中，某个函数耗时较长，而且如果触发了强制同步布局，鼠标移动到上面去会有个 <code>Forced reflow</code> 提示，可能存在性能瓶颈，接在点击该执行函数就可以看到在哪触发的强制同步布局。具体 <code>Chrome DevTools</code> 如何操作查看 <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Get Started With Analyzing Runtime Performance</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS-选择器的优先级&quot;&gt;&lt;a href=&quot;#CSS-选择器的优先级&quot; class=&quot;headerlink&quot; title=&quot;CSS 选择器的优先级&quot;&gt;&lt;/a&gt;CSS 选择器的优先级&lt;/h2&gt;&lt;p&gt;内联样式 &amp;gt; &lt;code&gt;ID&lt;/code&gt; 选择器 &amp;gt; 类选择器、属性选择器和伪类选择器(&lt;code&gt;:hover&lt;/code&gt;,&lt;code&gt;:first-child&lt;/code&gt;，&lt;code&gt;:after&lt;/code&gt; 之类) &amp;gt; 标签（类型）选择器和伪元素选择器(&lt;code&gt;::after&lt;/code&gt;,&lt;code&gt;::first-letter&lt;/code&gt;,&lt;code&gt;::selection&lt;/code&gt;等等)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CSS2&lt;/code&gt; 用的是 &lt;code&gt;:after&lt;/code&gt;，而 &lt;code&gt;CSS3&lt;/code&gt; 用的是 &lt;code&gt;::after&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相同则比较数量每一级的数量总和。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://1016990109.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之HTML</title>
    <link href="http://1016990109.github.io/2018/09/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BHTML/"/>
    <id>http://1016990109.github.io/2018/09/04/前端基础之HTML/</id>
    <published>2018-09-04T03:29:55.000Z</published>
    <updated>2018-09-05T13:05:35.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><p><code>DOCTYPE</code> 是用来声明文档类型和 <code>DTD</code> 规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错。<code>HTML</code> 编辑器通常也会在语法高亮的同时提供合法性验证。</p><p>通常有以下几种：</p><ul><li><p>HTML5(推荐使用，其他的有触发怪异模式和近标准模式的风险)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>HTML 4.01 Strict</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>HTML 4.01 Transitional</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>上面的类型浏览器都会以标准模式渲染，除了下面这些情况（这些情况浏览器会进入兼容模式，也称怪异模式）：</p><ul><li><code>DOCTYPE</code> 声明了 <code>Transitional DTD</code> 但未给出 <code>URI</code></li><li><code>DOCTYPE</code> 声明不合法</li><li>未给出 <code>DOCTYPE</code> 声明</li></ul><blockquote><p>确定把 <code>DOCTYPE</code> 正确地放在 <code>HTML</code> 文件的顶端。任何放在 <code>DOCTYPE</code> 前面的东西，比如批注或 <code>XML</code> 声明，会令 <code>Internet Explorer 9</code> 或更早期的浏览器触发怪异模式。</p></blockquote><h2 id="标准模式和怪异模式的区别"><a href="#标准模式和怪异模式的区别" class="headerlink" title="标准模式和怪异模式的区别"></a>标准模式和怪异模式的区别</h2><ul><li><p>盒模型的处理差异<br>标准 <code>CSS</code> 盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而 <code>IE6</code> 之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于 <code>IE</code>，怪异模式和标准模式下的盒模型宽高计算方式是不一样的；</p></li><li><p>行内元素的垂直对齐<br>很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然 <code>CSS</code> 的规范要求它们被对齐至盒内文本的基线。标准模式下，基于 <code>Gecko</code> 的浏览器将会对齐至基线，而在 <code>quirks</code> 模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。具体请看这篇文章 <a href="https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/" target="_blank" rel="noopener">CSS 深入理解 vertical-align 和 line-height 的基友关系</a>。</p></li></ul><h2 id="多语言"><a href="#多语言" class="headerlink" title="多语言"></a>多语言</h2><p>当客户端向服务器发送 <code>HTTP</code> 请求时，通常会发送有关语言首选项的信息，比如使用 <code>Accept-Language</code> 请求头。如果替换语言存在，服务器可以利用该信息返回与之相匹配的 <code>HTML</code> 文档。返回的 <code>HTML</code> 文档还应在 <code>&lt;html&gt;</code> 标签中声明 <code>lang</code> 属性，比如 <code>&lt;html lang=&quot;en&quot;&gt;...&lt;/html&gt;</code>。</p><h2 id="HTML5-的基本构件"><a href="#HTML5-的基本构件" class="headerlink" title="HTML5 的基本构件"></a>HTML5 的基本构件</h2><ul><li>语义 - 提供更准确地描述内容。</li><li>连接 - 提供新的方式与服务器通信。</li><li>离线和存储 - 允许网页在本地存储数据并有效地离线运行。</li><li>多媒体 - 在 <code>Open Web</code> 中，视频和音频被视为一等公民（<code>first-class citizens</code>）。</li><li>2D/3D 图形和特效 - 提供更多种演示选项。</li><li>性能和集成 - 提供更快的访问速度和性能更好的计算机硬件。</li><li>设备访问 - 允许使用各种输入、输出设备。</li><li>外观 - 可以开发丰富的主题。</li></ul><h2 id="cookie、sessionStorage-和-localStorage-的区别"><a href="#cookie、sessionStorage-和-localStorage-的区别" class="headerlink" title="cookie、sessionStorage 和 localStorage 的区别"></a>cookie、sessionStorage 和 localStorage 的区别</h2><table><thead><tr><th></th><th>cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>由谁初始化</td><td>客户端或服务器，服务器可以使用 Set-Cookie 响应头。</td><td>客户端</td><td>客户端</td></tr><tr><td>过期时间</td><td>手动设置</td><td>永不过期</td><td>当前页面关闭时</td></tr><tr><td>在当前浏览器会话（<code>browser sessions</code>）中是否保持不变</td><td>取决于是否设置了过期时间</td><td>是</td><td>否</td></tr><tr><td>是否随着每个 <code>HTTP</code> 请求发送给服务器</td><td>是，<code>Cookies</code> 会通过 <code>Cookie</code> 请求头，自动发送给服务器</td><td>否</td><td>否</td></tr><tr><td>容量（每个域名，每个域名都有单独的存储）</td><td>4kb</td><td>5MB</td><td>5MB</td></tr><tr><td>访问权限</td><td>任意窗口</td><td>任意窗口</td><td>当前页面窗口</td></tr></tbody></table><h2 id="渐进式渲染"><a href="#渐进式渲染" class="headerlink" title="渐进式渲染"></a>渐进式渲染</h2><ul><li>图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，<code>JavaScript</code> 将加载并显示图像。</li><li>确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 <code>CSS</code>、脚本和内容，然后可以使用延迟加载脚本或监听 <code>DOMContentLoaded/load</code> 事件加载其他资源和内容。</li><li>异步加载 <code>HTML</code> 片段——当页面通过后台渲染时，把 <code>HTML</code> 拆分，通过异步请求，分块发送给浏览器。</li></ul><h2 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h2><p>设计响应式图片时我们可以使用两个新的属性 —— <code>srcset</code> 和 <code>sizes</code> —— 来提供更多额外的资源图像和提示，帮助浏览器选择正确的一个资源。</p><p><code>srcset</code> 定义了我们允许浏览器选择的图像集，以及每个图像的大小。</p><p><code>sizes</code> 定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。</p><p>所以，有了这些属性，浏览器会：</p><ol><li>查看设备宽度</li><li>检查 <code>sizes</code> 列表中哪个媒体条件是第一个为真</li><li>查看给予该媒体查询的槽大小</li><li>加载 <code>srcset</code> 列表中引用的最接近所选的槽大小的图像</li></ol><p>更加具体的使用方式可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images" target="_blank" rel="noopener">响应式图片</a></p><h2 id="HTML-与-XHTML-的区别"><a href="#HTML-与-XHTML-的区别" class="headerlink" title="HTML 与 XHTML 的区别"></a>HTML 与 XHTML 的区别</h2><p><code>HTML</code>:</p><ul><li>元素不一定有起始的标签</li><li>元素不一定有结束的标签</li><li>空元素才可以自关闭，如 <code>br</code>、<code>img</code></li><li>标签和属性大小写<strong>不敏感</strong></li><li>属性可以不用双引号</li><li>某些属性可以为空，如 <code>disabled</code>、<code>checked</code></li><li>特殊符号不需要转义</li><li>文档必须包含 <code>HTML5</code> 的 <code>DOCTYPE</code></li></ul><p><code>XHTML</code>:</p><ul><li>所有元素都必须有起始标签</li><li>非空元素如果有起始标签则必须同时有结束标签</li><li>自关闭的元素一定要使用 <code>/&gt;</code></li><li>属性大小写敏感，一般来说都是小写</li><li>属性必须使用双引号引起来</li><li>禁止空属性，必须有值，如 <code>checked=&quot;checked&quot;</code></li><li>特殊符号需要转义</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DOCTYPE&quot;&gt;&lt;a href=&quot;#DOCTYPE&quot; class=&quot;headerlink&quot; title=&quot;DOCTYPE&quot;&gt;&lt;/a&gt;DOCTYPE&lt;/h2&gt;&lt;p&gt;&lt;code&gt;DOCTYPE&lt;/code&gt; 是用来声明文档类型和 &lt;code&gt;DTD&lt;/code&gt; 规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错。&lt;code&gt;HTML&lt;/code&gt; 编辑器通常也会在语法高亮的同时提供合法性验证。&lt;/p&gt;
&lt;p&gt;通常有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HTML5(推荐使用，其他的有触发怪异模式和近标准模式的风险)&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://1016990109.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Linux 命令 —— 配置文件和 Shell 环境</title>
    <link href="http://1016990109.github.io/2018/08/21/Linux-%E5%91%BD%E4%BB%A4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8CShell%E7%8E%AF%E5%A2%83/"/>
    <id>http://1016990109.github.io/2018/08/21/Linux-命令-配置文件和Shell环境/</id>
    <published>2018-08-21T11:31:51.000Z</published>
    <updated>2018-08-24T03:24:06.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h2><p><code>shell</code> 在环境中存储了两种基本类型的数据，虽然 <code>bash</code> 几乎无法分辨这些数据的类型。它们是环境变量和 <code>shell</code> 变量。</p><a id="more"></a><h3 id="检查环境变量"><a href="#检查环境变量" class="headerlink" title="检查环境变量"></a>检查环境变量</h3><p><code>set</code> 显示 <code>shell</code> 变量、<code>shell</code> 函数和环境变量，<code>printenv</code> 只显示环境变量。<code>printenv [name]</code> 还能输出变量的值(当然常用的还是 <code>echo $[name]</code>)。而别名只能通过 <code>alias</code> 来查看。</p><h3 id="建立-shell-环境"><a href="#建立-shell-环境" class="headerlink" title="建立 shell 环境"></a>建立 shell 环境</h3><p>当我们登录系统后，<code>bash</code> 程序启动，并且会读取一系列称为启动文件的配置脚本，这些文件定义了默认的可供所有用户共享的 <code>shell</code> 环境。然后是读取更多位于我们自己家目录中的启动文件，这些启动文件定义了用户个人的 <code>shell</code> 环境。确切的启动顺序依赖于要运行的 <code>shell</code> 会话类型。有两种 <code>shell</code> 会话类型：一个是登录 <code>shell</code> 会话，另一个是非登录 <code>shell</code> 会话。</p><p>登录 <code>shell</code> 会话会在其中提示用户输入用户名和密码；例如，我们启动一个虚拟控制台会话。非登录 <code>shell</code> 会话通常当我们在 <code>GUI</code> 下启动终端会话时出现。</p><p>退出命令：</p><ul><li>执行 <code>exit</code> 命令，退出一个 <code>shell</code>（登录或非登录 <code>shell</code>）；</li><li>执行 <code>logout</code> 命令，退出登录 <code>shell</code>（不能退出非登录 <code>shell</code>）。</li></ul><p>登录 <code>shell</code> 会读取一个或多个启动文件，如下表：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/profile</td><td>应用于所有用户的全局配置脚本。</td></tr><tr><td>~/.bash_profile</td><td>用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr><tr><td>~/.bash_login</td><td>如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。</td></tr><tr><td>~/.profile</td><td>如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。</td></tr></tbody></table><p>非登录 <code>shell</code> 会读取以下启动文件：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/bash.bashrc</td><td>应用于所有用户的全局配置文件。</td></tr><tr><td>~/.bashrc</td><td>用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr></tbody></table><p>除了读取以上启动文件之外，非登录 <code>shell</code> 会话也会继承它们父进程的环境设置，通常是一个登录 <code>shell</code>。</p><p>在普通用户看来，文件 <code>~/.bashrc</code> 可能是最重要的启动文件，因为它几乎总是被读取(每次执行 <code>shell</code> 脚本时都会重新读取)。非登录 <code>shell</code> 默认会读取它，并且大多数登录 <code>shell</code> 的启动文件也会能读取 <code>~/.bashrc</code> 文件。</p><h3 id="一个启动文件的内容"><a href="#一个启动文件的内容" class="headerlink" title="一个启动文件的内容"></a>一个启动文件的内容</h3><p>看一下典型的 <code>.bash_profile</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile</span></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">. ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># User specific environment and startup programs</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改后使用 <code>source ***</code> 激活启动文件。</p><h2 id="vi-简介"><a href="#vi-简介" class="headerlink" title="vi 简介"></a>vi 简介</h2><p>第一版 <code>vi</code> 是在 1976 由 Bill Joy 写成的，当时他是加州大学伯克利分校的学生，后来他共同创建了 <code>Sun</code> 微系统公司。<code>vi</code> 这个名字来源于单词“visual”，因为它打算在带有可移动光标的视频终端上编辑文本。在发明可视化编辑器之前，有一次只能操作一行文本的行编辑器。为了编辑，我们需要告诉行编辑器到一个特殊行并且说明做什么修改，比方说添加或删除文本。视频终端（而不是基于打印机的终端，像电传打印机）的出现，使可视化编辑成为可能。<code>vi</code> 实际上整合了一个强大的行编辑器 ———— ex , 所以我们在使用 <code>vi</code> 时能运行行编辑命令。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><p>按 <code>i</code> 进入插入模式。</p></li><li><p><code>:w</code> 保存。</p></li><li><p><code>u</code> 是 <code>undo</code>。</p></li><li><p><code>p</code> 粘贴到光标位置之后，<code>P</code> 粘贴到光标位置之前。</p></li><li><p>查找：<code>f</code> 命令能搜索一特定行，并将光标移动到下一个匹配的字符上。例如，命令 <code>fa</code> 会把光标定位到同一行中下一个出现的”a”字符上。在进行了一次行内搜索后，输入分号能重复这次搜索。<br>移动光标到下一个出现的单词或短语上，使用 <code>/</code> 命令。当你输入 <code>/</code> 命令后，一个”/”字符会出现在屏幕底部。接下来，输入要查找的单词或短语， 按下回车。光标就会移动到下一个包含所查找字符串的位置。通过 <code>n</code> 命令来重复先前的查找。</p></li><li><p>替换<br><code>vi</code> 使用 <code>ex</code> 命令来执行查找和替代操作（<code>vi</code> 中叫做“替换”）。将整个文件中的单词“Line”更改为“line”， 输入以下命令(后面再加个 <code>c</code> 则每次替换会提醒用户确认)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/Line/line/g</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>条目</th><th>含义</th></tr></thead><tbody><tr><td>:</td><td>冒号字符运行一个 <code>ex</code> 命令。</td></tr><tr><td>%</td><td>指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行。另外，操作范围也 可以用 1,5 来代替（因为我们的文件只有 5 行文本），或者用 1,$ 来代替，意思是 “ 从第一行到文件的最后一行。”如果省略了文本行的范围，那么操作只对当前行生效。</td></tr><tr><td>s</td><td>指定操作。在这种情况下是，替换（查找与替代）。</td></tr><tr><td>/Line/line</td><td>查找类型与替代文本。</td></tr><tr><td>g</td><td>这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略 g，则 只替换每个文本行中第一个匹配的字符串。</td></tr></tbody></table><ul><li>编辑多个文件<br><code>vi file1 file2 file3...</code> 打开多个文件。<br><code>:n</code> 切换到下一个文件。<br><code>:N</code> 切换到上一个文件。<br><code>:buffers</code> 列出文件缓冲，<code>:buffers 缓冲区编号</code> 切换到对应的文件。</li></ul><p>移动光标：</p><table><thead><tr><th>按键</th><th>移动光标</th></tr></thead><tbody><tr><td>l or 右箭头</td><td>向右移动一个字符</td></tr><tr><td>h or 左箭头</td><td>向左移动一个字符</td></tr><tr><td>j or 下箭头</td><td>向下移动一行</td></tr><tr><td>k or 上箭头</td><td>向上移动一行</td></tr><tr><td>0 (零按键)</td><td>移动到当前行的行首。</td></tr><tr><td>^</td><td>移动到当前行的第一个非空字符。</td></tr><tr><td>$</td><td>移动到当前行的末尾。</td></tr><tr><td>w</td><td>移动到下一个单词或标点符号的开头。</td></tr><tr><td>W</td><td>移动到下一个单词的开头，忽略标点符号。</td></tr><tr><td>b</td><td>移动到上一个单词或标点符号的开头。</td></tr><tr><td>B</td><td>移动到上一个单词的开头，忽略标点符号。</td></tr><tr><td>Ctrl-f or Page Down</td><td>向下翻一页</td></tr><tr><td>Ctrl-b or Page Up</td><td>向上翻一页</td></tr><tr><td>numberG</td><td>移动到第 number 行。例如，1G 移动到文件的第一行。</td></tr><tr><td>G</td><td>移动到文件末尾。</td></tr></tbody></table><p>文本删除命令(这个 <code>d</code> 命令不仅删除文本，它还“剪切”文本。)：</p><table><thead><tr><th>命令</th><th>删除的文本</th></tr></thead><tbody><tr><td>x</td><td>当前字符</td></tr><tr><td>3x</td><td>当前字符及其后的两个字符。</td></tr><tr><td>dd</td><td>当前行。</td></tr><tr><td>5dd</td><td>当前行及随后的四行文本。</td></tr><tr><td>dW</td><td>从光标位置开始到下一个单词的开头。</td></tr><tr><td>d$</td><td>从光标位置开始到当前行的行尾。</td></tr><tr><td>d0</td><td>从光标位置开始到当前行的行首。</td></tr><tr><td>d^</td><td>从光标位置开始到文本行的第一个非空字符。</td></tr><tr><td>dG</td><td>从当前行到文件的末尾。</td></tr><tr><td>d20G</td><td>从当前行到文件的第 20 行。</td></tr></tbody></table><p>复制命令：</p><table><thead><tr><th>命令</th><th>复制的内容</th></tr></thead><tbody><tr><td>yy</td><td>当前行。</td></tr><tr><td>5yy</td><td>当前行及随后的四行文本。</td></tr><tr><td>yW</td><td>从当前光标位置到下一个单词的开头。</td></tr><tr><td>y$</td><td>从当前光标位置到当前行的末尾。</td></tr><tr><td>y0</td><td>从当前光标位置到行首。</td></tr><tr><td>y^</td><td>从当前光标位置到文本行的第一个非空字符。</td></tr><tr><td>yG</td><td>从当前行到文件末尾。</td></tr><tr><td>y20G</td><td>从当前行到文件的第 20 行。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Shell-环境&quot;&gt;&lt;a href=&quot;#Shell-环境&quot; class=&quot;headerlink&quot; title=&quot;Shell 环境&quot;&gt;&lt;/a&gt;Shell 环境&lt;/h2&gt;&lt;p&gt;&lt;code&gt;shell&lt;/code&gt; 在环境中存储了两种基本类型的数据，虽然 &lt;code&gt;bash&lt;/code&gt; 几乎无法分辨这些数据的类型。它们是环境变量和 &lt;code&gt;shell&lt;/code&gt; 变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://1016990109.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="http://1016990109.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之JS事件循环</title>
    <link href="http://1016990109.github.io/2018/08/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://1016990109.github.io/2018/08/19/前端基础之JS事件循环/</id>
    <published>2018-08-19T15:22:38.000Z</published>
    <updated>2018-09-04T07:27:31.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>JavaScript</code> 从诞生之日起就是一门单线程的非阻塞的脚本语言</p><p>单线程是必要的，也是 <code>JavaScript</code> 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 <code>DOM</code> 操作。试想一下 如果 <code>JavaScript</code> 是多线程的，那么当两个线程同时对 <code>DOM</code> 进行一项操作，例如一个向其添加事件，而另一个删除了这个 <code>DOM</code>，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，<code>JavaScript</code> 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p><a id="more"></a><p>为了利用多核 <code>CPU</code> 的计算能力，<code>HTML5</code> 提出 <code>Web Worker</code> 标准，允许 <code>JavaScript</code> 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 <code>DOM</code>。所以，这个新标准并没有改变 <code>JavaScript</code> 单线程的本质。</p><h2 id="浏览器-JS-引擎事件循环"><a href="#浏览器-JS-引擎事件循环" class="headerlink" title="浏览器 JS 引擎事件循环"></a>浏览器 JS 引擎事件循环</h2><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>主线程完全可以不管 <code>IO</code> 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 <code>IO</code> 设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（<code>synchronous</code>），另一种是异步任务（<code>asynchronous</code>）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（<code>task queue</code>）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>运行机制如下：</p><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（<code>execution context stack</code>）。<br>（2）主线程之外，还存在一个”任务队列”（<code>task queue</code>）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”<strong>所有</strong>同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p><blockquote><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），<code>IO</code> 设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。除了 <code>IO</code> 设备事件，用户点击事件等也是会进入”任务队列”的。”任务队列”是先进先出的，主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。</p></blockquote><h3 id="macro-task-宏任务-与-micro-task-微任务"><a href="#macro-task-宏任务-与-micro-task-微任务" class="headerlink" title="macro task(宏任务) 与 micro task(微任务)"></a>macro task(宏任务) 与 micro task(微任务)</h3><p>异步任务之间也有执行的优先级，不同的异步任务被分为两类：微任务（<code>micro task</code>）和宏任务（<code>macro task</code>）。</p><p>以下事件属于宏任务：</p><ul><li>setInterval()</li><li>setTimeout()</li></ul><p>以下事件属于微任务：</p><ul><li>new Promise()</li><li>new MutaionObserver()</li></ul><p>在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。</p><p><strong>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</strong></p><p><strong>同类型异步任务按进入的先后顺序依次触发。</strong></p><h2 id="Node-环境下的事件循环"><a href="#Node-环境下的事件循环" class="headerlink" title="Node 环境下的事件循环"></a>Node 环境下的事件循环</h2><p><code>Node.js</code> 也是单线程的 <code>Event Loop</code>，但是它的运行机制不同于浏览器环境。</p><p><code>Node</code> 中事件循环的实现是依靠的 <code>libuv</code> 引擎。我们知道 <code>Node</code> 选择 <code>Chrome v8</code> 引擎作为 <code>js</code> 解释器，<code>v8</code> 引擎将 <code>js</code> 代码分析后去调用对应的 <code>Node API</code>，而这些 <code>API</code> 最后则由 <code>libuv</code> 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 <code>Node</code> 中的事件循环存在于 <code>libuv</code> 引擎中。</p><p>我们来看看 <code>libuv</code> 的事件循环模型：</p><p><img src="/assets/img/node_event_loop.png" alt="node event loop"></p><blockquote><p><code>timers</code>，一个 <code>timer</code> 指定一个下限时间而不是准确时间，在达到这个下限时间后执行回调。在指定的时间过后，<code>timers</code> 会尽早的执行回调，但是系统调度或者其他回调的执行可能会延迟它们。下限的时间有一个范围：[1, 2147483647]，如果设定的时间不在这个范围，将被设置为 1。</p></blockquote><blockquote><p><code>setImmediate()</code> 具有最高优先级，只要 <code>poll</code> 队列为空，代码被 <code>setImmediate()</code>，无论是否有 <code>timers</code> 达到下限时间，<code>setImmediate()</code>的代码都先执行。</p></blockquote><p>我们可以大致分析出 <code>Node</code> 中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(<code>poll</code>)–&gt;检查阶段(<code>check</code>)–&gt;关闭事件回调阶段(<code>close callback</code>)–&gt;定时器检测阶段(<code>timer</code>)–&gt;<code>I/O</code> 事件回调阶段(<code>I/O callbacks</code>)–&gt;闲置阶段(<code>idle</code>, <code>prepare</code>)–&gt;轮询阶段…</p><p>除了 <code>setTimeout</code> 和 <code>setInterval</code> 这两个方法，<code>Node.js</code> 还提供了另外两个与”任务队列”有关的方法：<code>process.nextTick</code> 和 <code>setImmediate</code>。</p><p>执行顺序为 <code>process.nextTick</code>(单独的一个队列) –&gt; 微任务(<code>Promise</code>，<code>MutaionObserver</code>) –&gt; 宏任务(<code>setTimeout</code>，<code>setInterval</code>)/<code>setImmediate</code></p><blockquote><p>注意错误使用 <code>process.nextTick</code> 可能会进入一个死循环，而导致 <code>js</code> 主线程阻塞，而 <code>setTimeout(function, 0)</code> 不会。<code>process.nextTick</code> 在当前”执行栈”执行。</p></blockquote><h3 id="关于-setTimeout-和-setImmediate"><a href="#关于-setTimeout-和-setImmediate" class="headerlink" title="关于 setTimeout 和 setImmediate"></a>关于 setTimeout 和 setImmediate</h3><p><code>setTimeout</code> 和 <code>setImmediate</code> 在 <code>Node</code> 环境下执行是靠“随缘法则”的，执行先后顺序不确定。</p><p>首先进入的是 <code>timers</code> 阶段，如果我们的机器性能一般，那么进入 <code>timers</code> 阶段，一毫秒已经过去了（<code>setTimeout(fn, 0)</code>等价于 <code>setTimeout(fn, 1)</code>），那么 <code>setTimeout</code> 的回调会首先执行。</p><p>如果没有到一毫秒，那么在 <code>timers</code> 阶段的时候，下限时间没到，<code>setTimeout</code> 回调不执行，事件循环来到了 <code>poll</code> 阶段，这个时候队列为空，此时有代码被 <code>setImmediate()</code>，于是先执行了 <code>setImmediate()</code> 的回调函数，之后在下一个事件循环再执行 <code>setTimemout</code> 的回调函数。</p><p>而我们在执行代码的时候，进入 <code>timers</code> 的时间延迟其实是随机的，并不是确定的，所以会出现两个函数执行顺序随机的情况。</p><p>但是有种情况例外：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码，<code>setImmediate</code> 永远优先 <code>setTimeout</code> 执行。</p><p><code>fs.readFile</code> 的回调是在 <code>poll</code> 阶段执行的，当其回调执行完毕之后，<code>poll</code> 队列为空，而 <code>setTimeout</code> 入了 <code>timers</code> 的队列，此时有代码被 <code>setImmediate()</code>，于是事件循环先进入 <code>check</code> 阶段执行回调，之后在下一个事件循环再在 <code>timers</code> 阶段中执行有效回调。</p><p><strong>总结：</strong></p><ul><li>如果两者都在主模块中调用，那么执行先后取决于进程性能，也就是随机。</li><li>如果两者都不在主模块调用（被一个异步操作包裹），那么 <code>setImmediate</code> 的回调永远先执行。</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>为了更好地理解事件循环，可以尝试运行下面的代码，看看结果如何：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行队列(同步) 2 3 5   6 8（6,8为nextTick队列中的)</span></span><br><span class="line"><span class="comment">//任务队列(异步) 4 (1,7顺序不确定)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 从诞生之日起就是一门单线程的非阻塞的脚本语言&lt;/p&gt;
&lt;p&gt;单线程是必要的，也是 &lt;code&gt;JavaScript&lt;/code&gt; 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 &lt;code&gt;DOM&lt;/code&gt; 操作。试想一下 如果 &lt;code&gt;JavaScript&lt;/code&gt; 是多线程的，那么当两个线程同时对 &lt;code&gt;DOM&lt;/code&gt; 进行一项操作，例如一个向其添加事件，而另一个删除了这个 &lt;code&gt;DOM&lt;/code&gt;，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，&lt;code&gt;JavaScript&lt;/code&gt; 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="eventloop" scheme="http://1016990109.github.io/tags/eventloop/"/>
    
      <category term="事件循环" scheme="http://1016990109.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之HTTP/2</title>
    <link href="http://1016990109.github.io/2018/08/15/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP2/"/>
    <id>http://1016990109.github.io/2018/08/15/前端基础之HTTP2/</id>
    <published>2018-08-15T11:00:44.000Z</published>
    <updated>2018-08-16T15:37:13.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>HTTP/2</code> 可以让我们的应用更快、更简单、更稳定。</p><p><code>HTTP/2</code> 的目的是通过支持完整的请求与响应复用来减少延迟，通过有效压缩 <code>HTTP</code> 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持。为达成这些目标，<code>HTTP/2</code> 还给我们带来了大量其他协议层面的辅助实现，例如新的流控制、错误处理和升级机制。</p><p>需要注意的是，<code>HTTP/2</code> 仍是对之前 <code>HTTP</code> 标准的扩展，而非替代。<code>HTTP</code> 的应用语义不变，提供的功能不变，<code>HTTP</code> 方法、状态代码、<code>URI</code> 和标头字段等这些核心概念也不变。</p><a id="more"></a><h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h2><p><code>HTTP/2</code> 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 <code>HTTP</code> 消息并在客户端与服务器之间传输。</p><p><img src="/assets/img/binary_framing_layer01.svg" alt="binary framing layer"></p><h2 id="数据流、消息和帧"><a href="#数据流、消息和帧" class="headerlink" title="数据流、消息和帧"></a>数据流、消息和帧</h2><ul><li>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</li><li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li><li>帧：<code>HTTP/2</code> 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li></ul><p>这些概念的关系总结如下：</p><ul><li>所有通信都在一个 <code>TCP</code> 连接上完成，此连接可以承载任意数量的双向数据流。</li><li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li><li>每条消息都是一条逻辑 <code>HTTP</code> 消息（例如请求或响应），包含一个或多个帧。</li><li>帧是最小的通信单位，承载着特定类型的数据，例如 <code>HTTP</code> 标头、消息负载，等等。来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p><img src="/assets/img/streams_messages_frames01.svg" alt="streams messages frames"></p><h2 id="请求与响应复用"><a href="#请求与响应复用" class="headerlink" title="请求与响应复用"></a>请求与响应复用</h2><p>在 <code>HTTP/1.x</code> 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 <code>TCP</code> 连接。这是 <code>HTTP/1.x</code> 交付模型的直接结果，该模型可以保证每个连接每次只交付一个响应（响应排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 <code>TCP</code> 连接的效率低下。<strong>这就是需要对请求资源的个数做优化的原因(CSS Sprite、合并 js 和 css、内联小资源、利用 HTTP 管道、域名分片)</strong></p><blockquote><p><em>队首阻塞：</em> &gt; <strong>1.<code>http1.0</code> 的队首阻塞</strong><br>对于同一个 <code>tcp</code> 连接，所有的 <code>http1.0</code> 请求放入队列中，只有前一个请求的响应收到了，然后才能发送下一个请求。<br>可见，<code>http1.0</code> 的队首组塞发生在客户端。<br><strong>2.<code>http1.1</code> 的队首阻塞</strong><br>对于同一个 <code>tcp</code> 连接，<code>http1.1</code> 允许一次发送多个 <code>http1.1</code> 请求，也就是说，不必等前一个响应收到，就可以发送下一个请求，这样就解决了 <code>http1.0</code> 的客户端的队首阻塞。但是，<code>http1.1</code> 规定，服务器端的响应的发送要根据请求被接收的顺序排队，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送，也会造成队首阻塞。</p></blockquote><p><code>HTTP/2</code> 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 <code>HTTP</code> 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。就是请求或者响应可以不一起发送，而是分帧发送，哪一个消息的帧准备好了就可以发，而不用等待。</p><h2 id="数据流优先级"><a href="#数据流优先级" class="headerlink" title="数据流优先级"></a>数据流优先级</h2><p>前面提到每个数据流都有一个唯一的标识符和可选的优先级消息，这个优先级消息就包括关联的权重和依赖关系：</p><ul><li>可以向每个数据流分配一个介于 1 至 256 之间的整数。</li><li>每个数据流与其他数据流之间可以存在显式依赖关系。</li></ul><p>总体的规则就是父项优先级更高，也就是 ”根数据流“ 的子项优先级最高，当同级时按照权重分配资源。</p><blockquote><p>注意着不能保证顺序，只是要求，即客户端无法强制服务器通过数据流优先级以特定顺序处理数据流。</p></blockquote><h2 id="每个来源一个连接"><a href="#每个来源一个连接" class="headerlink" title="每个来源一个连接"></a>每个来源一个连接</h2><p>每一个 <code>origin</code> 只需要一个连接，因为每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。因此，所有 <code>HTTP/2</code> 连接都是永久的，而且仅需要每个来源一个连接，随之带来诸多性能优势。</p><blockquote><p>连接数量减少对提升 <code>HTTPS</code> 部署的性能来说是一项特别重要的功能：可以减少开销较大的 <code>TLS</code> 连接数、提升会话重用率，以及从整体上减少所需的客户端和服务器资源。</p></blockquote><h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><p>流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。</p><p><code>HTTP/2</code> 的流量控制具有以下特征：</p><p>1.流量控制是特定于一个连接的。每种类型的流量控制都是在单独的一跳的两个端点之间的，并不是在整个端到端的路径上的。（这里的一跳指的是 <code>HTTP</code> 连接的一跳，而不是 <code>IP</code> 路由的一跳）</p><p>2.流量控制是基于 <code>WINDOW_UPDATE</code> 帧的。接收方公布自己打算在每个流以及整个连接上分别接收多少字节。这是一个以信用为基础的方案。</p><p>3.流量控制是有方向的，由接收者全面控制。接收方可以为每个流和整个连接设置任意的窗口大小。发送方必须尊重接收方设置的流量控制限制。客户方、服务端和中间代理作为接收方时都独立地公布各自的流量控制窗口，作为发送方时都遵守对端的流量控制设置。</p><p>4.无论是新流还是整个连接，流量控制窗口的初始值是 65535 字节。</p><p>5.帧的类型决定了流量控制是否适用于帧。目前，只有 <code>DATA</code> 帧服从流量控制，所有其它类型的帧并不消耗流量控制窗口的空间。这保证了重要的控制帧不会被流量控制阻塞。</p><p>6.流量控制不能被禁用。建立 <code>HTTP/2</code> 连接后，客户端将与服务器交换 <code>SETTINGS</code> 帧，这会在两个方向上设置流控制窗口。流控制窗口的默认值设为 65535(2^16 - 1) 字节，但是接收方可以设置一个较大的最大窗口大小（2^31-1 字节），并在接收到任意数据时通过发送 <code>WINDOW_UPDATE</code> 帧来维持这一大小。</p><p>7.<code>HTTP/2</code> 只定义了 <code>WINDOW_UPDATE</code> 帧的格式和语义，并没有规定接收方如何决定何时发送帧、发送什么样的值，也没有规定发送方如何选择发送包。具体实现可以选择任何满足需求的算法。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p><code>HTTP/2</code> 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。</p><p><img src="/assets/img/server_push.svg" alt="server push"></p><h3 id="PUSH-PROMISE"><a href="#PUSH-PROMISE" class="headerlink" title="PUSH_PROMISE"></a>PUSH_PROMISE</h3><p>所有服务器推送数据流都由 <code>PUSH_PROMISE</code> 帧发起，表明了服务器向客户端推送所述资源的意图，并且需要 <strong>先于请求推送资源的响应数据传输</strong>。这种传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。满足此要求的最简单策略是先于父响应（即，<code>DATA</code> 帧）发送所有 <code>PUSH_PROMISE</code> 帧，其中包含所承诺资源的 <code>HTTP</code> 标头。</p><p>在客户端接收到 <code>PUSH_PROMISE</code> 帧后，它可以根据自身情况选择拒绝数据流（通过 <code>RST_STREAM</code> 帧）。 （如果资源已经位于缓存中，可能会发生这种情况。）这是一个相对于 <code>HTTP/1.x</code> 的重要提升。 相比之下，使用资源内联（一种受欢迎的 <code>HTTP/1.x</code> “优化”）等同于“强制推送”：<strong>客户端无法选择拒绝、取消或单独处理内联的资源</strong>。</p><h2 id="标头压缩"><a href="#标头压缩" class="headerlink" title="标头压缩"></a>标头压缩</h2><p>传统的 <code>HTTP/1.x</code> 传递报文时需要传输标头，有时候会很大(带上 <code>cookie</code> 的时候)，开销过大了。而 <code>HTTP/2</code> 使用 <code>HPACK</code> 压缩格式压缩请求和响应标头元数据，这种格式通过两种方式压缩：</p><ul><li>这种格式支持通过静态 <code>Huffman</code> 代码对传输的标头字段进行编码，从而减小了各个传输的大小。</li><li>这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。</li></ul><p>利用 <code>Huffman</code> 编码，可以在传输时对各个值进行压缩(比如还没建立索引时，传输的 <code>User-Agent</code> 的内容也就是值可以使用霍夫曼编码压缩)，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对(比如之前传递过 <code>MyHeader:test</code> 的头部，建立索引放在动态表中，索引为 62，那么下次传输只用传递索引值 62即可)。</p><p>作为一种进一步优化方式，<code>HPACK</code> 压缩上下文包含一个静态表和一个动态表：静态表在规范中定义，并提供了一个包含所有连接都可能使用的常用 <code>HTTP</code> 标头字段（例如，有效标头名称）的列表；动态表最初为空，将根据在特定连接内交换的值进行更新。因此，为之前未见过的值采用静态 <code>Huffman</code> 编码，并替换每一侧静态表或动态表中已存在值的索引，可以减小每个请求的大小。</p><p>下面是预定义的头字段静态映射表：</p><p><img src="/assets/img/http2_static_table.png" alt="static tabel"></p><blockquote><p>在 <code>HTTP/2</code> 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 <code>:method</code>、<code>:scheme</code>、<code>:authority</code> 和 <code>:path</code> 伪标头字段。</p></blockquote><h3 id="HPACK-的安全性和性能"><a href="#HPACK-的安全性和性能" class="headerlink" title="HPACK 的安全性和性能"></a>HPACK 的安全性和性能</h3><blockquote><p>早期版本的 <code>HTTP/2</code> 和 <code>SPDY</code> 使用 <code>zlib</code>（带有一个自定义字典）压缩所有 <code>HTTP</code> 标头。然而，2012 年夏天，出现了针对 <code>TLS</code> 和 <code>SPDY</code> 压缩算法的“犯罪”安全攻击，此攻击会导致会话被劫持。 于是，<code>zlib</code> 压缩算法被 <code>HPACK</code> 替代，后者经过专门设计，可以解决发现的安全问题、实现起来也更高效和简单，当然，可以对 <code>HTTP</code> 标头元数据进行良好压缩。</p></blockquote><p>关于 <code>HPACK</code> 压缩算法的完成详情查看 <a href="https://tools.ietf.org/html/draft-ietf-httpbis-header-compression" target="_blank" rel="noopener">https://tools.ietf.org/html/draft-ietf-httpbis-header-compression</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developers.google.cn/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li><li><a href="https://www.cnblogs.com/ghj1976/p/4586529.html" target="_blank" rel="noopener">为 HTTP/2 头压缩专门设计的 HPACK</a></li><li><a href="https://www.cnblogs.com/hustdc/p/8487366.html" target="_blank" rel="noopener">http协议的队首阻塞</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HTTP/2&lt;/code&gt; 可以让我们的应用更快、更简单、更稳定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTP/2&lt;/code&gt; 的目的是通过支持完整的请求与响应复用来减少延迟，通过有效压缩 &lt;code&gt;HTTP&lt;/code&gt; 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持。为达成这些目标，&lt;code&gt;HTTP/2&lt;/code&gt; 还给我们带来了大量其他协议层面的辅助实现，例如新的流控制、错误处理和升级机制。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;HTTP/2&lt;/code&gt; 仍是对之前 &lt;code&gt;HTTP&lt;/code&gt; 标准的扩展，而非替代。&lt;code&gt;HTTP&lt;/code&gt; 的应用语义不变，提供的功能不变，&lt;code&gt;HTTP&lt;/code&gt; 方法、状态代码、&lt;code&gt;URI&lt;/code&gt; 和标头字段等这些核心概念也不变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="网络" scheme="http://1016990109.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP/2" scheme="http://1016990109.github.io/tags/HTTP-2/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之关键路径渲染优化</title>
    <link href="http://1016990109.github.io/2018/08/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/"/>
    <id>http://1016990109.github.io/2018/08/09/前端基础之关键路径渲染优化/</id>
    <published>2018-08-09T15:14:24.000Z</published>
    <updated>2018-08-15T11:00:03.092Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器接收到服务器返回的 <code>HTML</code>、<code>CSS</code> 和 <code>JavaScript</code> 字节数据并对其进行解析和转变成像素的渲染过程被称为关键渲染路径。通过优化关键渲染路径即可以缩短浏览器渲染页面的时间。</p><p>浏览器渲染页面前需要先构建 <code>DOM</code> 和 <code>CSSOM</code> 树。因此，我们需要确保尽快将 <code>HTML</code> 和 <code>CSS</code> 都提供给浏览器。</p><a id="more"></a><h2 id="文档对象模型-DOM"><a href="#文档对象模型-DOM" class="headerlink" title="文档对象模型 (DOM)"></a>文档对象模型 (DOM)</h2><p>先看一下浏览器是如何构建 <code>DOM</code> 的：</p><p><img src="/assets/img/dom-full-process.png" alt="dom full process"></p><ol><li>转换： 浏览器从磁盘或网络读取 <code>HTML</code> 的原始字节，并根据文件的指定编码（例如 <code>UTF-8</code>）将它们转换成各个字符。</li><li>令牌化： 浏览器将字符串转换成 <code>W3C HTML5</code> 标准规定的各种令牌，例如，<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li><li>词法分析： 发出的令牌转换成定义其属性和规则的“对象”。</li><li><code>DOM</code> 构建： 最后，由于 <code>HTML</code> 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：<code>HTML</code> 对象是 <code>body</code> 对象的父项，<code>body</code> 是 <code>paragraph</code> 对象的父项，依此类推。</li></ol><h2 id="CSS-对象模型-CSSOM"><a href="#CSS-对象模型-CSSOM" class="headerlink" title="CSS 对象模型 (CSSOM)"></a>CSS 对象模型 (CSSOM)</h2><p>与处理 <code>HTML</code> 时一样，我们需要将收到的 <code>CSS</code> 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 <code>HTML</code> 过程，不过是为 <code>CSS</code> 而不是 <code>HTML</code>：</p><p><img src="/assets/img/cssom-construction.png" alt="cssom construction"></p><p>这就是构建 <code>CSSOM</code> 树的过程。</p><h2 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h2><p>我们根据 <code>HTML</code> 和 <code>CSS</code> 输入构建了 <code>DOM</code> 树和 <code>CSSOM</code> 树。不过，它们都是独立的对象，分别网罗文档不同方面的信息：一个描述内容，另一个则是描述需要对文档应用的样式规则。需要将二者结合生成渲染树才是渲染到屏幕上的东西。</p><p><img src="/assets/img/render-tree-construction.png" alt="render tree construction"></p><p>为构建渲染树，浏览器大体上完成了下列工作：</p><p>1.从 <code>DOM</code> 树的根节点开始遍历每个可见节点。</p><ul><li>某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。</li><li>某些节点通过 <code>CSS</code> 隐藏，因此在渲染树中也会被忽略，例如，上例中的 <code>span</code> 节点—不会出现在渲染树中，—因为有一个显式规则在该节点上设置了 <code>display: none</code> 属性。(值得注意的是<code>visibility: hidden</code> 属性并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，所以它会被渲染成一个空框)</li></ul><p>2.对于每个可见节点，为其找到适配的 <code>CSSOM</code> 规则并应用它们。</p><p>3.发射可见节点，连同其内容和计算的样式。</p><p>渲染树构建完毕后，浏览器得到了每个可见节点的内容与其样式，下一步工作则需要计算每个节点在窗口内的确切位置与大小，也就是 <strong>布局阶段</strong>。</p><p>布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小，所有相对的测量值也都会被转换为屏幕内的绝对像素值。</p><h2 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h2><p>1.处理 HTML 标记并构建 DOM 树。</p><p>2.处理 CSS 标记并构建 CSSOM 树。</p><p>3.将 DOM 与 CSSOM 合并成一个渲染树。</p><p>4.根据渲染树来布局，以计算每个节点的几何信息。</p><p>5.将各个节点绘制到屏幕上。</p><p><strong>优化关键渲染路径_就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间</strong></p><h2 id="阻塞渲染的-CSS"><a href="#阻塞渲染的-CSS" class="headerlink" title="阻塞渲染的 CSS"></a>阻塞渲染的 CSS</h2><p><code>CSS</code> 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p><p>通过使用媒体查询，我们可以根据特定用例（比如显示或打印），也可以根据动态情况（比如屏幕方向变化、尺寸调整事件等）定制外观。<strong>声明样式表资产时，请密切注意媒体类型和查询，因为它们将严重影响关键渲染路径的性能</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"other.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"(min-width: 40em)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>像上面的第一个适用所有情况，故而会阻塞渲染；而第二个和第三个分别适应打印时和屏幕宽度大于 <code>40em</code> 时，所以不会阻塞渲染。</p><blockquote><p>请注意“阻塞渲染”仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 <code>CSS</code> 资源，只不过不阻塞渲染的资源优先级较低罢了。</p></blockquote><h2 id="优化-JavaScript"><a href="#优化-JavaScript" class="headerlink" title="优化 JavaScript"></a>优化 JavaScript</h2><ul><li><code>JavaScript</code> 可以查询和修改 <code>DOM</code> 与 <code>CSSOM</code>。</li><li><code>JavaScript</code> 执行会阻止 <code>CSSOM</code>。</li><li>除非将 <code>JavaScript</code> 显式声明为异步，否则它会阻止构建 <code>DOM</code>。</li></ul><p>可以将脚本标记为异步防止阻塞 <code>DOM</code> 和 <code>CSSOM</code> 构建：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="优化关键渲染路径总结"><a href="#优化关键渲染路径总结" class="headerlink" title="优化关键渲染路径总结"></a>优化关键渲染路径总结</h2><ul><li><p>关键资源：可能阻塞网页首次渲染的资源。</p></li><li><p>关键路径长度：获取关键资源所需的往返次数或总时间。</p></li><li><p>关键字节：所有关键资源文件大小的总和。</p></li></ul><p>优化关键渲染路径就是在对关键资源、关键路径长度和关键字节进行优化。关键资源越少，浏览器在渲染前的准备工作就越少；同样，关键路径长度和关键字节关系到浏览器下载资源的效率，它们越少，浏览器下载资源的速度就越快。</p><blockquote><p>评估关键渲染路径可以使用 <code>Lighthouse</code> 审核页面，参阅 <a href="https://developers.google.cn/web/tools/lighthouse/?hl=zh-cn" target="_blank" rel="noopener">使用 Lighthouse 审核网络应用</a>。</p></blockquote><h2 id="PageSpeed-规则和建议"><a href="#PageSpeed-规则和建议" class="headerlink" title="PageSpeed 规则和建议"></a>PageSpeed 规则和建议</h2><ul><li><p>优化 <code>JavaScript</code> 的使用<br>避免同步服务器调用<br>延迟解析 <code>JavaScript</code>，<code>async</code> 和 <code>defer</code><br>避免运行时间长的 <code>JavaScript</code></p></li><li><p>优化 CSS 的使用<br>将 <code>CSS</code> 置于文档 <code>head</code> 标签内，尽早下载<br>避免使用 <code>CSS import</code>，它们会在关键路径中增加往返次数<br>内联阻塞渲染的 <code>CSS</code>，这样不会增加关键路径中增加往返次数</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器接收到服务器返回的 &lt;code&gt;HTML&lt;/code&gt;、&lt;code&gt;CSS&lt;/code&gt; 和 &lt;code&gt;JavaScript&lt;/code&gt; 字节数据并对其进行解析和转变成像素的渲染过程被称为关键渲染路径。通过优化关键渲染路径即可以缩短浏览器渲染页面的时间。&lt;/p&gt;
&lt;p&gt;浏览器渲染页面前需要先构建 &lt;code&gt;DOM&lt;/code&gt; 和 &lt;code&gt;CSSOM&lt;/code&gt; 树。因此，我们需要确保尽快将 &lt;code&gt;HTML&lt;/code&gt; 和 &lt;code&gt;CSS&lt;/code&gt; 都提供给浏览器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://1016990109.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之浏览器性能优化</title>
    <link href="http://1016990109.github.io/2018/08/02/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://1016990109.github.io/2018/08/02/前端基础之浏览器性能优化/</id>
    <published>2018-08-02T15:43:25.000Z</published>
    <updated>2018-10-12T01:15:18.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渲染性能"><a href="#渲染性能" class="headerlink" title="渲染性能"></a>渲染性能</h1><h2 id="重绘重排"><a href="#重绘重排" class="headerlink" title="重绘重排"></a>重绘重排</h2><p>以下三种情况会导致网页重新渲染：</p><ul><li>修改 DOM</li><li>修改样式表</li><li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li></ul><a id="more"></a><p>需要注意的是，”重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，”重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。像重绘一般很难避免，所以这里不讨论。</p><h3 id="减少重排方案"><a href="#减少重排方案" class="headerlink" title="减少重排方案"></a>减少重排方案</h3><p>1.分离读写操作<br><code>DOM</code> 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><p>2.如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</p><p>3.不要一条条地改变样式，而要通过改变 <code>class</code>，或者 <code>csstext</code> 属性，一次性地改变样式。</p><p>4.尽量使用离线 <code>DOM</code>，而不是真实的网面 <code>DOM</code>，来改变元素样式。比如，操作 <code>Document Fragment</code> 对象，完成后再把这个对象加入 <code>DOM</code>。再比如，使用 <code>cloneNode()</code> 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</p><p>5.先将元素设为 <code>display: none</code>（需要 1 次重排和重绘），然后对这个节点进行 100 次操作，最后再恢复显示（需要 1 次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达 100 次的重新渲染。</p><p>6.<code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code> 的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。原理就是使得元素不再同一层，<strong>基于这种想法还可以使用 <code>transform:translateZ(0);</code> 或者 <code>will-change:transform</code> 来创建新层</strong>，同样能减少重排，一般是对有动画的元素，因为重排很会频繁。</p><p>7.只在必要的时候，才将元素的 <code>display</code> 属性为可见，因为不可见的元素不影响重排和重绘。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。先把元素设置为 <code>display:none</code> 最后再 <code>display:block</code> 就只会触发两次次重绘重排，一次消失，一次出现。</p><p>8.使用 <code>createDocumentFragment</code> 来创建 <code>DocumentFragment</code>(不属于文档树)，把需要插入的节点放到其中，最后再把 <code>DocumentFragment</code> 插入到文档流。当请求把一个 <code>DocumentFragment</code> 节点插入文档树时，插入的不是 <code>DocumentFragment</code> 自身，而是它的所有子孙节点。这使得 <code>DocumentFragment</code> 成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。</p><p>9.使用 <code>cloneNode(true or false)</code> 和 <code>replaceChild</code> 技术，引发一次回流和重绘；</p><p>10.使用虚拟 <code>DOM</code> 的脚本库，比如 <code>React</code> 等。</p><p>11.使用 <code>window.requestAnimationFrame()</code>、<code>window.requestIdleCallback()</code> 这两个方法调节重新渲染（详见后文）。</p><h2 id="刷新率"><a href="#刷新率" class="headerlink" title="刷新率"></a>刷新率</h2><p>网页动画的每一帧（<code>frame</code>）都是一次重新渲染。每秒低于 24 帧的动画，人眼就能感受到停顿。一般的网页动画，需要达到每秒 30 帧到 60 帧的频率，才能比较流畅。如果能达到每秒 70 帧甚至 80 帧，就会极其流畅。</p><p>如果想达到 60 帧的刷新率，就意味着 <code>JavaScript</code> 线程每个任务的耗时，必须少于 16 毫秒。一个解决办法是使用 <code>Web Worker</code>，主线程只用于 <code>UI</code> 渲染，然后跟 <code>UI</code> 渲染不相干的任务，都放在 <code>Worker</code> 线程。</p><h3 id="开发者工具-Timeline"><a href="#开发者工具-Timeline" class="headerlink" title="开发者工具 Timeline"></a>开发者工具 Timeline</h3><p><code>Chrome</code> 或 <code>Safari</code> 之类的浏览器在开发者模式下有个 <code>Timeline</code> 的选项卡，可以录制一段时间内浏览器性能的问题，有帧模式和事件模式，可以互相切换。横条的是”事件模式”（<code>Event Mode</code>），显示重新渲染的各种事件所耗费的时间；竖条的是”帧模式”（<code>Frame Mode</code>），显示每一帧的时间耗费在哪里。</p><p>帧模式有两条水平线，下面的一条是 <code>60FPS</code>，低于这条线，可以达到每秒 60 帧；上面的一条是 <code>30FPS</code>，低于这条线，可以达到每秒 30 次渲染。如果色柱都超过 <code>30FPS</code>，这个网页就有性能问题了。</p><h2 id="PerformanceObserver"><a href="#PerformanceObserver" class="headerlink" title="PerformanceObserver"></a>PerformanceObserver</h2><p>这是个性能监测的 <code>API</code>，可以观察不同性能类型。</p><p><code>Google</code> 提出了以用户为中心的四个衡量指标：</p><ol><li>Is it happening? First Paint (<code>FP</code>,首次渲染,背景颜色之类的) / First Contentful Paint (<code>FCP</code>,首次内容渲染,有 <code>DOM</code> 出现)</li><li>Is it useful? First Meaningful Paint (<code>FMP</code>,首次有意义渲染) / Hero Element Timing</li><li>Is it usable? Time to Interactive (<code>TTI</code>,可以交互时间)</li><li>Is it delightful? Long Tasks(长任务)</li></ol><p><img src="/assets/img/perf-metrics-load-timeline.png" alt="perf-metrics-load-timeline"></p><ul><li><p>跟踪 <code>FP/FCP</code>，监听 <code>paint</code> 事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> PerformanceObserver(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.getEntries()) &#123;</span><br><span class="line">    <span class="comment">// `name` will be either 'first-paint' or 'first-contentful-paint'.</span></span><br><span class="line">    <span class="keyword">const</span> metricName = entry.name</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Math</span>.round(entry.startTime + entry.duration)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送到 Google Analytics</span></span><br><span class="line">    ga(<span class="string">'send'</span>, <span class="string">'event'</span>, &#123;</span><br><span class="line">      eventCategory: <span class="string">'Performance Metrics'</span>,</span><br><span class="line">      eventAction: metricName,</span><br><span class="line">      eventValue: time,</span><br><span class="line">      nonInteraction: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">observer.observe(&#123; <span class="attr">entryTypes</span>: [<span class="string">'paint'</span>] &#125;)</span><br></pre></td></tr></table></figure></li><li><p>同理监听 <code>longtask</code> 事件，可以发现阻塞主进程的长任务进而进行优化。</p></li><li><p><code>FMP</code><br>关于页面有效内容，或者“Hero element”，由于依赖具体实现，并没有给出通用方法。 具体可以使用 <a href="https://speedcurve.com/blog/user-timing-and-custom-metrics/" target="_blank" rel="noopener">performance api 度量指标</a>。</p></li><li><p><code>TTI</code><br>对于 <code>TTI</code> 可以使用 <a href="https://github.com/GoogleChromeLabs/tti-polyfill" target="_blank" rel="noopener">tti-polyfill</a> 的垫片来完成对 <code>TTI</code> 的监控：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ttiPolyfill <span class="keyword">from</span> <span class="string">'./path/to/tti-polyfill.js'</span></span><br><span class="line"></span><br><span class="line">ttiPolyfill.getFirstConsistentlyInteractive().then(<span class="function"><span class="params">tti</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//发送到 Google Analytics</span></span><br><span class="line">  ga(<span class="string">'send'</span>, <span class="string">'event'</span>, &#123;</span><br><span class="line">    eventCategory: <span class="string">'Performance Metrics'</span>,</span><br><span class="line">    eventAction: <span class="string">'TTI'</span>,</span><br><span class="line">    eventValue: tti,</span><br><span class="line">    nonInteraction: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>input latency(输入延迟)<br>有时候鼠标事件可能会超过很长一段时间才响应，这也是需要我们发现并解决的，可以用当前时间与事件事件比较得出结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subscribeBtn = <span class="built_in">document</span>.querySelector(<span class="string">'#subscribe'</span>);</span><br><span class="line"></span><br><span class="line">subscribeBtn.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="comment">// Event listener logic goes here...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lag = performance.now() - event.timeStamp;</span><br><span class="line">  <span class="keyword">if</span> (lag &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    ga(<span class="string">'send'</span>, <span class="string">'event'</span>, &#123;</span><br><span class="line">      eventCategory: <span class="string">'Performance Metric'</span></span><br><span class="line">      eventAction: <span class="string">'input-latency'</span>,</span><br><span class="line">      eventLabel: <span class="string">'#subscribe:click'</span>,</span><br><span class="line">      eventValue: <span class="built_in">Math</span>.round(lag),</span><br><span class="line">      nonInteraction: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在某一个根元素上绑定对应监测事件，获得时间差，大于 100ms 则发送报告。</p></li></ul><h2 id="window-requestAnimationFrame"><a href="#window-requestAnimationFrame" class="headerlink" title="window.requestAnimationFrame"></a>window.requestAnimationFrame</h2><p><code>window.requestAnimationFrame(callback)</code> 方法可以将某些代码放到下一次重新渲染时执行。</p><p>页面滚动事件（<code>scroll</code>）的监听函数，就很适合用 <code>window.requestAnimationFrame()</code> ，推迟到下一次重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(scrollHandler)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是得注意一个问题，像滚动或者触屏事件可能频繁触发，导致在一帧内多次渲染，造成不必要的计算与绘制，解决方法一个是使用节流函数，另一个比较完美的方法就是通过 <code>requestAnimationFrame</code> 来管理队列，其思路就是保证 <code>requestAnimationFrame</code> 的队列里，同样的回调函数只有一个。示意代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scheduledAnimationFrame = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> onScroll = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (scheduledAnimationFrame) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduledAnimationFrame = <span class="literal">true</span></span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(scrollHandler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll)</span><br></pre></td></tr></table></figure><p>当然，最适用的场合还是网页动画。下面是一个旋转动画的例子，元素每一帧旋转 1 度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rAF = <span class="built_in">window</span>.requestAnimationFrame</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> degrees = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  div.style.transform = <span class="string">'rotate('</span> + degrees + <span class="string">'deg)'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'updated to degrees '</span> + degrees)</span><br><span class="line">  degrees = degrees + <span class="number">1</span></span><br><span class="line">  rAF(update)</span><br><span class="line">&#125;</span><br><span class="line">rAF(update)</span><br></pre></td></tr></table></figure><h2 id="window-requestIdleCallback"><a href="#window-requestIdleCallback" class="headerlink" title="window.requestIdleCallback()"></a>window.requestIdleCallback()</h2><p>另一个比较冷门的就是 <code>window.requestIdleCallback(callback [,timeout])</code> 了，这个函数指定只有当一帧的末尾有空闲时间，才会执行回调函数。也就是说只有当前帧的运行时间小于 16.66ms 时，函数 <code>callback</code> 才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。</p><p>第二个参数代表过了规定时间后如果还没出发就强制执行，怕浏览器一直很忙而来不及渲染。</p><p><code>callback</code> 可以接收 <code>deadline</code> 作为参数，<code>deadline</code> 对象有一个方法和一个属性：<code>timeRemaining()</code> 和 <code>didTimeout</code>。</p><p><code>timeRemaining()</code> 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于 0，就把任务分配到下一轮 <code>requestIdleCallback</code>。<code>didTimeout</code> 属性会返回一个布尔值，表示指定的时间是否过期。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//当前帧还有空余时间就做任务，如果任务没做完移动到下一个 requestIdleCallback</span></span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    (deadline.timeRemaining() &gt; <span class="number">0</span> || deadline.didTimeout) &amp;&amp;</span><br><span class="line">    tasks.length &gt; <span class="number">0</span></span><br><span class="line">  )</span><br><span class="line">    doWorkIfNeeded()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>) requestIdleCallback(myNonEssentialWork)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(myNonEssentialWork, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>上面代码确保了，<code>doWorkIfNeeded</code> 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。</p><h2 id="使输入处理程序去除抖动"><a href="#使输入处理程序去除抖动" class="headerlink" title="使输入处理程序去除抖动"></a>使输入处理程序去除抖动</h2><p>输入处理程序可能是应用出现性能问题的原因，因为它们可能阻止帧完成，并且可能导致额外（且不必要）的布局工作。</p><p>解决方案如下：</p><ul><li>避免长时间运行输入处理程序；它们可能阻止滚动。</li><li>不要在输入处理程序中进行样式更改。</li><li>使处理程序去除抖动；存储事件值并在下一个 <code>requestAnimationFrame</code> 回调中处理样式更改(<strong>注意更改样式放到最后，读取操作放在更改样式之前，以免发生强制同步布局</strong>)。</li></ul><p>去抖动：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onScroll</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Store the scroll value for laterz.</span></span><br><span class="line">  lastScrollY = <span class="built_in">window</span>.scrollY</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent multiple rAF callbacks.</span></span><br><span class="line">  <span class="keyword">if</span> (scheduledAnimationFrame) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  scheduledAnimationFrame = <span class="literal">true</span></span><br><span class="line">  requestAnimationFrame(readAndUpdatePage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll)</span><br></pre></td></tr></table></figure><p>可以发现是先存储了 <code>window.scrollY</code>，然后在 <code>requestAnimationFram</code> 的回调函数中再去获取这个值，不用担心触发强制同步布局；使用 <code>scheduledAnimationFrame</code> 来防止抖动；这样做还有一个好处是使输入处理程序轻量化，效果非常好，因为现在您不用去阻止计算开销很大的代码的操作，处理逻辑都放到了 <code>requestAnimationFrame</code> 的回调函数中执行了！</p><h2 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h2><p>todo</p><h1 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h1><h2 id="压缩资源"><a href="#压缩资源" class="headerlink" title="压缩资源"></a>压缩资源</h2><ul><li><p>源码压缩：预处理和环境特定优化<br>压缩冗余或不必要数据的最佳方法是将其全部消除。我们不能只是删除任意数据，但在某些环境中，我们可能对数据格式及其属性有内容特定了解，往往可以在不影响其实际含义的情况下显著减小负载的大小。<br>比如消除 <code>CSS</code>, <code>JS</code>的注释，空格等等。</p></li><li><p>通过 <code>GZIP</code> 压缩文本<br><code>GZIP</code> 对基于文本的资产的压缩效果最好：<code>CSS</code>、<code>JavaScript</code> 和 <code>HTML</code>。<br>所有现代浏览器都支持 <code>GZIP</code> 压缩，并且会自动请求该压缩。<br>您的服务器必须配置为启用 <code>GZIP</code> 压缩。<br>某些 <code>CDN</code> 需要特别注意以确保 <code>GZIP</code> 已启用。</p></li></ul><h2 id="图像优化"><a href="#图像优化" class="headerlink" title="图像优化"></a>图像优化</h2><ul><li>消除多余的图像资源</li><li>尽可能利用 <code>CSS3</code> 效果，因为 <code>CSS3</code> 可能会启动 <code>GPU</code> 加速，这样就在单独的线程中去完成动画了，而不需要在主线程中，参考 <a href="https://developers.google.com/web/fundamentals/design-and-ux/animations/animations-and-performance?hl=zh-cn" target="_blank" rel="noopener">动画与性能</a></li><li>使用网页字体取代在图像中进行文本编码</li><li>使用矢量图(SVG)，还可以同时使用 <code>GZIP</code> 压缩</li><li>将图片格式转为 <code>WebP</code> 来压缩图片(有些浏览器不支持需要注意)</li><li>一些 <code>CDN</code> 也提供图片的优化</li><li>懒加载(将页面里所有 <code>img</code> 属性 <code>src</code> 属性用 <code>data-xx</code> 代替，当页面滚动直至此图片出现在可视区域时，用 <code>js</code> 取到该图片的 <code>data-xx</code> 的值赋给 <code>src</code>，<code>onscroll</code> 监听每一个 <code>li</code> 的 <code>scrollTop</code>，或者对于 <code>css</code> 属性的图片可以动态添加 <code>visible</code> 的 <code>class</code> 来完成，比如初始化的时候找一张 <code>holder</code> 的图片，等到滚动到可视区域后加上 <code>visible</code> 的 <code>class</code> 来替换成真实的图片)。这里可以了解一下 <code>IntersectionObserver API</code> 来检测对象是否在用户可视区。<strong>有时候为了节约渲染性能会使用和图片相同大小的占位符</strong></li><li>大的 <code>GIF</code> 可以转化为视频，减少加载时间</li><li>使用 <code>Progressive JPEG</code>(这种加载时从低分辨率到高分辨率，从模糊到清晰) 代替传统的 <code>JPEG</code>(这种是 Baseline 的，从上加载到下，需要等待加载完才知道图片是啥)，更加具体的细节可以查看谷歌文档 <a href="https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/automating-image-optimization/?hl=zh-cn" target="_blank" rel="noopener">automating-image-optimization</a></li><li>视频使用 <code>preload=&quot;none&quot;</code> 来阻止预加载视频，有时可以使用 <code>GIF</code> 替换视频</li></ul><h2 id="JS-优化"><a href="#JS-优化" class="headerlink" title="JS 优化"></a>JS 优化</h2><ul><li>只发送用户需要的，可使用代码分割技术，例如 <code>webpack</code> 中的 <code>code-spliting</code>。</li><li>缩小，<code>UglifyJS</code> 缩小 <code>ES5</code> 的代码，使用 <code>babel-minify</code> 来缩小 <code>ES6</code> 及以上代码。</li><li>压缩，<code>GZIP</code>。</li><li>使用 <code>HTTP</code> 缓存。</li><li>加载第三方脚本可以使用 <code>async</code> 或者 <code>defer</code> 属性。</li><li>移除未引用的代码，<code>tree-shaking</code>。</li></ul><p><img src="/assets/img/async_defer.png" alt="aysnc-defer"></p><p>这里可以看到 <code>async</code> 与 <code>defer</code> 的区别，<code>async</code> 是使得脚本的下载和 <code>DOM</code> 的解析同时进行，当脚本下载好的时候立即停止 <code>DOM</code> 解析然后执行脚本；而 <code>defer</code> 虽然也是同时下载和解析，但是就算下载完成了也是需要等待 <code>DOM</code> 解析完成了才可以执行。</p><h2 id="字体优化"><a href="#字体优化" class="headerlink" title="字体优化"></a>字体优化</h2><ul><li>在构建渲染树之前会延迟字体请求，这可能会导致文本渲染延迟，<code>CSS</code> 已经下载完并与 <code>DOM</code> 共同构建渲染树，这个时候如果需要请求字体可能会阻塞渲染，产生了“空白文本问题”，出现该问题时，浏览器会在渲染网页布局时遗漏所有文本。</li><li>可以通过 <code>Font Loading API</code> 实现自定义字体加载和渲染策略，以替换默认延迟加载字体加载。</li><li>可以通过字体内联替换较旧浏览器中的默认延迟加载字体加载。</li></ul><h3 id="通过-Font-Loading-API-优化字体渲染"><a href="#通过-Font-Loading-API-优化字体渲染" class="headerlink" title="通过 Font Loading API 优化字体渲染"></a>通过 Font Loading API 优化字体渲染</h3><p><a href="https://drafts.csswg.org/css-font-loading/" target="_blank" rel="noopener">Font Loading API</a> 提供了一种脚本编程接口来定义和操纵 <code>CSS</code> 字体，追踪其下载进度，以及替换其默认延迟下载行为。例如，如果您确定将需要特定字体变体，您可以定义它并指示浏览器启动对字体资源的立即获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> font = <span class="keyword">new</span> FontFace(<span class="string">'Awesome Font'</span>, <span class="string">'url(/fonts/awesome.woff2)'</span>, &#123;</span><br><span class="line">  style: <span class="string">'normal'</span>,</span><br><span class="line">  unicodeRange: <span class="string">'U+000-5FF'</span>,</span><br><span class="line">  weight: <span class="string">'400'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">font.load() <span class="comment">// don't wait for the render tree, initiate an immediate fetch!</span></span><br><span class="line"></span><br><span class="line">font.ready().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// apply the font (which may re-render text and cause a page reflow)</span></span><br><span class="line">  <span class="comment">// after the font has finished downloading</span></span><br><span class="line">  <span class="built_in">document</span>.fonts.add(font)</span><br><span class="line">  <span class="built_in">document</span>.body.style.fontFamily = <span class="string">'Awesome Font, serif'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// OR... by default the content is hidden,</span></span><br><span class="line">  <span class="comment">// and it's rendered after the font is available</span></span><br><span class="line">  <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</span><br><span class="line">  content.style.visibility = <span class="string">'visible'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// OR... apply your own render strategy here...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="通过内联优化字体渲染"><a href="#通过内联优化字体渲染" class="headerlink" title="通过内联优化字体渲染"></a>通过内联优化字体渲染</h3><p>使用 <code>Font Loading API</code> 消除“空白文本问题”的简单替代策略是将字体内容内联到 <code>CSS</code> 样式表内：</p><ul><li>浏览器会使用高优先级自动下载具有匹配媒体查询的 <code>CSS</code> 样式表，因为需要使用它们来构建 <code>CSSOM</code>。</li><li>将字体数据内联到 <code>CSS</code> 样式表中会强制浏览器使用高优先级下载字体，而不等待渲染树。即它起到的是手动替换默认延迟加载行为的作用。</li></ul><h2 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h2><p>一些需要离线的资源(下次也能用上，如购物车)也可以考虑放到本地存储里，如 <code>localStorage</code>、<code>sessionStorage</code> 等等。</p><p>离线的图片可以使用 <code>Cache API</code> 来完成，详情查看 <a href="https://developers.google.cn/web/fundamentals/instant-and-offline/web-storage/cache-api?hl=zh-cn" target="_blank" rel="noopener">Using the Cache API</a>。</p><p>当数据量较大的时候，就可能用到 <code>IndexedDB</code> 来存储了。注意使用的时候需要注意并不是所有的类型都能写到 <code>IndexedDB</code> 中的，<code>IOS</code> 上的 <code>Safari</code> 是不能存储 <code>Blob</code> 类型的数据的，但是 <code>ArrayBuffer</code> 类型就是比较通用的了。写入可能失败，开发者需要意识到这一点，添加错误的监听函数。</p><h2 id="使用-CDN-加速"><a href="#使用-CDN-加速" class="headerlink" title="使用 CDN 加速"></a>使用 CDN 加速</h2><p>一般网站还会使用 <code>CDN</code> 来加速，使用离用户最近的节点给用户提供资源。详情查看 <a href="https://www.cnblogs.com/losbyday/p/5843960.html" target="_blank" rel="noopener">CDN 技术详解</a>。</p><h2 id="使用-HTTP-缓存"><a href="#使用-HTTP-缓存" class="headerlink" title="使用 HTTP 缓存"></a>使用 HTTP 缓存</h2><p>详情查看另一篇博客 <a href="/2018/08/09/前端基础之网络/#强缓存与协商缓存">前端基础之网络–强缓存与协商缓存</a>。</p><h2 id="关键路径渲染优化"><a href="#关键路径渲染优化" class="headerlink" title="关键路径渲染优化"></a>关键路径渲染优化</h2><p>详情查看另一篇博客 <a href="/2018/08/09/前端基础之关键路径渲染优化/index.html">前端基础之关键路径渲染优化</a>。</p><h2 id="PRPL-模式"><a href="#PRPL-模式" class="headerlink" title="PRPL 模式"></a>PRPL 模式</h2><p><code>PRPL</code> 是一种用于结构化和提供 <code>Progressive Web App</code> (<code>PWA</code>) 的模式，该模式强调应用交付和启动的性能。 它代表：</p><ul><li>推送 - 为初始网址路由推送关键资源。(Push critical resources for the initial route.)</li><li>渲染 - 渲染初始路由。(Render initial route.)</li><li>预缓存 - 预缓存剩余路由。(Pre-cache remaining routes.)</li><li>延迟加载 - 延迟加载并按需创建剩余路由。(Lazy-load and create remaining routes on demand.)</li></ul><p>像下面这种应用结构就很适合用 <code>RPRL</code> 模式：</p><ol><li>应用的主<em>进入点</em>从每个有效的路由提供。 此文件应非常小，它从不同网址提供，因此会被缓存多次。 进入点的所有资源网址都需要是绝对网址，因为它可以从非顶级网址提供。</li><li><code>Shell</code> 或 <code>App Shell</code>，包含顶级应用逻辑、路由器，等等。</li><li>延迟加载的应用 _片段_ 。片段可以表示特定视图的代码，或可延迟加载的其他代码（例如，首次绘制不需要的部分主应用，如用户与应用交互前未显示的菜单）。<code>Shell</code> 负责在需要时动态导入片段。</li></ol><p><img src="/assets/img/app-build-components.png" alt="app-build-components"></p><p>在此图表中，实线表示<em>静态依赖项</em>：使用 <code>&lt;link&gt;</code> 和 <code>&lt;script&gt;</code> 标记在文件中标识的外部资源。 虚线表示<em>动态</em>或<em>按需加载的依赖项</em>：根据 <code>Shell</code> 所需加载的文件。</p><p>构建过程会构建一个包含所有这些依赖项的图表，服务器会使用此信息高效地提供文件。 还会为不支持 <code>HTTP/2</code> 的浏览器构建一组硬化捆绑包。</p><h2 id="资源优先级"><a href="#资源优先级" class="headerlink" title="资源优先级"></a>资源优先级</h2><p>不是每个资源的都是同等重要的，浏览器加载资源有一定的优先级(例如 <code>CSS</code> 的加载优先级就比脚本和图片要高)。</p><h3 id="浏览器默认优先级"><a href="#浏览器默认优先级" class="headerlink" title="浏览器默认优先级"></a>浏览器默认优先级</h3><p>一般来说 <code>HTML</code> 和 <code>CSS</code> 有同样高的优先级(<code>Highest</code>)，而在 <code>head</code> 标签中的 <code>script</code> 标签的优先级就是 <code>High</code>，在 <code>body</code> 里最后时是 <code>Medium</code>，但是如加上了 <code>async</code> 属性那么优先级就会变成 <code>Low</code>，等等。具体的读者可以打开 <code>Chrome</code> 的开发者工具中的 <code>Network</code> 右键表头显示 <code>Priority</code> 查看网站加载资源优先级的详情，如图：</p><p><img src="/assets/img/chrome_priority.png" alt="resources priority"></p><p>那么当你发现资源的优先级和你预想的不一样该怎么办？这里提供三种解决方案，都是和新的 <code>&lt;link&gt;</code> 类型相关的。一方面，如果发现资源对用户是关键的，但是加载优先级却特别低，你可以使用 <code>preload</code> 或者 <code>preconnect</code> 来解决；另一方面，如果想要当其他所有资源都已经处理完毕再让浏览器去获取某些资源，可以使用 <code>prefetch</code>。</p><h3 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h3><p><code>&lt;link rel=&quot;preload&quot;&gt;</code> 告诉浏览器这个资源是当前页面所需要的，需要尽快获取。可以这么使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">as</span>=<span class="string">"script"</span> <span class="attr">href</span>=<span class="string">"super-important.js"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">href</span>=<span class="string">"critical.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>as</code> 属性是用来告诉浏览器资源的类型(<strong>如果类型没有设置那么浏览器是不会拿这个资源来用的</strong>)。大部分基于标签的资源会被浏览器内部的预加载器（<a href="https://calendar.perfplanet.com/2013/big-bad-preloader/" target="_blank" rel="noopener">preloader</a>）提早发现，但并非所有资源都是基于标签的。有些资源是隐藏在 <code>CSS</code> 和 <code>JavaScript</code> 中的，浏览器不知道页面即将需要这些资源，而等到发现它们时已经为时已晚。所以在有些情况，这些资源延缓了首屏渲染，或是延缓了页面关键部分的加载。而 <code>preload</code> 就告诉浏览器当前页面一定会用到这个资源的，赶紧去获取。</p><blockquote><p>注意 <code>preload</code> 不会阻塞 <code>window.onload</code> 事件，除非该资源是被一个阻塞该事件的资源请求的。</p></blockquote><blockquote><p>加载该资源后，如果 3s 内还没有被当前页面使用，那么控制台会抛出一个警告，故而需要注意！！！</p></blockquote><p><img src="/assets/img/res-prio-timeout.png" alt="res-prio-timeout"></p><p><strong>使用场景：</strong></p><ul><li><p>较早加载字体<br>一种流行的“较晚发现关键资源”的代表是 <code>Web</code> 字体。一方面，它对页面渲染字体很关键（除非你在使用最新的 <code>font-display</code>）。另一方面，它们被埋在 <code>CSS</code> 很深的地方，很难发现。所以对一定需要的字体可以使用 <code>preload</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">as</span>=<span class="string">"font"</span> <span class="attr">crossorigin</span>=<span class="string">"crossorigin"</span> <span class="attr">type</span>=<span class="string">"font/woff2"</span> <span class="attr">href</span>=<span class="string">"myfont.woff2"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>有一点需要指明，获取字体时必须加上 <code>crossorigin</code> 属性，就如使用 <code>CORS</code> 的匿名模式获取一样，即使你的字体与页面同域(否则会被浏览器忽略)。</strong></p></li><li><p>加载关键路径的 <code>CSS</code> 和 <code>JavaScript</code><br>关键路径资源是初始加载所必需的，虽然可以使用内联来达到及时加载的目的，但是却失去了缓存(<code>HTML</code> 是不缓存的，文件太大的话缓存的作用就不明显了)的优势和版本控制(修改关键路径的任何资源都导致整个页面更新，而如果是分开的资源则只需更新部分资源)的优势。</p></li></ul><h3 id="Preconnect"><a href="#Preconnect" class="headerlink" title="Preconnect"></a>Preconnect</h3><p><code>&lt;link rel=&quot;preconnect&quot;&gt;</code> 告诉浏览器你的页面将要与另一个域建立连接，并且想要这个过程尽快开始。</p><p>建立连接在慢网络中通常需要较多的时间来建立，尤其是安全连接时，包括了 <code>DNS</code> 查找、重定向、若干循环才找到能处理用户请求的服务器，不仅完成 <code>DNS</code> 预解析，同时还将进行 <code>TCP</code> 握手和建立传输层协议，而将这些操作提前能提升网页的性能和用户体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>尽量使用 <code>preload</code>，因为它是更为全面的性能提升。</p></blockquote><blockquote><p><code>dns-prefetch</code> 的浏览器支持度会好点，但是这个只是提前做了 <code>DNS</code> 查找，并不进行 <code>TCP</code> 握手和传输层协议的建立。</p></blockquote><p><strong>使用场景：</strong></p><ul><li>知道当前需要获取的资源在哪却不知道具体是什么资源</li><li>流媒体</li></ul><h3 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h3><p>不像 <code>preload</code> 和 <code>preconnect</code> 使用关键资源更早被获取或连接，<code>prefetch</code> 使得那些非关键的资源被下载(如果可能的话)。这个是优先级最低的，在 <code>Chrome</code> 中能看到是 <code>Lowest</code>。</p><p>一般预测用户下一步要干什么并提前准备好，比如加载某个列表的第一项、加载下一页(小说里比较常见).</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"page-2.html"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>prefetch</code> 不能覆盖，如果同时有一个正常请求的资源和一个 <code>prefetch</code> 的相同资源，那么这个资源会被加载两次，一个以高优先级下载，一个以低优先级下载。</p></blockquote><blockquote><p>预获取的资源没有同源限制！</p></blockquote><blockquote><p><code>subresources</code> 是另一个预获取资源的方式，只不过优先级更高，在所有的 <code>prefetch</code> 之前进行。<code>&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt;</code>。</p></blockquote><h2 id="Webpack-优化加载性能"><a href="#Webpack-优化加载性能" class="headerlink" title="Webpack 优化加载性能"></a>Webpack 优化加载性能</h2><p>1.有效利用浏览器缓存：<code>code split</code>，如第三方库、<code>polyfill</code> 单独打包，分离公共库；<code>css</code> 单独提取出一个文件，<code>ExtractTextPlugin</code>。</p><p>2.懒加载：动态引入，<code>import</code>，注意可能需要使用 <code>babel</code> 的 <code>dynamic-webpack-import</code> 插件，不然编译会报错。</p><p>3.减少代码体积：<code>Minification</code>，使用 <code>UglifyJsPlugin</code> 来 <code>minify</code> 代码，生产环境相要对应上源代码需要同时设置 <code>devtool</code> 的值和 <code>UglifyJsPlugin</code> 的 <code>sourceMap</code> 为 <code>true</code>；使用 <code>babel-preset-env</code> 的 <code>useBuiltIns</code> 和 <code>target</code> 来共同控制需要 <code>shim</code> 的 <code>polyfill</code> 代码，尽量少加载垫片，比原来直接 <code>import &#39;babel-polyfill&#39;</code> 要少一部分的垫片；<code>tree-shaking</code> 来去除无用的代码。</p><p>4.图片压缩：使用 <code>image-webpack-loader</code> 来压缩图片，注意 <code>webp</code> 支持度较低，不建议使用。</p><p>5.分析包结构：使用 <code>BundleAnalyzerPlugin</code> 来分析打包后的包结构以及大小，便于后续的优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;渲染性能&quot;&gt;&lt;a href=&quot;#渲染性能&quot; class=&quot;headerlink&quot; title=&quot;渲染性能&quot;&gt;&lt;/a&gt;渲染性能&lt;/h1&gt;&lt;h2 id=&quot;重绘重排&quot;&gt;&lt;a href=&quot;#重绘重排&quot; class=&quot;headerlink&quot; title=&quot;重绘重排&quot;&gt;&lt;/a&gt;重绘重排&lt;/h2&gt;&lt;p&gt;以下三种情况会导致网页重新渲染：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改 DOM&lt;/li&gt;
&lt;li&gt;修改样式表&lt;/li&gt;
&lt;li&gt;用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://1016990109.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://1016990109.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="浏览器" scheme="http://1016990109.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
